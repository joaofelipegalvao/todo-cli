# v0.7.0 - Advanced Filters (--pending, --done)

**ğŸ¯ Goal:** Filter tasks by status with helper function for display

**ğŸ“¦ Implementation:**

**Helper function extracted:**

```rust
fn display_tasks(tasks: &[&str], title: &str) {
    println!("\nğŸ“‹ {}:\n", title);

    let mut completed = 0;
    let total = tasks.len();

    for (i, line) in tasks.iter().enumerate() {
        // ... display logic (same as v0.6.0) ...
    }

    // ... statistics ...
}
```

**Filter logic in list command:**

```rust
"list" => {
    let filter = if args.len() > 2 {
        args[2].as_str()
    } else {
        "all"
    };

    match fs::read_to_string("todos.txt") {
        Ok(content) => {
            let valid_lines: Vec<&str> = content
                .lines()
                .filter(|l| !l.trim().is_empty())
                .collect();

            if valid_lines.is_empty() {
                println!("No tasks");
                return Ok(());
            }

            match filter {
                "--pending" => {
                    let pending: Vec<&str> = valid_lines
                        .iter()
                        .filter(|line| line.contains("[ ]"))
                        .copied()
                        .collect();

                    if pending.is_empty() {
                        println!("No pending tasks");
                    } else {
                        display_tasks(&pending, "Pending tasks");
                    }
                }

                "--done" => {
                    let completed: Vec<&str> = valid_lines
                        .iter()
                        .filter(|line| line.contains("[x]"))
                        .copied()
                        .collect();

                    if completed.is_empty() {
                        println!("No completed tasks");
                    } else {
                        display_tasks(&completed, "Completed tasks");
                    }
                }

                "all" => {
                    display_tasks(&valid_lines, "Tasks");
                }

                _ => {
                    return Err(format!(
                        "Invalid filter: {}. Use --pending or --done",
                        filter
                    ).into());
                }
            }
        }
        Err(_) => {
            println!("No tasks");
        }
    }
}
```

**ğŸ§  Key Concepts:**

### DRY Principle - Don't Repeat Yourself

**Before v0.7.0:** Display logic was duplicated in `list` command  
**After v0.7.0:** Extracted to `display_tasks()` helper function

**Why this matters:**

```rust
// Before: 50+ lines of display code in list command
"list" => {
    // ... filtering ...
    // ... 50 lines of display logic ...
    // ... statistics ...
}

// After: Clean separation
"list" => {
    // ... filtering ...
    display_tasks(&filtered, "Title");  // 1 line!
}

fn display_tasks(tasks: &[&str], title: &str) {
    // ... display logic (reusable) ...
}
```

### Function Signatures and Slices

```rust
fn display_tasks(tasks: &[&str], title: &str) {
    //                    â†‘ slice of string references
}
```

**Why `&[&str]` instead of `Vec<&str>`?**

```rust
// This works but creates unnecessary copy
fn display_tasks(tasks: Vec<&str>) { /* ... */ }

// This is more efficient - borrows without copying
fn display_tasks(tasks: &[&str]) { /* ... */ }
```

**Slice benefits:**

- âœ… No allocation/copying
- âœ… Can accept Vec, array, or another slice
- âœ… More flexible API

### The `.copied()` method

```rust
let pending: Vec<&str> = valid_lines
    .iter()
    .filter(|line| line.contains("[ ]"))
    .copied()  // â† Important!
    .collect();
```

**Why `.copied()` is needed:**

```rust
valid_lines.iter()  // Returns Iterator<Item = &&str>
                    //                    â†‘ double reference!

.filter(|line| line.contains("[ ]"))  // &&str â†’ bool
// After filter, we still have &&str

.copied()  // &&str â†’ &str (copies the reference)
```

**Without `.copied()`:**

```rust
// Type mismatch error!
let pending: Vec<&str> = valid_lines
    .iter()
    .filter(|line| line.contains("[ ]"))
    .collect();  // Tries to collect Vec<&&str>
```

### Pipeline Architecture

**The filtering pipeline:**

```rust
let pending: Vec<&str> = valid_lines
    .iter()                    // Step 1: Get iterator
    .filter(|line| line.contains("[ ]"))  // Step 2: Filter
    .copied()                  // Step 3: Fix reference type
    .collect();                // Step 4: Build Vec
```

**This is functional programming:**

- Each step transforms data
- Steps are composable
- No intermediate variables needed
- Easy to read and modify

### Error Handling with `format!`

```rust
return Err(format!(
    "Invalid filter: {}. Use --pending or --done",
    filter
).into());
```

**Breaking it down:**

```rust
format!("Invalid filter: {}. Use --pending or --done", filter)
// Creates String with dynamic content

.into()  // String â†’ Box<dyn Error>
// Converts to error type expected by function
```

**Why `format!` instead of `println!` style?**

- `format!` returns String (can be used in error)
- `println!` prints to console (can't be used in error)
- Same syntax, different purpose

### Match Expression as Filter Router

```rust
match filter {
    "--pending" => { /* pending logic */ }
    "--done" => { /* done logic */ }
    "all" => { /* all logic */ }
    _ => { /* error case */ }
}
```

**This is a routing pattern:**

- Each arm handles one filter type
- `_` catches invalid filters
- Easy to add new filters later

**ğŸ”— Resources:**

- [Code v0.7.0](https://github.com/joaofelipegalvao/todo-cli/tree/v0.7.0)
- [Full diff](https://github.com/joaofelipegalvao/todo-cli/compare/v0.6.0...v0.7.0)