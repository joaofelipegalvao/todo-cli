{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83e\udd80 Todo CLI Learning Docs","text":"<p>Complete learning journey from basic CLI to professional task manager</p> <p>This docs contains the complete documentation of how the todo-cli project evolved, version by version. Each version represents a learning milestone with detailed explanations of concepts, design decisions, and implementation details.</p>"},{"location":"#navigation","title":"Navigation","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>For beginners learning Rust and CLI development:</p> <ul> <li>v0.1.0 - Basic CLI - First CLI with add/list</li> <li>v0.2.0 - Done Command - Mark tasks as completed</li> <li>v0.3.0 - Remove Command - Delete specific tasks</li> <li>v0.4.0 - Undone Command - Unmark completed tasks</li> <li>v0.4.1 - List Bug Fix - Handle empty lines properly</li> <li>v0.4.2 - State Validations - Prevent invalid state transitions</li> <li>v0.5.0 - Clear Command - Remove all tasks at once</li> </ul>"},{"location":"#intermediate-features","title":"Intermediate Features","text":"<p>For those comfortable with Rust basics:</p> <ul> <li>v0.6.0 - Visual Interface with Colors - Add colorful visual hierarchy</li> <li>v0.7.0 - Advanced Filters - Filter by status with helper functions</li> <li>v0.8.0 - Priority System - Three-level priority with visual indicators</li> <li>v0.9.0 - Priority Sorting - Sort tasks by priority</li> <li>v1.0.0 - Search + Refactoring - Add search and refactor display</li> <li>v1.1.0 - Medium Priority Filter - Complete priority filtering system</li> </ul>"},{"location":"#advanced-architecture","title":"Advanced Architecture","text":"<p>For experienced developers:</p> <ul> <li>v1.2.0 - Struct Refactoring - Type-safe architecture with structs/enums</li> <li>v1.3.0 - JSON Serialization - Replace custom format with serde</li> <li>v1.4.0 - Tags System - Add categorization with tags</li> <li>v1.5.0 - Due Dates + Tabular Display - Deadline tracking with chrono</li> <li>v1.6.0 - Professional CLI with Clap - Industry-standard CLI framework</li> <li>v1.7.0 - Professional Error Handling - \u2b50 NEW: anyhow + thiserror</li> </ul>"},{"location":"#cross-cutting-concepts","title":"Cross-Cutting Concepts","text":"<p>Key patterns and best practices used throughout the project:</p> <ul> <li>Error Handling - From basic <code>?</code> to professional error messages</li> <li>Advanced Error Handling - \u2b50 NEW: Deep dive into anyhow + thiserror</li> <li>File Operations - File I/O patterns and JSON serialization</li> <li>CLI Design - Command-line interface patterns and user experience</li> <li>Type Safety - Using Rust's type system to prevent bugs</li> </ul>"},{"location":"#project-evolution","title":"Project Evolution","text":"<pre><code>v0.1: String matching everywhere\n   \u2193\nv1.2: Type-safe structs and enums (36% reduction)\n   \u2193\nv1.3: Automatic JSON serialization (91% I/O reduction)\n   \u2193\nv1.4: Extensible with tags (1 line = new feature)\n   \u2193\nv1.5: Due dates + tabular display (deadline tracking + professional UX)\n   \u2193\nv1.6: Clap + ValueEnum (zero manual parsing, compile-time safety)\n   \u2193\nv1.7: anyhow + thiserror (professional error handling) \u2b50 NEW\n</code></pre>"},{"location":"#version-summary","title":"Version Summary","text":"Version Feature Key Concepts Lines of Code v0.1.0 Basic CLI <code>OpenOptions</code>, <code>match</code>, <code>?</code> ~50 v0.2.0 Done Command <code>.map()</code>, <code>.collect()</code>, <code>Vec&lt;String&gt;</code> ~80 v0.3.0 Remove Command Index validation, <code>Vec::remove()</code> ~100 v0.4.0 Undone Command State machine, inverse operations ~120 v0.5.0 Clear Command <code>fs::metadata()</code>, idempotent operations ~130 v0.6.0 Visual Interface <code>colored</code> crate, visual hierarchy ~180 v0.7.0 Advanced Filters Helper functions, DRY principle ~200 v0.8.0 Priority System <code>Option&lt;T&gt;</code>, pattern matching, pipeline ~250 v0.9.0 Priority Sorting <code>.sort_by()</code>, <code>Ordering</code>, optimization ~270 v1.0.0 Search + Refactoring Atomic functions, separation of concerns ~290 v1.1.0 Medium Filter API completeness, symmetry design ~300 v1.2.0 Struct Refactoring Type safety, 36% code reduction ~115 v1.3.0 JSON Serialization Serde, 91% I/O reduction ~5 v1.4.0 Tags System <code>Vec&lt;String&gt;</code>, <code>.retain()</code>, bug fixes ~120 v1.5.0 Due Dates <code>chrono</code>, date arithmetic, tabular display ~150 v1.6.0 Professional CLI Clap, <code>ValueEnum</code>, zero manual parsing ~80 v1.7.0 Error Handling <code>anyhow</code>, <code>thiserror</code>, error chains ~85"},{"location":"#learning-path","title":"Learning Path","text":""},{"location":"#path-1-complete-beginner-01-11","title":"Path 1: Complete Beginner (0.1 \u2192 1.1)","text":"<p>Start here if you're new to Rust:</p> <ol> <li>Basics (v0.1-v0.5) - Syntax, ownership, error handling</li> <li>Visual Polish (v0.6-v0.7) - Crates, user experience</li> <li>Advanced Features (v0.8-v1.1) - Enums, Options, patterns</li> </ol> <p>Time: 2-3 weeks Outcome: Comfortable with Rust fundamentals</p>"},{"location":"#path-2-architecture-focus-12-17","title":"Path 2: Architecture Focus (1.2 \u2192 1.7)","text":"<p>For those wanting to learn professional Rust patterns:</p> <ol> <li>Type Safety (v1.2) - Structs and enums</li> <li>Serialization (v1.3) - Serde patterns</li> <li>CLI Frameworks (v1.6) - Clap derive macros</li> <li>Error Handling (v1.7) - anyhow + thiserror \u2b50</li> </ol> <p>Time: 1-2 weeks Outcome: Production-ready Rust architecture</p>"},{"location":"#path-3-error-handling-deep-dive-new","title":"Path 3: Error Handling Deep Dive (NEW)","text":"<p>Focus on professional error management:</p> <ol> <li>Basic errors (v0.1-v0.4) - <code>?</code> operator, validation</li> <li>Generic errors (v1.2-v1.6) - <code>Box&lt;dyn Error&gt;</code></li> <li>Professional errors (v1.7) - anyhow + thiserror \u2b50</li> <li>Concepts - Advanced Error Handling</li> </ol> <p>Time: 3-4 days Outcome: Master Rust error handling</p>"},{"location":"#key-achievements","title":"Key Achievements","text":""},{"location":"#code-quality","title":"Code Quality","text":"<ul> <li>36% reduction in total lines after struct refactoring</li> <li>91% reduction in I/O code after JSON migration</li> <li>Zero manual parsing after adopting clap</li> <li>Type safety from command line to storage</li> <li>Professional error handling with context chains (v1.7.0) \u2b50</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>\u2705 Complete CRUD operations</li> <li>\u2705 Priority system with visual indicators</li> <li>\u2705 Advanced filters and search</li> <li>\u2705 Tags for categorization</li> <li>\u2705 Due dates with deadline tracking</li> <li>\u2705 Professional CLI with auto-help</li> <li>\u2705 Type-safe architecture throughout</li> <li>\u2705 Rich error messages with context \u2b50 NEW</li> </ul>"},{"location":"#learning-outcomes","title":"Learning Outcomes","text":"<ol> <li>Rust fundamentals through practical application</li> <li>CLI design patterns that feel natural to users</li> <li>Type safety - using compiler to prevent bugs</li> <li>Refactoring strategy - evolve code without breaking it</li> <li>Professional development - industry-standard patterns</li> </ol>"},{"location":"#technical-stack","title":"Technical Stack","text":"<ul> <li>Language: Rust \ud83e\udd80</li> <li>CLI Framework: Clap (v1.6.0+)</li> <li>Serialization: Serde + JSON</li> <li>Colors: Colored crate</li> <li>Dates: Chrono</li> <li>File Format: JSON (v1.3.0+)</li> </ul>"},{"location":"#potential-future-versions","title":"Potential Future Versions","text":"<ul> <li>v1.8: Subtasks/nested tasks with recursive data structures</li> <li>v1.9: Multiple projects/contexts</li> <li>v2.0: TUI with <code>ratatui</code></li> <li>v2.1: Configuration file with <code>config</code> crate</li> <li>v2.2: Shell completions (bash, zsh, fish)</li> <li>v2.3: Export/import (CSV, JSON, Markdown)</li> <li>v2.4: Sync with cloud storage</li> <li>v2.5: Web API with <code>axum</code></li> <li>v3.0: Plugin system</li> </ul>"},{"location":"#for-students","title":"For Students","text":"<ol> <li>Read chronologically - Start with v0.1.0 and progress through versions</li> <li>Study the code - Each version links to the exact commit</li> <li>Understand the \"why\" - Each version explains design decisions</li> <li>Try the concepts - Implement similar patterns in your projects</li> <li>Compare approaches - See how code evolved from strings to structs</li> </ol>"},{"location":"#learning-goals","title":"Learning Goals","text":"<ul> <li>Rust fundamentals: Ownership, borrowing, lifetimes, error handling</li> <li>CLI design: Subcommands, flags, help generation, user experience</li> <li>Code organization: When to use functions, structs, enums</li> <li>Type safety: How to use Rust's type system to prevent bugs</li> <li>Refactoring: How to evolve code without breaking functionality</li> <li>Professional development: Industry-standard patterns and tools</li> </ul>"},{"location":"#for-each-version","title":"For Each Version","text":"<ol> <li>Read the documentation - Understand the goals and concepts</li> <li>Examine the code - Look at the actual implementation</li> <li>Study the diff - See what changed from previous version</li> <li>Run the code - Test the functionality yourself</li> <li>Experiment - Try modifying and extending the features</li> </ol>"},{"location":"#next-steps","title":"Next Steps","text":"<p>The CLI is now production-ready and serves as an excellent foundation for learning more advanced Rust concepts:</p>"},{"location":"#learning-extensions","title":"Learning Extensions","text":"<p>Each future version would teach new Rust concepts while building on the solid foundation established here.</p> <p>The beauty of this architecture: All new features benefit from the type-safe, extensible foundation built through careful refactoring.</p> <p>\ud83e\udd80 Happy learning!</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/#planned","title":"Planned","text":"<ul> <li>Edit command</li> <li>Recurring tasks</li> <li>Subtasks/nested tasks</li> <li>Export/import commands</li> <li>Shell completions (bash, zsh, fish)</li> <li>Unit tests</li> <li>TUI (Terminal User Interface)</li> </ul>"},{"location":"CHANGELOG/#170-2026-02-07","title":"1.7.0 - 2026-02-07","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Professional error handling using <code>anyhow</code> and <code>thiserror</code> crates</li> <li><code>TodoError</code> enum for domain-specific errors with rich data</li> <li>Custom error variants:</li> <li><code>InvalidTaskId { id, max }</code> - Shows valid range in error message</li> <li><code>TaskAlreadyInStatus { id, status }</code> - Prevents duplicate state changes</li> <li><code>TagNotFound(String)</code> - Clear message when filtering by non-existent tag</li> <li><code>NoTasksFound</code> - Better UX when filters return empty results</li> <li><code>NoTagsFound</code> - Informative message when no tags exist</li> <li><code>NoSearchResults(String)</code> - Shows search query in error message</li> <li><code>validate_task_id()</code> helper function for centralized ID validation</li> <li>Error chain display in <code>main()</code> - Shows full \"Caused by:\" chain</li> <li>Rich context with <code>.context()</code> on all operations</li> <li>Specific error messages for each failure mode</li> <li>Pattern matching on <code>std::io::ErrorKind</code> for granular error handling</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>BREAKING CHANGE: Error type migrated from <code>Box&lt;dyn Error&gt;</code> to <code>anyhow::Result</code></li> <li>All function signatures updated to use <code>Result&lt;T&gt;</code> (shorthand for <code>Result&lt;T, anyhow::Error&gt;</code>)</li> <li><code>load_tasks()</code>: Added context for parse failures and read errors</li> <li><code>save_tasks()</code>: Added context for serialization and write failures</li> <li><code>done</code> command: Added validation for already-completed tasks</li> <li><code>undone</code> command: Added validation for already-pending tasks</li> <li><code>remove</code> command: Uses centralized <code>validate_task_id()</code></li> <li><code>list</code> command: Returns <code>TodoError::NoTasksFound</code> instead of printing</li> <li><code>search</code> command: Returns <code>TodoError::NoSearchResults</code> instead of printing</li> <li><code>tags</code> command: Returns <code>TodoError::NoTagsFound</code> instead of printing</li> <li>Error display: Shows colored \"Error:\" prefix and \"Caused by:\" chain</li> <li><code>main()</code>: Enhanced error display with full error chain traversal</li> </ul>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Clippy warning in <code>get_due_text()</code> - Removed redundant <code>else if</code> block</li> <li>Generic error messages replaced with specific, actionable messages</li> <li>Lost error context - Now displays full error chain</li> <li>User confusion about error causes - Shows root cause with \"Caused by:\"</li> <li>Missing context in file operations - All I/O now includes file path context</li> <li>State validation gaps - All state transitions now validated</li> </ul>"},{"location":"CHANGELOG/#160-2026-02-04","title":"1.6.0 - 2026-02-04","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Professional CLI framework using <code>clap</code> crate (v4.5) with derive macros</li> <li>Type-safe filtering with enum-based arguments</li> <li><code>StatusFilter</code> enum: <code>All</code>, <code>Pending</code>, <code>Done</code> (replaces boolean flags)</li> <li><code>DueFilter</code> enum: <code>Overdue</code>, <code>Soon</code>, <code>WithDue</code>, <code>NoDue</code> (replaces 4 boolean flags)</li> <li><code>SortBy</code> enum: <code>Priority</code>, <code>Due</code>, <code>Created</code> (replaces string-based sorting)</li> <li><code>ValueEnum</code> trait implementation on <code>Priority</code> for CLI value parsing</li> <li>Auto-generated help text with <code>#[command()]</code> attributes</li> <li>Command-level help with <code>long_about</code> descriptions</li> <li>Argument-level help with doc comments (appear in <code>--help</code> output)</li> <li>Command aliases for improved productivity:</li> <li><code>a</code> for <code>add</code></li> <li><code>ls</code> for <code>list</code></li> <li><code>rm</code> and <code>delete</code> for <code>remove</code></li> <li>Automatic argument parsing with type safety and validation</li> <li>Automatic NaiveDate parsing using <code>clap::value_parser!(NaiveDate)</code></li> <li>Professional error messages with context and suggestions</li> <li><code>Cli</code> struct with <code>#[derive(Parser)]</code> for top-level command handling</li> <li><code>Commands</code> enum with <code>#[derive(Subcommand)]</code> for subcommand routing</li> <li><code>AddArgs</code> struct with <code>#[derive(Args)]</code> for complex add command arguments</li> <li>Short flags: <code>-t</code> for <code>--tag</code>, <code>-s</code> for <code>--sort</code></li> <li>Repeatable arguments: <code>--tag</code> can be used multiple times</li> <li><code>Task::matches_status()</code> helper method for status filtering</li> <li><code>Task::matches_due_filter()</code> helper method for due date filtering</li> <li>Metadata in help output: program name, author, version, examples</li> <li><code>after_help</code> examples section showing common usage patterns</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>BREAKING CHANGE: Complete CLI interface redesigned with Clap</li> <li>BREAKING CHANGE: Command syntax updated across all commands:</li> <li><code>--high/--medium/--low</code> \u2192 <code>--priority high/medium/low</code></li> <li><code>--pending/--done</code> \u2192 <code>--status pending/done/all</code></li> <li><code>--overdue/--due-soon/--with-due/--without-due</code> \u2192 <code>--due overdue/soon/with-due/no-due</code></li> <li><code>--sort</code> \u2192 <code>--sort priority/due/created</code></li> <li>BREAKING CHANGE: Priority values in JSON now lowercase (<code>\"high\"</code>, <code>\"medium\"</code>, <code>\"low\"</code>)</li> <li><code>Priority</code> enum: Added <code>ValueEnum</code> derive for CLI integration</li> <li>Argument parsing: Manual <code>env::args()</code> parsing \u2192 Clap derive macros</li> <li>Help generation: Manual help strings \u2192 Automatic from struct attributes</li> <li>Validation: Manual conflict checking \u2192 Automatic with type system</li> <li>Error messages: Generic strings \u2192 Contextual clap-generated errors</li> <li><code>main()</code> function: Simplified with <code>Cli::parse()</code> handling all parsing</li> <li>Filter mutual exclusion: Runtime checks \u2192 Compile-time type safety with enums</li> <li>Boolean filter flags (4 for dates) \u2192 Single <code>Option&lt;DueFilter&gt;</code> enum</li> <li>Parsing complexity: ~100 lines of manual parsing \u2192 ~20 lines of declarative structs</li> <li>Code organization: Flat argument handling \u2192 Structured with dedicated types</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Manual argument parsing with <code>env::args().collect()</code></li> <li>Manual flag conflict validation (15+ lines)</li> <li>Manual help text construction</li> <li>Generic \"Usage: ...\" error messages</li> <li>Manual <code>NaiveDate</code> parsing and error handling (8 lines \u2192 1 line with <code>value_parser!</code>)</li> <li>Boolean flags for status filters (<code>--pending</code>, <code>--done</code>)</li> <li>Boolean flags for priority filters (<code>--high</code>, <code>--medium</code>, <code>--low</code>)</li> <li>Boolean flags for date filters (<code>--overdue</code>, <code>--due-soon</code>, <code>--with-due</code>, <code>--without-due</code>)</li> <li>String-based sorting validation</li> </ul>"},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>Eliminated possibility of conflicting filter flags (enforced by type system)</li> <li>Improved error messages with suggestions for typos (e.g., \"did you mean 'high'?\")</li> <li>Consistent argument naming across all commands</li> <li>Professional command-line interface matching industry standards</li> </ul>"},{"location":"CHANGELOG/#technical-details","title":"Technical Details","text":"<ul> <li>Dependencies:</li> <li>Added: <code>clap = { version = \"4.5\", features = [\"derive\"] }</code></li> <li>Enables derive macros for declarative CLI definition</li> <li>Code reduction: ~100 lines of parsing code \u2192 ~20 lines of struct definitions</li> <li>Type safety improvements:</li> <li><code>StatusFilter</code> enum prevents invalid status values at compile time</li> <li><code>DueFilter</code> enum ensures only one date filter used (via <code>Option&lt;T&gt;</code>)</li> <li><code>SortBy</code> enum validates sort fields at compile time</li> <li><code>Priority</code> as <code>ValueEnum</code> enables automatic CLI parsing</li> <li>Derive macros used:</li> <li><code>#[derive(Parser)]</code> on <code>Cli</code> - top-level command parsing</li> <li><code>#[derive(Subcommand)]</code> on <code>Commands</code> - subcommand routing</li> <li><code>#[derive(Args)]</code> on <code>AddArgs</code> - grouped arguments for complex commands</li> <li><code>#[derive(ValueEnum)]</code> on enums - enables use as CLI values</li> <li>Attribute annotations:</li> <li><code>#[command(name, author, version, about, after_help)]</code> - metadata</li> <li><code>#[arg(long, short, value_enum, default_value_t)]</code> - argument configuration</li> <li><code>#[command(visible_alias)]</code> - command aliases</li> <li>Doc comments (<code>///</code>) automatically become help text</li> <li>Pattern matching:</li> <li><code>Option&lt;DueFilter&gt;</code> enables <code>if let Some(filter)</code> pattern for optional filters</li> <li><code>match</code> on enums is exhaustive (compiler enforces handling all cases)</li> <li>Automatic behaviors:</li> <li><code>--help</code> and <code>-h</code> flags generated automatically</li> <li><code>--version</code> and <code>-V</code> flags generated automatically</li> <li>Error handling with exit codes (0 for success, non-zero for errors)</li> <li>Suggestions for typos in values (e.g., \"hgh\" suggests \"high\")</li> <li>Color-coded help output in supported terminals</li> <li>Integration points:</li> <li><code>Cli::parse()</code> consumes <code>std::env::args()</code> automatically</li> <li><code>value_parser!(NaiveDate)</code> uses <code>FromStr</code> trait from chrono</li> <li>Enums with <code>ValueEnum</code> get case-insensitive parsing by default</li> </ul>"},{"location":"CHANGELOG/#migration-notes","title":"Migration Notes","text":"<p>Upgrading from v1.5.0:</p> <p>Command syntax changes required:</p> <pre><code># Old (v1.5.0):\ntodo add \"Task\" --high --tag work\ntodo list --pending --high --overdue --sort\n\n# New (v1.6.0):\ntodo add \"Task\" --priority high --tag work\ntodo list --status pending --priority high --due overdue --sort priority\n</code></pre> <p>Complete syntax mapping:</p> Old Flag (v1.5.0) New Argument (v1.6.0) <code>--high</code> <code>--priority high</code> <code>--medium</code> <code>--priority medium</code> <code>--low</code> <code>--priority low</code> <code>--pending</code> <code>--status pending</code> <code>--done</code> <code>--status done</code> <code>--overdue</code> <code>--due overdue</code> <code>--due-soon</code> <code>--due soon</code> <code>--with-due</code> <code>--due with-due</code> <code>--without-due</code> <code>--due no-due</code> <code>--sort</code> (bool) <code>--sort priority\\|due\\|created</code> <p>Data compatibility:</p> <ul> <li>JSON file format (<code>todos.json</code>) remains fully compatible</li> <li>Priority values in JSON change from <code>\"High\"</code> to <code>\"high\"</code> (lowercase)</li> <li>Existing tasks automatically migrate on first load</li> <li>No manual data migration needed</li> <li>All task data, tags, and dates preserved</li> </ul> <p>New features available:</p> <ul> <li>Use <code>todo --help</code> for comprehensive command help</li> <li>Use <code>todo &lt;command&gt; --help</code> for command-specific help</li> <li>Try command aliases: <code>todo a</code>, <code>todo ls</code>, <code>todo rm</code></li> <li>Explore short flags: <code>-t</code> for tags, <code>-s</code> for sort</li> </ul> <p>Breaking changes to address:</p> <ol> <li>Update any scripts using the old flag syntax</li> <li>Priority values in JSON will be lowercase after first save</li> <li>Sorting now requires explicit field name (not just <code>--sort</code>)</li> <li>Status filter now explicit (no implicit \"all\" without flag)</li> </ol>"},{"location":"CHANGELOG/#150-2026-02-03","title":"1.5.0 - 2026-02-03","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>Due date tracking with <code>chrono</code> crate</li> <li><code>due_date</code> field in <code>Task</code> struct (<code>Option&lt;NaiveDate&gt;</code>)</li> <li><code>created_at</code> field in <code>Task</code> struct (<code>NaiveDate</code>) - automatic timestamp on task creation</li> <li><code>--due YYYY-MM-DD</code> flag for <code>add</code> command to set task deadlines</li> <li><code>--overdue</code> filter to list tasks past their due date</li> <li><code>--due-soon</code> filter to list tasks due in the next 7 days</li> <li><code>--with-due</code> filter to list tasks that have a due date</li> <li><code>--without-due</code> filter to list tasks without a due date</li> <li><code>--sort due</code> option to sort tasks by due date (earliest first)</li> <li><code>--sort created</code> option to sort tasks by creation date (oldest first)</li> <li><code>Task::is_overdue()</code> method to check if task is past due date</li> <li><code>Task::is_due_soon(days: i64)</code> method to check if task is due within N days</li> <li>Date parsing with <code>NaiveDate::parse_from_str()</code> using format <code>%Y-%m-%d</code></li> <li>Color-coded due date display:</li> <li>Red + Bold: Overdue (e.g., \"late 3 days\")</li> <li>Yellow + Bold: Due today (e.g., \"due today\")</li> <li>Yellow: Due soon, 1-7 days (e.g., \"in 5 days\")</li> <li>Cyan: Future, 8+ days (e.g., \"in 30 days\")</li> <li>Tabular display format for professional task listing</li> <li>Dynamic column width calculation based on content</li> <li><code>display_task_tabular()</code> function for formatted output</li> <li><code>calculate_column_widths()</code> function for optimal column sizing</li> <li><code>get_due_text()</code> function for human-readable due date formatting</li> <li><code>get_due_colored()</code> function for urgency-based coloring</li> <li>Header row with column labels: <code>ID</code>, <code>P</code> (Priority), <code>S</code> (Status), <code>Task</code>, <code>Tags</code>, <code>Due</code></li> <li>Separator line for visual clarity</li> <li>String truncation with ellipsis for long task names and tags</li> <li>Date arithmetic using <code>chrono::Duration</code> for calculating days until due</li> </ul>"},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>BREAKING CHANGE: Priority display changed from emojis (\ud83d\udd34\ud83d\udfe1\ud83d\udfe2) to letters (H/M/L)</li> <li><code>Priority::emoji()</code> renamed to <code>Priority::letter()</code></li> <li>More professional and terminal-friendly appearance</li> <li>Consistent column width in tabular format</li> <li>BREAKING CHANGE: Task display format completely redesigned</li> <li>Old: <code>1. \ud83d\udd34 \u23f3 Study Rust [learning, programming]</code></li> <li>New: Tabular format with aligned columns</li> </ul> <pre><code>  ID  P  S  Task           Tags              Due\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1  H  \u23f3  Study Rust     learning, prog... in 5 days\n</code></pre> <ul> <li><code>Task::new()</code> signature: now accepts <code>due_date: Option&lt;NaiveDate&gt;</code> parameter</li> <li><code>Task</code> JSON format: includes <code>due_date</code> (nullable) and <code>created_at</code> (required)</li> <li><code>--sort</code> flag: renamed from boolean to value-based (<code>priority</code>, <code>due</code>, <code>created</code>)</li> <li>Due date sorting: tasks with dates come before tasks without dates</li> <li>Completed tasks no longer display due date information</li> <li>Maximum column widths enforced (task: 40 chars, tags: 20 chars, due: 20 chars)</li> <li>Minimum column widths enforced (task: 10 chars, tags: 4 chars, due: 3 chars)</li> </ul>"},{"location":"CHANGELOG/#fixed_2","title":"Fixed","text":"<ul> <li>Mutual exclusion validation for date filters (can't use multiple date filters together)</li> <li>Proper handling of <code>None</code> values in due date sorting</li> <li>Grammar in due date text (\"1 day\" vs \"2 days\")</li> <li>Visual hierarchy with color-coding guides attention to urgent items</li> </ul>"},{"location":"CHANGELOG/#technical-details_1","title":"Technical Details","text":"<ul> <li><code>chrono</code> crate added with <code>serde</code> feature for automatic date serialization</li> <li><code>NaiveDate</code> used for dates (no timezone information needed for due dates)</li> <li>Date creation: <code>Local::now().naive_local().date()</code> for current date</li> <li>Date comparison: direct comparison operators (<code>&lt;</code>, <code>&gt;</code>, <code>==</code>) work on <code>NaiveDate</code></li> <li>Pattern matching on <code>Option&lt;NaiveDate&gt;</code> for flexible due date handling</li> <li>Format specifiers: <code>{:&gt;3}</code> (right-align), <code>{:&lt;40}</code> (left-align with width)</li> <li>String slicing for truncation: <code>&amp;text[..width-3]</code> with \"...\" suffix</li> <li>Four-way pattern matching in due date sort for handling <code>Option</code> combinations</li> <li>Tabular format uses <code>print!()</code> for inline formatting and <code>println!()</code> for line breaks</li> <li>Date filters use <code>retain()</code> to preserve task indices</li> </ul>"},{"location":"CHANGELOG/#migration-notes_1","title":"Migration Notes","text":"<p>Upgrading from v1.4.0:</p> <ul> <li>Old tasks remain compatible - <code>due_date</code> defaults to <code>null</code></li> <li><code>created_at</code> will be set to current date on first load for existing tasks</li> <li>No data loss - all existing fields preserved</li> <li>New fields can be added manually to JSON if needed</li> <li>Priority indicators will display as letters instead of emojis</li> </ul>"},{"location":"CHANGELOG/#140-2026-01-31","title":"1.4.0 - 2026-01-31","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Tags system for task categorization</li> <li><code>tags</code> field in <code>Task</code> struct (<code>Vec&lt;String&gt;</code>)</li> <li><code>--tag &lt;name&gt;</code> flag for <code>add</code> command (can be used multiple times)</li> <li><code>--tag &lt;name&gt;</code> filter for <code>list</code> command</li> <li><code>--tag &lt;name&gt;</code> filter for <code>search</code> command</li> <li><code>tags</code> command to list all tags with task counts</li> <li>Tag display in task output (colored cyan for pending, dimmed for completed)</li> </ul>"},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li><code>Task::new()</code> signature: now accepts <code>tags: Vec&lt;String&gt;</code> parameter</li> <li><code>display_task()</code>: Added tag display after task text</li> <li><code>list</code> command: Added tag filtering with <code>--tag</code> flag</li> <li><code>search</code> command: Added tag filtering with <code>--tag</code> flag</li> <li>Task display format: shows tags as <code>[tag1, tag2]</code> after task text</li> </ul>"},{"location":"CHANGELOG/#fixed_3","title":"Fixed","text":"<ul> <li>Critical bug: Task numbering now maintains original indices when filtering</li> <li>Before: Filtered lists showed renumbered tasks (1, 2, 3...), causing <code>done</code>/<code>undone</code>/<code>remove</code> to operate on wrong tasks</li> <li>After: Filtered lists show original task numbers, ensuring commands work correctly</li> <li>Changed <code>display_lists()</code> to accept <code>Vec&lt;(usize, &amp;Task)&gt;</code> with original indices</li> <li>All filter operations now use <code>retain()</code> instead of <code>filter().collect()</code> to preserve indices</li> </ul>"},{"location":"CHANGELOG/#technical-details_2","title":"Technical Details","text":"<ul> <li>Tags are stored as <code>Vec&lt;String&gt;</code> in JSON</li> <li>Empty tag vectors serialize to <code>[]</code> in JSON</li> <li>Tag filtering is case-sensitive (matches exact tag names)</li> <li><code>tags</code> command deduplicates and sorts tags alphabetically</li> <li>Original task numbering preserved through tuple <code>(usize, &amp;Task)</code> pattern</li> <li>Serde automatically handles tags serialization/deserialization</li> </ul>"},{"location":"CHANGELOG/#130-2026-01-30","title":"1.3.0 - 2026-01-30","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li>JSON serialization using <code>serde</code> and <code>serde_json</code></li> <li>Automatic serialization/deserialization with derive macros</li> <li><code>#[derive(Serialize, Deserialize)]</code> on <code>Task</code> and <code>Priority</code></li> <li>Pretty-printed JSON output with <code>to_string_pretty()</code></li> <li>Automatic type validation and descriptive error messages</li> <li>Universal format support (JSON as standard)</li> </ul>"},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>BREAKING CHANGE: File format migrated from custom text (<code>todos.txt</code>) to JSON (<code>todos.json</code>)</li> <li><code>load_tasks()</code>: Replaced manual parsing with <code>serde_json::from_str()</code> (12 lines \u2192 3 lines)</li> <li><code>save_tasks()</code>: Replaced manual formatting with <code>serde_json::to_string_pretty()</code> (4 lines \u2192 2 lines)</li> <li>Storage file: <code>todos.txt</code> \u2192 <code>todos.json</code></li> <li><code>clear</code> command: Updated to delete <code>todos.json</code> instead of <code>todos.txt</code></li> </ul>"},{"location":"CHANGELOG/#removed_1","title":"Removed","text":"<ul> <li><code>Task::to_line()</code> method - replaced by automatic serialization (12 lines deleted)</li> <li><code>Task::from_line()</code> method - replaced by automatic deserialization (25 lines deleted)</li> <li>All custom text parsing logic (37 lines total)</li> </ul>"},{"location":"CHANGELOG/#technical-details_3","title":"Technical Details","text":"<ul> <li>91% code reduction in I/O operations (53 lines \u2192 5 lines)</li> <li>Serde generates 100+ lines of optimized serialization code automatically</li> <li>Format-agnostic design allows easy migration to TOML, YAML, or binary formats</li> <li>Extensibility: Adding new fields now requires only 1 line (struct field) instead of 30+ lines (parser updates)</li> <li>Better error messages: \"missing field <code>priority</code> at line 4 column 3\" vs generic parsing errors</li> <li>Git-friendly: JSON diffs clearly show what changed</li> <li>Tooling support: Can use <code>jq</code>, JSON validators, formatters, etc.</li> </ul>"},{"location":"CHANGELOG/#migration-notes_2","title":"Migration Notes","text":"<p>Users need to migrate from <code>todos.txt</code> to <code>todos.json</code>:</p> <ul> <li>Option 1: Start fresh (delete <code>todos.txt</code>, recreate tasks)</li> <li>Option 2: Manual migration (convert old format to JSON)</li> <li>Future: Migration script could be provided</li> </ul>"},{"location":"CHANGELOG/#120-2026-01-29","title":"1.2.0 - 2026-01-29","text":""},{"location":"CHANGELOG/#added_5","title":"Added","text":"<ul> <li>Type-safe architecture with structs and enums</li> <li><code>Priority</code> enum (High, Medium, Low) replacing string-based priorities</li> <li><code>Task</code> struct encapsulating task data (text, completed, priority)</li> <li><code>impl</code> blocks with methods: <code>new()</code>, <code>to_line()</code>, <code>from_line()</code>, <code>mark_done()</code>, <code>mark_undone()</code></li> <li>Centralized I/O with <code>load_tasks()</code> and <code>save_tasks()</code> helper functions</li> <li>Derive macros: <code>Debug</code>, <code>Clone</code>, <code>PartialEq</code>, <code>Copy</code> for type safety</li> </ul>"},{"location":"CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li>BREAKING CHANGE: Complete refactoring from string parsing to struct-based architecture</li> <li>All commands now use <code>Task</code> struct instead of raw string manipulation</li> <li>Parsing logic centralized in <code>Task::from_line()</code> method</li> <li>File I/O consolidated into two functions (36% code reduction)</li> <li><code>add</code> command: uses <code>Task::new()</code> constructor</li> <li><code>done</code>/<code>undone</code> commands: use <code>task.mark_done()</code>/<code>task.mark_undone()</code> methods</li> <li><code>list</code> command: type-safe field access (<code>task.completed</code>, <code>task.priority</code>)</li> <li>Priority comparison: string matching \u2192 enum comparison</li> <li>Display logic: uses <code>Priority::emoji()</code> and <code>Priority::order()</code> methods</li> </ul>"},{"location":"CHANGELOG/#fixed_4","title":"Fixed","text":"<ul> <li>Ownership issues with priority filters using <code>Copy</code> trait</li> <li>Clippy warnings: redundant closures replaced with function pointers</li> <li>Type safety: compiler now catches priority typos at compile time</li> </ul>"},{"location":"CHANGELOG/#technical-details_4","title":"Technical Details","text":"<ul> <li>Code metrics: ~180 lines \u2192 ~115 lines (36% reduction)</li> <li>Maintainability: Adding new fields now requires changes in only 3 places instead of 7+</li> <li>Extensibility: Easy to add timestamps, tags, subtasks in future versions</li> <li>Type safety: No more runtime errors from typos like <code>\"hihg\"</code></li> </ul>"},{"location":"CHANGELOG/#110-2026-01-28","title":"1.1.0 - 2026-01-28","text":""},{"location":"CHANGELOG/#added_6","title":"Added","text":"<ul> <li><code>--medium</code> flag to filter tasks by medium priority</li> <li>Complete symmetry in priority filtering (high/medium/low)</li> <li>Dynamic titles for medium priority task combinations</li> </ul>"},{"location":"CHANGELOG/#changed_6","title":"Changed","text":"<ul> <li>Updated help messages to include <code>--medium</code> option</li> <li>Improved consistency between task creation and filtering</li> </ul>"},{"location":"CHANGELOG/#fixed_5","title":"Fixed","text":"<ul> <li>Design flaw: users can now filter by medium priority, completing the priority filter set</li> </ul>"},{"location":"CHANGELOG/#101-2026-01-27","title":"1.0.1 - 2026-01-27","text":""},{"location":"CHANGELOG/#changed_7","title":"Changed","text":"<ul> <li>BREAKING CHANGE: Entire codebase translated to English</li> <li>All variable names Portuguese \u2192 English</li> <li>All function names Portuguese \u2192 English  </li> <li>All user-facing messages Portuguese \u2192 English</li> <li>All dynamic titles and error messages now in English</li> <li>Achieve full consistency with English documentation</li> <li>Updated function names: <code>extrair_prioridade</code> \u2192 <code>extract_priority</code>, etc.</li> </ul>"},{"location":"CHANGELOG/#100-2026-01-27","title":"1.0.0 - 2026-01-27","text":""},{"location":"CHANGELOG/#added_7","title":"Added","text":"<ul> <li><code>search &lt;term&gt;</code> command to search tasks by term</li> <li><code>display_task()</code> function for atomic rendering</li> <li><code>display_lists()</code> function for list rendering with statistics</li> </ul>"},{"location":"CHANGELOG/#changed_8","title":"Changed","text":"<ul> <li>Complete refactoring: separation of parsing vs rendering</li> <li>Better code reuse without duplication</li> </ul>"},{"location":"CHANGELOG/#fixed_6","title":"Fixed","text":"<ul> <li>Correct numbering in search command</li> </ul>"},{"location":"CHANGELOG/#090-2026-01-27","title":"0.9.0 - 2026-01-27","text":""},{"location":"CHANGELOG/#added_8","title":"Added","text":"<ul> <li><code>--sort</code> flag to sort tasks by priority</li> <li><code>priority_order()</code> function for high/medium/low mapping</li> <li>Optimized pipeline: filter \u2192 then sort</li> </ul>"},{"location":"CHANGELOG/#080-2026-01-26","title":"0.8.0 - 2026-01-26","text":""},{"location":"CHANGELOG/#added_9","title":"Added","text":"<ul> <li>Priority system (high, medium, low)</li> <li><code>--high</code> and <code>--low</code> flags to filter by priority</li> <li>Colored emojis (\ud83d\udd34 \ud83d\udfe1 \ud83d\udfe2) for visual indication</li> <li><code>extract_priority()</code> function for parsing</li> <li><code>priority_emoji()</code> function for rendering</li> <li>Filter combination (status + priority)</li> <li>Conflicting flags validation</li> <li>Dynamic titles based on context</li> </ul>"},{"location":"CHANGELOG/#070-2026-01-26","title":"0.7.0 - 2026-01-26","text":""},{"location":"CHANGELOG/#added_10","title":"Added","text":"<ul> <li><code>--pending</code> and <code>--done</code> flags to filter by status</li> <li>Filter combination support</li> <li>Helper functions for code reuse</li> </ul>"},{"location":"CHANGELOG/#060-2026-01-25","title":"0.6.0 - 2026-01-25","text":""},{"location":"CHANGELOG/#added_11","title":"Added","text":"<ul> <li>Colorful visual interface using <code>colored</code> crate</li> <li>Visual hierarchy with dimmed/bold formatting</li> <li>Progress counter with percentage</li> <li>Color-coded priority indicators</li> </ul>"},{"location":"CHANGELOG/#050-2026-01-24","title":"0.5.0 - 2026-01-24","text":""},{"location":"CHANGELOG/#added_12","title":"Added","text":"<ul> <li><code>clear</code> command to remove all tasks</li> <li>File existence validation with <code>fs::metadata()</code></li> </ul>"},{"location":"CHANGELOG/#042-2026-01-23","title":"0.4.2 - 2026-01-23","text":""},{"location":"CHANGELOG/#fixed_7","title":"Fixed","text":"<ul> <li>State validation to prevent duplicate operations</li> <li>More specific error messages</li> </ul>"},{"location":"CHANGELOG/#041-2026-01-23","title":"0.4.1 - 2026-01-23","text":""},{"location":"CHANGELOG/#fixed_8","title":"Fixed","text":"<ul> <li>Bug in <code>list</code> command with empty lines</li> <li>Robust line filtering with <code>trim()</code></li> </ul>"},{"location":"CHANGELOG/#040-2026-01-23","title":"0.4.0 - 2026-01-23","text":""},{"location":"CHANGELOG/#added_13","title":"Added","text":"<ul> <li><code>undone</code> command to unmark tasks</li> </ul>"},{"location":"CHANGELOG/#030-2026-01-23","title":"0.3.0 - 2026-01-23","text":""},{"location":"CHANGELOG/#added_14","title":"Added","text":"<ul> <li><code>remove</code> command to delete specific tasks</li> <li>Index validation</li> <li>Comprehensive error handling</li> </ul>"},{"location":"CHANGELOG/#020-2026-01-23","title":"0.2.0 - 2026-01-23","text":""},{"location":"CHANGELOG/#added_15","title":"Added","text":"<ul> <li><code>done</code> command to mark tasks as completed</li> <li>String manipulation with <code>.replace()</code>, <code>.map()</code>, <code>.collect()</code></li> </ul>"},{"location":"CHANGELOG/#010-2026-01-23","title":"0.1.0 - 2026-01-23","text":""},{"location":"CHANGELOG/#added_16","title":"Added","text":"<ul> <li><code>add</code> command to add tasks</li> <li><code>list</code> command to list all tasks</li> <li>Basic file operations with <code>OpenOptions</code></li> <li>Pattern matching for subcommands</li> <li>Error handling with <code>?</code> operator</li> </ul>"},{"location":"advanced/v1.2.0-struct-refactoring/","title":"v1.2.0 - Struct Refactoring (Type-Safe Architecture)","text":"<p>\ud83c\udfaf Goal: Replace string parsing with type-safe structs and enums for maintainability and extensibility</p> <p>\ud83d\udce6 The Problem We're Solving:</p> <p>Before v1.2.0:</p> <p>Every command parsed strings manually:</p> <pre><code>// Parsing priority from strings (repeated everywhere)\nlet without_checkbox = line.replace(\"[ ]\", \"\").replace(\"[x]\", \"\").trim();\nif without_checkbox.contains(\"(high)\") {\n    let text = without_checkbox.replace(\"(high)\", \"\").trim();\n    // ... handle high priority\n} else if without_checkbox.contains(\"(low)\") {\n    // ... handle low priority\n}\n\n// Checking completion status (string matching)\nif line.contains(\"[x]\") {\n    // completed\n} else {\n    // pending\n}\n</code></pre> <p>Problems:</p> <p>\u274c String parsing repeated in every command \u274c No type safety - typos like <code>\"hihg\"</code> compile fine \u274c Hard to add new fields (timestamps, tags) \u274c Can't leverage Rust's type system \u274c Prone to bugs (what if format changes?)  </p> <p>\ud83d\udce6 The Solution: Structs + Enums</p> <p>Core data structures:</p> <pre><code>#[derive(Debug, Clone, PartialEq, Copy)]\nenum Priority {\n    High,\n    Medium,\n    Low,\n}\n\n#[derive(Debug, Clone, PartialEq)]\nstruct Task {\n    text: String,\n    completed: bool,\n    priority: Priority,\n}\n</code></pre> <p>Why this is revolutionary:</p> <p>\u2705 Type-safe - compiler catches mistakes \u2705 Self-documenting - clear what a Task contains \u2705 Extensible - add fields easily \u2705 DRY - parsing logic in ONE place \u2705 Testable - can unit test Task methods  </p> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"advanced/v1.2.0-struct-refactoring/#what-is-a-struct","title":"What is a <code>struct</code>?","text":"<p>Think of it as a custom data type that groups related data:</p> <pre><code>// Instead of passing around 3 separate values:\nfn display_task(text: String, completed: bool, priority: String) { }\n\n// We bundle them into one logical unit:\nfn display_task(task: &amp;Task) { }\n</code></pre> <p>Real-world analogy:</p> <pre><code>// Like a form with labeled fields:\nstruct Person {\n    name: String,      // \"John Doe\"\n    age: u32,          // 25\n    email: String,     // \"john@example.com\"\n}\n\n// Instead of passing 3 separate strings/numbers around\n</code></pre> <p>Our Task struct:</p> <pre><code>struct Task {\n    text: String,       // \"Study Rust\"\n    completed: bool,    // false\n    priority: Priority, // High\n}\n</code></pre>"},{"location":"advanced/v1.2.0-struct-refactoring/#what-is-an-enum","title":"What is an <code>enum</code>?","text":"<p>An enum represents one of several possible values:</p> <pre><code>enum Priority {\n    High,    // \u2190 can ONLY be one of these\n    Medium,  // \u2190 mutually exclusive\n    Low,     // \u2190 not multiple at once\n}\n</code></pre> <p>Why enum vs strings?</p> <pre><code>// \u274c String approach - error-prone\nlet priority = \"hihg\";  // Typo! Compiles fine, breaks at runtime\nif priority == \"high\" { }  // Won't match, silent bug\n\n// \u2705 Enum approach - compile-time safety\nlet priority = Priority::Hihg;  // ERROR: no variant `Hihg`\n// Won't compile! Catches typo immediately\n</code></pre> <p>Enums are exhaustive:</p> <pre><code>match priority {\n    Priority::High =&gt; \"\ud83d\udd34\",\n    Priority::Medium =&gt; \"\ud83d\udfe1\",\n    // Forgot Low? \u274c Compiler error: \"non-exhaustive patterns\"\n}\n</code></pre> <p>Compiler forces you to handle all cases!</p>"},{"location":"advanced/v1.2.0-struct-refactoring/#the-derive-attributes","title":"The <code>#[derive(...)]</code> attributes","text":"<pre><code>#[derive(Debug, Clone, PartialEq, Copy)]\nenum Priority {\n    High,\n    Medium,\n    Low,\n}\n</code></pre> <p>What do these mean?</p> <p><code>Debug</code> - Enables printing for debugging:</p> <pre><code>let pri = Priority::High;\nprintln!(\"{:?}\", pri);  // Output: High\n</code></pre> <p><code>Clone</code> - Enables creating copies:</p> <pre><code>let pri1 = Priority::High;\nlet pri2 = pri1.clone();  // Explicit copy\n</code></pre> <p><code>PartialEq</code> - Enables comparison:</p> <pre><code>if task.priority == Priority::High {\n    // This works because of PartialEq\n}\n</code></pre> <p><code>Copy</code> - Enables implicit copying:</p> <pre><code>let pri1 = Priority::High;\nlet pri2 = pri1;  // Automatically copied (not moved!)\n// pri1 still valid here \u2705\n</code></pre>"},{"location":"advanced/v1.2.0-struct-refactoring/#impl-blocks-adding-methods-to-types","title":"<code>impl</code> blocks - Adding methods to types","text":"<pre><code>impl Priority {\n    fn order(&amp;self) -&gt; u8 {\n        match self {\n            Priority::High =&gt; 0,\n            Priority::Medium =&gt; 1,\n            Priority::Low =&gt; 2,\n        }\n    }\n\n    fn emoji(&amp;self) -&gt; ColoredString {\n        match self {\n            Priority::High =&gt; \"\ud83d\udd34\".red(),\n            Priority::Medium =&gt; \"\ud83d\udfe1\".yellow(),\n            Priority::Low =&gt; \"\ud83d\udfe2\".green(),\n        }\n    }\n}\n</code></pre> <p>What's <code>&amp;self</code>?</p> <pre><code>fn emoji(&amp;self) -&gt; ColoredString\n//       \u2191 \"self\" = the Priority value we're calling this on\n</code></pre> <p>Usage:</p> <pre><code>let pri = Priority::High;\nlet icon = pri.emoji();  // \"self\" is `pri`\n//         \u2191 calling method ON the value\n</code></pre>"},{"location":"advanced/v1.2.0-struct-refactoring/#implementing-task-methods","title":"Implementing Task methods","text":"<pre><code>impl Task {\n    // Constructor - creates new Task\n    fn new(text: String, priority: Priority) -&gt; Self {\n        Self {\n            text,\n            completed: false,  // Always starts incomplete\n            priority,\n        }\n    }\n\n    // Convert Task \u2192 string format for file\n    fn to_line(&amp;self) -&gt; String {\n        let checkbox = if self.completed { \"[x]\" } else { \"[ ]\" };\n        let pri_str = match self.priority {\n            Priority::High =&gt; \" (high)\",\n            Priority::Low =&gt; \" (low)\",\n            Priority::Medium =&gt; \"\",\n        };\n        format!(\"{}{} {}\", checkbox, pri_str, self.text)\n    }\n\n    // Parse string \u2192 Task (returns Option because can fail)\n    fn from_line(line: &amp;str) -&gt; Option&lt;Self&gt; {\n        // ... parsing logic ...\n    }\n\n    // Mark as done\n    fn mark_done(&amp;mut self) {\n        self.completed = true;\n    }\n\n    // Mark as pending\n    fn mark_undone(&amp;mut self) {\n        self.completed = false;\n    }\n}\n</code></pre>"},{"location":"advanced/v1.2.0-struct-refactoring/#centralized-io-with-load_tasks-and-save_tasks","title":"Centralized I/O with <code>load_tasks</code> and <code>save_tasks</code>","text":"<p>Before - I/O scattered everywhere:</p> <pre><code>// In 'add' command\nlet mut file = OpenOptions::new().append(true).open(\"todos.txt\")?;\nwriteln!(file, \"[ ] (high) {}\", task)?;\n\n// In 'done' command\nlet content = fs::read_to_string(\"todos.txt\")?;\nlet mut lines: Vec&lt;String&gt; = content.lines().map(|l| l.to_string()).collect();\n// ... modify ...\nfs::write(\"todos.txt\", lines.join(\"\\n\"))?;\n</code></pre> <p>After - Centralized:</p> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt; {\n    match fs::read_to_string(\"todos.txt\") {\n        Ok(content) =&gt; {\n            let tasks: Vec&lt;Task&gt; = content\n                .lines()\n                .filter(|l| !l.trim().is_empty())\n                .filter_map(Task::from_line)  // Parsing in ONE place\n                .collect();\n            Ok(tasks)\n        }\n        Err(_) =&gt; Ok(Vec::new()),  // Missing file = empty list\n    }\n}\n\nfn save_tasks(tasks: &amp;[Task]) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let lines: Vec&lt;String&gt; = tasks.iter().map(|t| t.to_line()).collect();\n    fs::write(\"todos.txt\", lines.join(\"\\n\") + \"\\n\")?;\n    Ok(())\n}\n</code></pre> <p>Now every command:</p> <pre><code>\"done\" =&gt; {\n    let mut tasks = load_tasks()?;  // Load\n    tasks[index].mark_done();       // Modify\n    save_tasks(&amp;tasks)?;            // Save\n}\n</code></pre>"},{"location":"advanced/v1.2.0-struct-refactoring/#impact-of-refactoring","title":"Impact of Refactoring","text":"<p>Code metrics:</p> Metric Before After Change Total lines ~180 ~115 -36% <code>add</code> command 30 lines 20 lines -33% <code>list</code> command 90 lines 60 lines -33% <code>done</code> command 25 lines 15 lines -40% <code>search</code> command 35 lines 20 lines -43% <p>36% less code with MORE features!</p> <p>Extensibility unlocked:</p> <p>Now trivial to add:</p> <p>\u2705 Timestamps: <pre><code>struct Task {\n    // ...\n    created_at: DateTime,\n    completed_at: Option&lt;DateTime&gt;,\n}\n</code></pre></p> <p>\u2705 Tags: <pre><code>struct Task {\n    // ...\n    tags: Vec&lt;String&gt;,\n}\n</code></pre></p> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v1.2.0</li> <li>Full diff</li> <li>Rust Book - Structs</li> <li>Rust Book - Enums</li> </ul>"},{"location":"advanced/v1.3.0-json-serialization/","title":"v1.3.0 - JSON Serialization with Serde","text":"<p>\ud83c\udfaf Goal: Replace custom text format with JSON using automatic serialization</p> <p>\ud83d\udce6 The Problem We're Solving:</p> <p>Before v1.3.0:</p> <p>Even with structs, we still had custom text parsing:</p> <pre><code>// Custom format:\n\"[ ] (high) Study Rust\"\n\"[x] (low) Buy coffee\"\n\"[ ] Read docs\"\n\n// Manual serialization in to_line():\nfn to_line(&amp;self) -&gt; String {\n    let checkbox = if self.completed { \"[x]\" } else { \"[ ]\" };\n    let pri_str = match self.priority {\n        Priority::High =&gt; \" (high)\",\n        Priority::Low =&gt; \" (low)\",\n        Priority::Medium =&gt; \"\",\n    };\n    format!(\"{}{} {}\", checkbox, pri_str, self.text)\n}\n\n// Manual parsing in from_line():\nfn from_line(line: &amp;str) -&gt; Option&lt;Self&gt; {\n    // 25+ lines of parsing logic...\n}\n</code></pre> <p>Problems:</p> <p>\u274c Custom format is fragile \u274c Parsing logic is complex \u274c Hard to add new fields (need to update parsing) \u274c Not a standard format \u274c Can't integrate with other tools \u274c Manual maintenance of serialization  </p> <p>\ud83d\udce6 The Solution: JSON with Serde</p> <p>After v1.3.0:</p> <pre><code>[\n  {\n    \"text\": \"Study Rust\",\n    \"completed\": false,\n    \"priority\": \"High\"\n  },\n  {\n    \"text\": \"Buy coffee\",\n    \"completed\": true,\n    \"priority\": \"Low\"\n  },\n  {\n    \"text\": \"Read docs\",\n    \"completed\": false,\n    \"priority\": \"Medium\"\n  }\n]\n</code></pre> <p>Why this is revolutionary:</p> <p>\u2705 Standard format - universal, tools everywhere \u2705 Automatic serialization - serde does everything \u2705 2 lines of code for complete I/O \u2705 Trivial to extend - add field = one line \u2705 Export/Import ready - JSON is portable \u2705 Git-friendly - readable diffs  </p> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"advanced/v1.3.0-json-serialization/#what-is-serialization","title":"What is serialization?","text":"<p>Serialization = Converting data structures \u2192 storage format Deserialization = Converting storage format \u2192 data structures</p> <pre><code>// Serialization:\nTask { text: \"Study\", completed: false, priority: High }\n    \u2193\n\"{\\\"text\\\":\\\"Study\\\",\\\"completed\\\":false,\\\"priority\\\":\\\"High\\\"}\"\n\n// Deserialization:\n\"{\\\"text\\\":\\\"Study\\\",\\\"completed\\\":false,\\\"priority\\\":\\\"High\\\"}\"\n    \u2193\nTask { text: \"Study\", completed: false, priority: High }\n</code></pre>"},{"location":"advanced/v1.3.0-json-serialization/#adding-serde-dependencies","title":"Adding serde dependencies","text":"<p>In <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\ncolored = \"2.1\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n</code></pre> <p>What each does:</p> Crate Purpose <code>serde</code> Core serialization framework <code>features = [\"derive\"]</code> Enables <code>#[derive(Serialize, Deserialize)]</code> macros <code>serde_json</code> JSON-specific implementation"},{"location":"advanced/v1.3.0-json-serialization/#the-deriveserialize-deserialize-attribute","title":"The <code>#[derive(Serialize, Deserialize)]</code> attribute","text":"<p>Add to imports:</p> <pre><code>use serde::{Deserialize, Serialize};\n</code></pre> <p>Add to types:</p> <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Task {\n    text: String,\n    completed: bool,\n    priority: Priority,\n}\n\n#[derive(Debug, Clone, PartialEq, Copy, Serialize, Deserialize)]\nenum Priority {\n    High,\n    Medium,\n    Low,\n}\n</code></pre> <p>What these derives do:</p> <p><code>Serialize</code> - Generates code to convert type \u2192 format <code>Deserialize</code> - Generates code to convert format \u2192 type  </p> <p>The magic:</p> <pre><code>// Before (manual - 37 lines):\nimpl Task {\n    fn to_line(&amp;self) -&gt; String { /* 12 lines */ }\n    fn from_line(line: &amp;str) -&gt; Option&lt;Self&gt; { /* 25 lines */ }\n}\n\n// After (automatic - 1 line):\n#[derive(Serialize, Deserialize)]\n// Generates 100+ lines of perfect serialization code!\n</code></pre>"},{"location":"advanced/v1.3.0-json-serialization/#refactored-load_tasks-with-json","title":"Refactored <code>load_tasks()</code> with JSON","text":"<p>Before (custom text format):</p> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt; {\n    match fs::read_to_string(\"todos.txt\") {\n        Ok(content) =&gt; {\n            let tasks: Vec&lt;Task&gt; = content\n                .lines()\n                .filter(|l| !l.trim().is_empty())\n                .filter_map(Task::from_line)  // Manual parsing\n                .collect();\n            Ok(tasks)\n        }\n        Err(_) =&gt; Ok(Vec::new()),\n    }\n}\n</code></pre> <p>After (JSON):</p> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt; {\n    match fs::read_to_string(\"todos.json\") {  // .txt \u2192 .json\n        Ok(content) =&gt; {\n            let tasks: Vec&lt;Task&gt; = serde_json::from_str(&amp;content)?;  // \u2190 ONE LINE!\n            Ok(tasks)\n        }\n        Err(_) =&gt; Ok(Vec::new()),\n    }\n}\n</code></pre>"},{"location":"advanced/v1.3.0-json-serialization/#refactored-save_tasks-with-json","title":"Refactored <code>save_tasks()</code> with JSON","text":"<p>Before (custom text format):</p> <pre><code>fn save_tasks(tasks: &amp;[Task]) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let lines: Vec&lt;String&gt; = tasks.iter().map(|t| t.to_line()).collect();\n    fs::write(\"todos.txt\", lines.join(\"\\n\") + \"\\n\")?;\n    Ok(())\n}\n</code></pre> <p>After (JSON):</p> <pre><code>fn save_tasks(tasks: &amp;[Task]) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let json = serde_json::to_string_pretty(tasks)?;  // \u2190 ONE LINE!\n    fs::write(\"todos.json\", json)?;\n    Ok(())\n}\n</code></pre> <p>Why <code>to_string_pretty</code> instead of <code>to_string</code>?</p> <pre><code>// to_string - compact, one line:\nserde_json::to_string(tasks)\n// Output: [{\"text\":\"Study\",\"completed\":false,\"priority\":\"High\"}]\n\n// to_string_pretty - formatted, readable:\nserde_json::to_string_pretty(tasks)\n// Output:\n// [\n//   {\n//     \"text\": \"Study\",\n//     \"completed\": false,\n//     \"priority\": \"High\"\n//   }\n// ]\n</code></pre>"},{"location":"advanced/v1.3.0-json-serialization/#impact-of-json-migration","title":"Impact of JSON migration","text":"<p>Code reduction:</p> Component Before After Reduction <code>load_tasks()</code> 12 lines 3 lines -75% <code>save_tasks()</code> 4 lines 2 lines -50% <code>Task::from_line()</code> 25 lines DELETED -100% <code>Task::to_line()</code> 12 lines DELETED -100% Total 53 lines 5 lines -91% <p>91% reduction in I/O code! \ud83c\udfaf</p>"},{"location":"advanced/v1.3.0-json-serialization/#extensibility-demonstration","title":"Extensibility demonstration","text":"<p>Adding tags support:</p> <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Task {\n    text: String,\n    completed: bool,\n    priority: Priority,\n    #[serde(default)]  // \u2190 Use empty vec if field missing\n    tags: Vec&lt;String&gt;,  // \u2190 Add ONE line\n}\n</code></pre> <p>That's it! Serde now serializes/deserializes tags automatically.</p> <p>Example JSON:</p> <pre><code>[\n  {\n    \"text\": \"Study Rust\",\n    \"completed\": false,\n    \"priority\": \"High\",\n    \"tags\": [\"learning\", \"programming\"]\n  }\n]\n</code></pre> <p>No changes needed in:</p> <ul> <li>\u2705 <code>load_tasks()</code> - still 3 lines</li> <li>\u2705 <code>save_tasks()</code> - still 2 lines</li> <li>\u2705 All commands - work automatically</li> </ul> <p>This is the power of declarative serialization!</p> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v1.3.0</li> <li>Full diff</li> <li>Serde documentation</li> <li>Serde JSON docs</li> </ul>"},{"location":"advanced/v1.4.0-tags-system/","title":"v1.4.0 - Tags System","text":"<p>\ud83c\udfaf Goal: Add categorization system with tags and fix critical numbering bug</p> <p>\ud83d\udce6 What We're Adding:</p> <p>Tags for task organization:</p> <pre><code># Before - no categorization:\ntodo add \"Study Rust\" --high\ntodo add \"Fix bug\" --high\n# How to separate work from personal? No way!\n\n# After - with tags:\ntodo add \"Study Rust\" --high --tag learning --tag programming\ntodo add \"Fix bug\" --high --tag work --tag urgent\ntodo list --tag work  # Show only work tasks\n</code></pre> <p>Why tags matter:</p> <p>\u2705 Categorization - Group tasks by project, context, etc. \u2705 Flexible filtering - Multiple tags per task \u2705 Easy to add - Thanks to JSON/serde \u2705 Visual feedback - Tags shown in list \u2705 Discovery - <code>tags</code> command shows all tags  </p> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"advanced/v1.4.0-tags-system/#adding-a-field-to-existing-struct","title":"Adding a field to existing struct","text":"<p>This is where JSON/serde shines!</p> <pre><code>// Before (v1.3.0):\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Task {\n    text: String,\n    completed: bool,\n    priority: Priority,\n}\n\n// After (v1.4.0):\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Task {\n    text: String,\n    completed: bool,\n    priority: Priority,\n    tags: Vec&lt;String&gt;,  // \u2190 Add ONE line\n}\n</code></pre> <p>That's it! Serde handles everything automatically.</p> <p>Handling backward compatibility:</p> <pre><code>// Problem: Old JSON doesn't have \"tags\" field\n{\n  \"text\": \"Old task\",\n  \"completed\": false,\n  \"priority\": \"High\"\n  // Missing \"tags\"!\n}\n\n// Serde error: \"missing field `tags`\"\n</code></pre> <p>Solution: Use <code>#[serde(default)]</code>:</p> <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Task {\n    text: String,\n    completed: bool,\n    priority: Priority,\n    #[serde(default)]  // \u2190 Use Vec::default() if missing\n    tags: Vec&lt;String&gt;,\n}\n</code></pre> <p>Now:</p> <ul> <li>New tasks: <code>\"tags\": [\"work\"]</code> \u2705</li> <li>Old tasks: Missing field \u2192 <code>tags: vec![]</code> \u2705</li> </ul>"},{"location":"advanced/v1.4.0-tags-system/#vecstring-for-multiple-values","title":"<code>Vec&lt;String&gt;</code> for multiple values","text":"<p>Why <code>Vec&lt;String&gt;</code> instead of single <code>String</code>?</p> <pre><code>// \u274c Single tag - limited\ntags: String  // Can only have one tag\n\n// \u2705 Multiple tags - flexible\ntags: Vec&lt;String&gt;  // Can have many tags\n</code></pre> <p>In JSON:</p> <pre><code>{\n  \"tags\": [\"learning\", \"programming\"]\n}\n</code></pre>"},{"location":"advanced/v1.4.0-tags-system/#parsing-multiple-flags-of-same-type","title":"Parsing multiple flags of same type","text":"<p>Challenge: Allow <code>--tag</code> multiple times:</p> <pre><code>todo add \"Study Rust\" --tag learning --tag programming --tag rust\n</code></pre> <p>Solution: Loop and collect:</p> <pre><code>let mut tags: Vec&lt;String&gt; = Vec::new();\nlet mut i = 3;  // Start after command and task text\n\nwhile i &lt; args.len() {\n    match args[i].as_str() {\n        \"--high\" =&gt; priority = Priority::High,\n        \"--medium\" =&gt; priority = Priority::Medium,\n        \"--low\" =&gt; priority = Priority::Low,\n        \"--tag\" =&gt; {\n            if i + 1 &gt;= args.len() {\n                return Err(\"--tag requires a value\".into());\n            }\n            tags.push(args[i + 1].clone());  // Add tag to vector\n            i += 1;  // Skip the tag value\n        }\n        _ =&gt; return Err(format!(\"Invalid flag: {}\", args[i]).into()),\n    }\n    i += 1;\n}\n</code></pre>"},{"location":"advanced/v1.4.0-tags-system/#filtering-with-retain","title":"Filtering with <code>retain()</code>","text":"<p>Before (v1.3.0): Creating new vectors</p> <pre><code>let mut valid_lines: Vec&lt;&amp;str&gt; = all_lines\n    .iter()\n    .filter(|line| !line.is_empty())\n    .copied()\n    .collect();  // Creates NEW vector\n</code></pre> <p>After (v1.4.0): Modifying in-place</p> <pre><code>let mut indexed_tasks: Vec&lt;(usize, &amp;Task)&gt; = /* ... */;\n\n// Filter in-place\nindexed_tasks.retain(|(_, t)| !t.completed);  // Removes items\n</code></pre> <p>What's <code>.retain()</code>?</p> <pre><code>vec.retain(|item| predicate);\n// Keeps only items where predicate returns true\n// Modifies vector IN PLACE\n</code></pre>"},{"location":"advanced/v1.4.0-tags-system/#the-critical-numbering-bug","title":"The critical numbering bug","text":"<p>The Problem:</p> <p>Before fix:</p> <pre><code>// Load all tasks\nlet tasks = load_tasks()?;  // [Task1, Task2, Task3, Task4, Task5]\n\n// Filter to pending only\nlet pending: Vec&lt;&amp;Task&gt; = tasks\n    .iter()\n    .filter(|t| !t.completed)\n    .collect();\n// Result: [Task1, Task3, Task5]\n\n// Display with NEW numbering\nfor (i, task) in pending.iter().enumerate() {\n    println!(\"{}. {}\", i + 1, task.text);  // \u274c 1, 2, 3\n}\n// Output:\n// 1. Task1  (was index 0)\n// 2. Task3  (was index 2)\n// 3. Task5  (was index 4)\n</code></pre> <p>User sees:</p> <pre><code>$ todo list --pending\n1. Study Rust\n2. Fix bug\n3. Write docs\n\n$ todo done 2  # User wants to mark \"Fix bug\" as done\n</code></pre> <p>What actually happens:</p> <pre><code>// \"2\" maps to index 1 in the FULL array\ntasks[1].mark_done();  // Marks Task2, not Task3!\n</code></pre> <p>Bug: User marked the WRONG task! \ud83d\udc1b</p> <p>The Solution: Preserve original indices</p> <pre><code>// Create tuples with ORIGINAL indices\nlet mut indexed_tasks: Vec&lt;(usize, &amp;Task)&gt; = tasks\n    .iter()\n    .enumerate()\n    .map(|(i, task)| (i + 1, task))  // Store (number, task)\n    .collect();\n// Result: [(1, Task1), (2, Task2), (3, Task3), (4, Task4), (5, Task5)]\n\n// Filter while KEEPING original numbers\nindexed_tasks.retain(|(_, t)| !t.completed);\n// Result: [(1, Task1), (3, Task3), (5, Task5)]\n\n// Display with ORIGINAL numbers\nfor (number, task) in &amp;indexed_tasks {\n    println!(\"{}. {}\", number, task.text);  // \u2705 1, 3, 5\n}\n</code></pre> <p>User sees:</p> <pre><code>$ todo list --pending\n1. Study Rust\n3. Fix bug      \u2190 Original number preserved!\n5. Write docs\n\n$ todo done 3   # Correctly marks Task3\n</code></pre> <p>Now it works! \u2705</p>"},{"location":"advanced/v1.4.0-tags-system/#new-command-tags","title":"New command: <code>tags</code>","text":"<p>Purpose: Show all tags in use with counts</p> <pre><code>\"tags\" =&gt; {\n    let tasks = load_tasks()?;\n\n    // Collect all unique tags\n    let mut all_tags: Vec&lt;String&gt; = Vec::new();\n    for task in &amp;tasks {\n        for tag in &amp;task.tags {\n            if !all_tags.contains(tag) {\n                all_tags.push(tag.clone());\n            }\n        }\n    }\n\n    all_tags.sort();  // Alphabetical order\n\n    println!(\"\\n Tags:\\n\");\n    for tag in &amp;all_tags {\n        let count = tasks.iter().filter(|t| t.tags.contains(tag)).count();\n        println!(\n            \"  {} ({} task{})\",\n            tag.cyan(),\n            count,\n            if count == 1 { \"\" } else { \"s\" }  // Grammar!\n        );\n    }\n\n    println!()\n}\n</code></pre> <p>Output:</p> <pre><code>$ todo tags\n\n Tags:\n\n  learning (1 task)\n  urgent (2 tasks)\n  work (2 tasks)\n</code></pre>"},{"location":"advanced/v1.4.0-tags-system/#visual-feedback-for-tags","title":"Visual feedback for tags","text":"<p>Updated <code>display_task()</code>:</p> <pre><code>fn display_task(number: usize, task: &amp;Task) {\n    // ... priority and status display ...\n\n    // Format tags\n    let tags_str = if task.tags.is_empty() {\n        String::new()  // No tags = empty string\n    } else {\n        format!(\" [{}]\", task.tags.join(\", \"))  // [tag1, tag2]\n    };\n\n    // Display with tags\n    if task.completed {\n        println!(\n            \"{} {} {} {}{}\",\n            number_fmt.dimmed(),\n            emoji,\n            \"\u2705\".green(),\n            task.text.green().strikethrough(),\n            tags_str.dimmed()  // \u2190 Dimmed for completed\n        );\n    } else {\n        println!(\n            \"{} {} {} {}{}\",\n            number_fmt.dimmed(),\n            emoji,\n            \"\u23f3\".yellow(),\n            task.text.bright_white(),\n            tags_str.cyan()  // \u2190 Cyan for pending\n        );\n    }\n}\n</code></pre> <p>Output examples:</p> <pre><code># Completed task with tags\n1. \ud83d\udd34 \u2705 Study Rust [learning, programming]\n                   \u2191 dimmed\n\n# Pending task with tags\n2. \ud83d\udfe1 \u23f3 Fix bug [work, urgent]\n             \u2191 cyan (stands out)\n\n# Task without tags\n3. \ud83d\udfe2 \u23f3 Buy coffee\n</code></pre> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v1.4.0</li> <li>Full diff</li> </ul>"},{"location":"advanced/v1.5.0-due-dates-tabular/","title":"v1.5.0 - Due Dates and Tabular Display","text":"<p>\ud83c\udfaf Goal: Add due date tracking with <code>chrono</code> and improve visual display with tabular format</p> <p>\ud83d\udce6 What We're Adding:</p> <p>Due dates for deadline management:</p> <pre><code># Before - no deadline tracking:\ntodo add \"Submit report\" --high\n# When is it due? No way to know!\n\n# After - with due dates:\ntodo add \"Submit report\" --high --due 2026-02-15\ntodo list --overdue        # See what's late\ntodo list --due-soon       # See what's coming up\ntodo list --sort due       # Sort by deadline\n</code></pre> <p>Why due dates matter:</p> <p>\u2705 Deadline awareness - Never miss important dates \u2705 Smart filtering - <code>--overdue</code>, <code>--due-soon</code> \u2705 Flexible sorting - By priority, due date, or creation \u2705 Visual urgency - Color-coded warnings \u2705 Automatic timestamps - <code>created_at</code> tracks when task was added  </p> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"advanced/v1.5.0-due-dates-tabular/#adding-the-chrono-crate","title":"Adding the <code>chrono</code> crate","text":"<p>In <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\ncolored = \"2.1\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nchrono = { version = \"0.4\", features = [\"serde\"] }  # \u2190 ADD\n</code></pre> <p>Why chrono?</p> <ul> <li>Rust's standard library has basic <code>std::time</code> but no date parsing</li> <li><code>chrono</code> is the de-facto standard for dates/times in Rust</li> <li>Feature <code>serde</code> enables automatic serialization</li> </ul> <p>Import:</p> <pre><code>use chrono::{Local, NaiveDate};\n</code></pre> <p>What's <code>NaiveDate</code>?</p> <ul> <li>\"Naive\" = no timezone information</li> <li>Just year-month-day (2026-02-15)</li> <li>Perfect for due dates (we care about the day, not the hour)</li> </ul>"},{"location":"advanced/v1.5.0-due-dates-tabular/#adding-date-fields-to-task","title":"Adding date fields to <code>Task</code>","text":"<p>Updated struct:</p> <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Task {\n    text: String,\n    completed: bool,\n    priority: Priority,\n    tags: Vec&lt;String&gt;,\n    due_date: Option&lt;NaiveDate&gt;,  // \u2190 NEW: Optional due date\n    created_at: NaiveDate,         // \u2190 NEW: Creation timestamp\n}\n</code></pre> <p>Why <code>Option&lt;NaiveDate&gt;</code>?</p> <pre><code>// Not all tasks have deadlines:\ndue_date: Option&lt;NaiveDate&gt;\n\n// Some(...) = has due date\n// None = no due date\n</code></pre> <p>Why <code>NaiveDate</code> for <code>created_at</code> (not <code>Option</code>)?</p> <pre><code>created_at: NaiveDate  // Always has a value\n</code></pre> <p>Every task has a creation time, so no <code>Option</code> needed.</p> <p>Updated constructor:</p> <pre><code>fn new(\n    text: String,\n    priority: Priority,\n    tags: Vec&lt;String&gt;,\n    due_date: Option&lt;NaiveDate&gt;,  // \u2190 NEW parameter\n) -&gt; Self {\n    Task {\n        text,\n        completed: false,\n        priority,\n        tags,\n        due_date,\n        created_at: Local::now().naive_local().date(),  // \u2190 AUTO\n    }\n}\n</code></pre> <p>Breaking down <code>created_at</code>:</p> <pre><code>Local::now()           // Get current local time (with timezone)\n    .naive_local()     // Convert to naive (remove timezone)\n    .date()            // Extract just the date (no time)\n</code></pre> <p>Result: <code>NaiveDate</code> like <code>2026-02-03</code></p>"},{"location":"advanced/v1.5.0-due-dates-tabular/#date-methods-on-task","title":"Date methods on <code>Task</code>","text":"<p>Check if overdue:</p> <pre><code>fn is_overdue(&amp;self) -&gt; bool {\n    if let Some(due) = self.due_date {\n        let today = Local::now().naive_local().date();\n        due &lt; today &amp;&amp; !self.completed\n    } else {\n        false  // No due date = can't be overdue\n    }\n}\n</code></pre> <p>Breakdown:</p> <pre><code>if let Some(due) = self.due_date  // Only if task has due date\n</code></pre> <p>Pattern matching on <code>Option</code>:</p> <ul> <li>If <code>Some(date)</code> \u2192 extract date, continue</li> <li>If <code>None</code> \u2192 skip to <code>else { false }</code></li> </ul> <pre><code>let today = Local::now().naive_local().date();\ndue &lt; today &amp;&amp; !self.completed\n</code></pre> <p>Task is overdue if:</p> <ol> <li>Due date is before today (<code>due &lt; today</code>)</li> <li>AND task is not completed (<code>!self.completed</code>)</li> </ol> <p>Check if due soon:</p> <pre><code>fn is_due_soon(&amp;self, days: i64) -&gt; bool {\n    if let Some(due) = self.due_date {\n        let today = Local::now().naive_local().date();\n        let days_until = (due - today).num_days();\n        days_until &gt;= 0 &amp;&amp; days_until &lt;= days &amp;&amp; !self.completed\n    } else {\n        false\n    }\n}\n</code></pre> <p>New concept: Date arithmetic</p> <pre><code>let days_until = (due - today).num_days();\n</code></pre> <p>What's happening:</p> <pre><code>// Today: 2026-02-03\n// Due: 2026-02-10\nlet days_until = (2026-02-10) - (2026-02-03);\n// Result: Duration of 7 days\n.num_days()  // Extract as i64: 7\n</code></pre>"},{"location":"advanced/v1.5.0-due-dates-tabular/#parsing-dates-from-command-line","title":"Parsing dates from command line","text":"<p>In <code>add</code> command:</p> <pre><code>\"--due\" =&gt; {\n    if i + 1 &gt;= args.len() {\n        return Err(\"--due requires a date in format YYYY-MM-DD\".into());\n    }\n\n    let date_str = &amp;args[i + 1];\n    match NaiveDate::parse_from_str(date_str, \"%Y-%m-%d\") {\n        Ok(date) =&gt; due_date = Some(date),\n        Err(_) =&gt; {\n            return Err(format!(\n                \"Invalid date format: '{}'. Use YYYY-MM-DD\",\n                date_str\n            )\n            .into());\n        }\n    }\n\n    i += 1;\n}\n</code></pre> <p>What's <code>parse_from_str</code>?</p> <pre><code>NaiveDate::parse_from_str(date_str, \"%Y-%m-%d\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>date_str</code>: String to parse (\"2026-02-15\")</li> <li><code>\"%Y-%m-%d\"</code>: Format pattern</li> <li><code>%Y</code> = 4-digit year (2026)</li> <li><code>%m</code> = 2-digit month (02)</li> <li><code>%d</code> = 2-digit day (15)</li> </ul> <p>Examples:</p> <pre><code># Valid:\ntodo add \"Task\" --due 2026-02-15  \u2705\n\n# Invalid:\ntodo add \"Task\" --due 02/15/2026  \u274c Wrong format\ntodo add \"Task\" --due 2026-13-01  \u274c Invalid month\ntodo add \"Task\" --due tomorrow    \u274c Not a date\n</code></pre>"},{"location":"advanced/v1.5.0-due-dates-tabular/#enhanced-sorting","title":"Enhanced sorting","text":"<p>New sort options:</p> <pre><code>match sort_by {\n    \"priority\" =&gt; {\n        indexed_tasks.sort_by(|(_, a), (_, b)| \n            a.priority.order().cmp(&amp;b.priority.order())\n        );\n    }\n    \"due\" =&gt; {\n        indexed_tasks.sort_by(|(_, a), (_, b)| \n            match (a.due_date, b.due_date) {\n                (Some(date_a), Some(date_b)) =&gt; date_a.cmp(&amp;date_b),\n                (Some(_), None) =&gt; std::cmp::Ordering::Less,\n                (None, Some(_)) =&gt; std::cmp::Ordering::Greater,\n                (None, None) =&gt; std::cmp::Ordering::Equal,\n            }\n        );\n    }\n    \"created\" =&gt; {\n        indexed_tasks.sort_by(|(_, a), (_, b)| \n            a.created_at.cmp(&amp;b.created_at)\n        );\n    }\n    _ =&gt; {}\n}\n</code></pre> <p>Understanding the <code>due</code> sort:</p> <p>Pattern matching on two <code>Option</code>s:</p> Case a.due_date b.due_date Result Why 1 <code>Some(date_a)</code> <code>Some(date_b)</code> Compare dates Both have dates 2 <code>Some(_)</code> <code>None</code> a comes first (<code>Less</code>) Tasks with dates come first 3 <code>None</code> <code>Some(_)</code> b comes first (<code>Greater</code>) Tasks with dates come first 4 <code>None</code> <code>None</code> Equal Neither has date <p>Why tasks with dates come first?</p> <p>Logic: Tasks with deadlines are more important than tasks without deadlines.</p>"},{"location":"advanced/v1.5.0-due-dates-tabular/#date-filters","title":"Date filters","text":"<p>Four new filters:</p> <pre><code>if overdue {\n    indexed_tasks.retain(|(_, t)| t.is_overdue());\n}\nif due_soon {\n    indexed_tasks.retain(|(_, t)| t.is_due_soon(7));\n}\nif with_due {\n    indexed_tasks.retain(|(_, t)| t.due_date.is_some());\n}\nif without_due {\n    indexed_tasks.retain(|(_, t)| t.due_date.is_none());\n}\n</code></pre> <p>Examples:</p> <pre><code>todo list --overdue        # Only late tasks\ntodo list --due-soon       # Due in next 7 days\ntodo list --with-due       # Any task with a due date\ntodo list --without-due    # Tasks with no deadline\n</code></pre>"},{"location":"advanced/v1.5.0-due-dates-tabular/#tabular-display-format","title":"Tabular display format","text":"<p>Major visual change:</p> <p>Before (v1.4.0):</p> <pre><code>1. \ud83d\udd34 \u23f3 Study Rust [learning, programming]\n2. \ud83d\udfe1 \u2705 Fix bug [work, urgent]\n</code></pre> <p>After (v1.5.0):</p> <pre><code>  ID  P  S  Task                Tags            Due\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1  H  \u23f3  Study Rust          learning, ...   in 5 days\n   2  M  \u2705  Fix bug             work, urgent\n</code></pre> <p>Why the change?</p> <ul> <li>\u2705 More professional</li> <li>\u2705 Easier to scan</li> <li>\u2705 Aligned columns</li> <li>\u2705 Better for many tasks</li> </ul> <p>New display function:</p> <pre><code>fn display_task_tabular(\n    number: usize,\n    task: &amp;Task,\n    task_width: usize,\n    tags_width: usize\n) {\n    let number_str = format!(\"{:&gt;3}\", number);\n    let letter = task.priority.letter();\n    let checkbox = if task.completed { \"\u2705\".green() } else { \"\u23f3\".bright_white() };\n\n    // Truncate if too long\n    let task_text = if task.text.len() &gt; task_width {\n        format!(\"{}...\", &amp;task.text[..task_width - 3])\n    } else {\n        task.text.clone()\n    };\n\n    // Format tags\n    let tags_str = if task.tags.is_empty() {\n        String::new()\n    } else {\n        let joined = task.tags.join(\", \");\n        if joined.len() &gt; tags_width {\n            format!(\"{}...\", &amp;joined[..tags_width - 3])\n        } else {\n            joined\n        }\n    };\n\n    // Get due date text and color\n    let due_text = get_due_text(task);\n    let due_colored = get_due_colored(task, &amp;due_text);\n\n    // Print with alignment\n    if task.completed {\n        print!(\"{:&gt;4} \", number_str.dimmed());\n        print!(\" {} \", letter);\n        print!(\" {} \", checkbox);\n        print!(\"{:&lt;width$}\", task_text.green(), width = task_width);\n        print!(\"  {:&lt;width$}\", tags_str.dimmed(), width = tags_width);\n        println!(\"  {}\", due_colored);\n    } else {\n        print!(\"{:&gt;4} \", number_str.dimmed());\n        print!(\" {} \", letter);\n        print!(\" {} \", checkbox);\n        print!(\"{:&lt;width$}\", task_text.bright_white(), width = task_width);\n        print!(\"  {:&lt;width$}\", tags_str.cyan(), width = tags_width);\n        println!(\"  {}\", due_colored);\n    }\n}\n</code></pre> <p>Formatting tricks:</p> <pre><code>format!(\"{:&gt;3}\", number)   // Right-align in 3 chars: \"  1\"\nformat!(\"{:&lt;40}\", text)    // Left-align in 40 chars: \"Task text             \"\n</code></pre>"},{"location":"advanced/v1.5.0-due-dates-tabular/#dynamic-column-widths","title":"Dynamic column widths","text":"<p>Calculate optimal widths:</p> <pre><code>fn calculate_column_widths(tasks: &amp;[(usize, &amp;Task)]) -&gt; (usize, usize, usize) {\n    let mut max_task_len = 10;   // Minimum width\n    let mut max_tags_len = 4;\n    let mut max_due_len = 3;\n\n    for (_, task) in tasks {\n        max_task_len = max_task_len.max(task.text.len());\n\n        if !task.tags.is_empty() {\n            let tags_str = task.tags.join(\", \");\n            max_tags_len = max_tags_len.max(tags_str.len());\n        }\n\n        let due_text = get_due_text(task);\n        if !due_text.is_empty() {\n            max_due_len = max_due_len.max(due_text.len());\n        }\n    }\n\n    // Enforce maximum widths\n    max_task_len = max_task_len.min(40);\n    max_tags_len = max_tags_len.min(20);\n    max_due_len = max_due_len.min(20);\n\n    (max_task_len, max_tags_len, max_due_len)\n}\n</code></pre> <p>Why dynamic widths?</p> <p>Columns adjust to content!</p>"},{"location":"advanced/v1.5.0-due-dates-tabular/#due-date-text-and-colors","title":"Due date text and colors","text":"<p>Format due date:</p> <pre><code>fn get_due_text(task: &amp;Task) -&gt; String {\n    if let Some(due) = task.due_date {\n        let today = Local::now().naive_local().date();\n        let days_until = (due - today).num_days();\n\n        if task.completed {\n            String::new()  // Don't show for completed tasks\n        } else if days_until &lt; 0 {\n            format!(\"late {} day{}\", -days_until, if -days_until == 1 { \"\" } else { \"s\" })\n        } else if days_until == 0 {\n            \"due today\".to_string()\n        } else if days_until &lt;= 7 {\n            format!(\"in {} day{}\", days_until, if days_until == 1 { \"\" } else { \"s\" })\n        } else {\n            format!(\"in {} day{}\", days_until, if days_until == 1 { \"\" } else { \"s\" })\n        }\n    } else {\n        String::new()  // No due date\n    }\n}\n</code></pre> <p>Examples:</p> <pre><code>// days_until = -3\n\"late 3 days\"\n\n// days_until = 0\n\"due today\"\n\n// days_until = 1\n\"in 1 day\"\n\n// days_until = 5\n\"in 5 days\"\n</code></pre> <p>Apply colors:</p> <pre><code>fn get_due_colored(task: &amp;Task, text: &amp;str) -&gt; ColoredString {\n    if text.is_empty() {\n        return \"\".normal();\n    }\n\n    if let Some(due) = task.due_date {\n        let today = Local::now().naive_local().date();\n        let days_until = (due - today).num_days();\n\n        if days_until &lt; 0 {\n            text.red().bold()         // Overdue: RED + BOLD\n        } else if days_until == 0 {\n            text.yellow().bold()      // Due today: YELLOW + BOLD\n        } else if days_until &lt;= 7 {\n            text.yellow()             // Due soon: YELLOW\n        } else {\n            text.cyan()               // Future: CYAN\n        }\n    } else {\n        text.normal()\n    }\n}\n</code></pre> <p>Color scheme:</p> Days Until Color Style Urgency &lt; 0 Red Bold \ud83d\udea8 LATE! 0 Yellow Bold \u26a0\ufe0f TODAY! 1-7 Yellow Normal \ud83d\udcc5 Soon &gt; 7 Cyan Normal \ud83d\uddd3\ufe0f Future <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v1.5.0</li> <li>Full diff</li> <li>chrono documentation</li> </ul>"},{"location":"advanced/v1.6.0-professional-cli-clap/","title":"v1.6.0 - Professional CLI with Clap","text":"<p>\ud83c\udfaf Goal: Replace manual argument parsing with <code>clap</code> and migrate boolean flags to type-safe enums</p> <p>\ud83d\udce6 The Problem We're Solving:</p> <p>Before v1.6.0 - Manual parsing with conflicts:</p> <pre><code>// Manual parsing:\nlet args: Vec&lt;String&gt; = env::args().collect();\nif args.len() &lt; 2 { return Err(\"Usage: ...\".into()); }\n\nlet command = &amp;args[1];\nmatch command.as_str() {\n    \"add\" =&gt; { /* manual parsing of flags */ }\n    \"list\" =&gt; {\n        let mut status_filter = \"all\";\n        let mut priority_filter: Option&lt;Priority&gt; = None;\n        let mut overdue = false;\n        let mut due_soon = false;\n        let mut with_due = false;\n        let mut without_due = false;\n\n        // Manual conflict checking:\n        if overdue || due_soon || with_due || without_due {\n            return Err(\"Use only one date filter\".into());\n        }\n    }\n}\n</code></pre> <p>Problems:</p> <p>\u274c Manual parsing (100+ lines just for flags) \u274c Boolean flags conflict manually (<code>conflicts_with_all</code>) \u274c Help text written by hand \u274c No type safety (strings everywhere) \u274c Hard to add new flags (lots of boilerplate) \u274c Error messages generic  </p> <p>After v1.6.0 - Clap with enums:</p> <pre><code>#[derive(Parser)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    List {\n        #[arg(long, value_enum, default_value_t = StatusFilter::All)]\n        status: StatusFilter,\n\n        #[arg(long, value_enum)]\n        due: Option&lt;DueFilter&gt;,\n\n        // No conflicts - enums are mutually exclusive!\n    }\n}\n</code></pre> <p>Benefits:</p> <p>\u2705 Zero manual parsing - clap does everything \u2705 Zero conflicts - enums are inherently exclusive \u2705 Auto-generated help - beautiful and complete \u2705 Type-safe - compiler validates everything \u2705 Easy to extend - add enum value = done \u2705 Professional errors - clap provides context  </p> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"advanced/v1.6.0-professional-cli-clap/#what-is-clap","title":"What is Clap?","text":"<p>Clap = Command Line Argument Parser</p> <p>The most popular CLI framework in Rust (used by cargo, ripgrep, bat, fd, etc.)</p> <p>Why clap?</p> <ul> <li>\u2705 Derive macros - write structs, get parser</li> <li>\u2705 Auto-generated help/version</li> <li>\u2705 Subcommands support</li> <li>\u2705 Type-safe parsing</li> <li>\u2705 Shell completions</li> <li>\u2705 Industry standard</li> </ul> <p>Adding clap:</p> <pre><code>[dependencies]\nclap = { version = \"4.5\", features = [\"derive\"] }\n</code></pre> <p>Feature <code>derive</code> enables <code>#[derive(Parser)]</code> macros.</p>"},{"location":"advanced/v1.6.0-professional-cli-clap/#the-derive-macro-pattern","title":"The derive macro pattern","text":"<p>Instead of manual parsing:</p> <pre><code>// 50 lines of if/else/match\n</code></pre> <p>Write declarative structs:</p> <pre><code>#[derive(Parser)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n</code></pre> <p>Clap generates:</p> <ul> <li>Parsing logic</li> <li>Help text</li> <li>Error messages</li> <li>Validation</li> <li>Type conversions</li> </ul> <p>All automatically!</p>"},{"location":"advanced/v1.6.0-professional-cli-clap/#main-cli-structure","title":"Main CLI structure","text":"<pre><code>#[derive(Parser)]\n#[command(name = \"todo-list\")]\n#[command(author = \"github.com/joaofelipegalvao\")]\n#[command(version = \"1.6.0\")]\n#[command(about = \"A modern, powerful task manager built with Rust\")]\n#[command(after_help = \"EXAMPLES:\n    todo add \\\"Task\\\" --priority high\n    todo list --status pending\n\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n</code></pre> <p>Attributes explained:</p> Attribute Purpose <code>#[command(name)]</code> Program name in help <code>#[command(author)]</code> Shown in <code>--version</code> <code>#[command(version)]</code> Version string <code>#[command(about)]</code> Short description <code>#[command(after_help)]</code> Examples after help <p>Result:</p> <pre><code>$ todo --help\nA modern, powerful task manager built with Rust\n\nUsage: todo-list &lt;COMMAND&gt;\n\nCommands:\n  add     Add a new task\n  list    List and filter tasks\n  ...\n\nEXAMPLES:\n    todo add \"Task\" --priority high\n    todo list --status pending\n</code></pre>"},{"location":"advanced/v1.6.0-professional-cli-clap/#subcommands-with-enum","title":"Subcommands with enum","text":"<pre><code>#[derive(Subcommand)]\nenum Commands {\n    Add(AddArgs),\n    List { ... },\n    Done { id: usize },\n    Remove { id: usize },\n    Search { query: String },\n    Tags,\n    Clear,\n}\n</code></pre> <p>Pattern:</p> <ul> <li>Named fields for simple args: <code>Done { id: usize }</code></li> <li>Separate struct for complex args: <code>Add(AddArgs)</code></li> </ul>"},{"location":"advanced/v1.6.0-professional-cli-clap/#statusfilter-enum","title":"StatusFilter enum","text":"<p>The problem we had:</p> <pre><code>// Boolean flags:\nlet mut status_filter = \"all\";  // \"all\", \"pending\", or \"done\"\n\n// Manual conflict checking:\nif args.contains(\"--pending\") &amp;&amp; args.contains(\"--done\") {\n    return Err(\"Can't use both --pending and --done\".into());\n}\n</code></pre> <p>The solution:</p> <pre><code>#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]\nenum StatusFilter {\n    /// Show only pending tasks\n    Pending,\n    /// Show only completed tasks\n    Done,\n    /// Show all tasks (default)\n    All,\n}\n</code></pre> <p>What's <code>ValueEnum</code>?</p> <p>A clap trait that makes enums work as CLI values:</p> <pre><code>todo list --status pending  # Parses to StatusFilter::Pending\ntodo list --status done     # Parses to StatusFilter::Done\ntodo list --status all      # Parses to StatusFilter::All\n</code></pre> <p>Usage in command:</p> <pre><code>List {\n    #[arg(long, value_enum, default_value_t = StatusFilter::All)]\n    status: StatusFilter,\n}\n</code></pre>"},{"location":"advanced/v1.6.0-professional-cli-clap/#duefilter-enum","title":"DueFilter enum","text":"<p>The old way - 4 boolean flags:</p> <pre><code>let mut overdue = false;\nlet mut due_soon = false;\nlet mut with_due = false;\nlet mut without_due = false;\n\n// Manual mutual exclusion:\nif overdue || due_soon || with_due || without_due {\n    return Err(\"Use only one date filter\".into());\n}\n</code></pre> <p>The new way - 1 enum:</p> <pre><code>#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]\nenum DueFilter {\n    /// Tasks past their due date\n    Overdue,\n    /// Tasks due in the next 7 days\n    Soon,\n    /// Tasks with any due date set\n    WithDue,\n    /// Tasks without a due date\n    NoDue,\n}\n</code></pre> <p>Benefits:</p> Aspect 4 Booleans 1 Enum Conflicts Manual checking Automatic (Option) Validation Runtime Compile-time Adding filter +1 bool + conflict check +1 enum variant Help text 4 separate flags 1 organized group Type safety Can set multiple true Impossible <p>Code reduction: 15 lines \u2192 3 lines</p>"},{"location":"advanced/v1.6.0-professional-cli-clap/#addargs-structure","title":"AddArgs structure","text":"<p>Dedicated struct for complex command:</p> <pre><code>#[derive(Args)]\nstruct AddArgs {\n    /// Task description\n    #[arg(value_name = \"DESCRIPTION\")]\n    text: String,\n\n    /// Task priority level\n    #[arg(long, value_enum, default_value_t = Priority::Medium)]\n    priority: Priority,\n\n    /// Add tags (can be repeated: -t work -t urgent)\n    #[arg(long, short = 't', value_name = \"TAG\")]\n    tag: Vec&lt;String&gt;,\n\n    /// Due date in format YYYY-MM-DD\n    #[arg(long, value_name = \"DATE\", value_parser = clap::value_parser!(NaiveDate))]\n    due: Option&lt;NaiveDate&gt;,\n}\n</code></pre> <p>Attributes explained:</p> <p><code>due</code> field:</p> <pre><code>#[arg(long, value_name = \"DATE\", value_parser = clap::value_parser!(NaiveDate))]\ndue: Option&lt;NaiveDate&gt;,\n</code></pre> <ul> <li><code>value_parser!(NaiveDate)</code> - THIS IS MAGIC</li> <li>Clap automatically parses string \u2192 NaiveDate</li> <li>Returns helpful error if invalid format</li> </ul> <p>Example usage:</p> <pre><code>todo add \"Deploy to production\" \\\n    --priority high \\\n    --tag work \\\n    --tag deployment \\\n    --tag urgent \\\n    --due 2026-02-15\n</code></pre> <p>All automatic!</p>"},{"location":"advanced/v1.6.0-professional-cli-clap/#command-aliases","title":"Command aliases","text":"<p>Before - single command name:</p> <pre><code>\"add\" =&gt; { /* ... */ }\n</code></pre> <p>After - multiple names:</p> <pre><code>#[command(visible_alias = \"a\")]\nAdd(AddArgs),\n\n#[command(visible_alias = \"ls\")]\nList { /* ... */ },\n\n#[command(visible_aliases = [\"rm\", \"delete\"])]\nRemove { id: usize },\n</code></pre> <p>Usage:</p> <pre><code># All equivalent:\ntodo add \"Task\"\ntodo a \"Task\"\n\n# All equivalent:\ntodo list --status pending\ntodo ls --status pending\n\n# All equivalent:\ntodo remove 3\ntodo rm 3\ntodo delete 3\n</code></pre>"},{"location":"advanced/v1.6.0-professional-cli-clap/#auto-generated-help","title":"Auto-generated help","text":"<p>Command-level help:</p> <pre><code>#[command(long_about = \"Add a new task to your todo list\\n\\n\\\n    Creates a new task with the specified text and optional metadata like priority,\\n\\\n    tags, and due date. Tasks are saved immediately to todos.json.\")]\nAdd(AddArgs),\n</code></pre> <p>Result:</p> <pre><code>$ todo add --help\nAdd a new task to your todo list\n\nCreates a new task with the specified text and optional metadata like priority,\ntags, and due date. Tasks are saved immediately to todos.json.\n\nUsage: todo add &lt;DESCRIPTION&gt; [OPTIONS]\n\nArguments:\n  &lt;DESCRIPTION&gt;  Task description\n\nOptions:\n      --priority &lt;PRIORITY&gt;  Task priority level [default: medium]\n  -t, --tag &lt;TAG&gt;           Add tags (can be repeated)\n      --due &lt;DATE&gt;          Due date in format YYYY-MM-DD\n  -h, --help                Print help\n</code></pre> <p>All from struct attributes!</p> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v1.6.0</li> <li>Full diff</li> <li>Clap documentation</li> </ul>"},{"location":"advanced/v1.7.0-professional-error-handling/","title":"v1.7.0 - Professional Error Handling with <code>anyhow</code> and <code>thiserror</code>","text":"<p>\ud83c\udfaf Goal: Transform generic error messages into professional, informative error handling</p> <p>\ud83d\udce6 The Problem We're Solving:</p> <p>Before v1.7.0 - Generic error handling:</p> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt; {\n    let content = fs::read_to_string(\"todos.json\")?;\n    let tasks: Vec&lt;Task&gt; = serde_json::from_str(&amp;content)?;\n    Ok(tasks)\n}\n</code></pre> <p>User sees:</p> <pre><code>$ todo list\nError: No such file or directory (os error 2)\n# Where? What file? How to fix?\n</code></pre> <p>Problems:</p> <p>\u274c Generic error messages \u274c No context about what operation failed \u274c Can't distinguish error types programmatically \u274c No error chains (root cause lost) \u274c Stack traces not helpful  </p> <p>After v1.7.0 - Professional error handling:</p> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;&gt; {\n    match fs::read_to_string(\"todos.json\") {\n        Ok(content) =&gt; serde_json::from_str(&amp;content)\n            .context(\"Failed to parse todos.json - file may be corrupted\"),\n        Err(e) if e.kind() == std::io::ErrorKind::NotFound =&gt; Ok(Vec::new()),\n        Err(e) =&gt; Err(e).context(format!(\n            \"Failed to read todos.json from current directory: {}\",\n            std::env::current_dir().unwrap_or_default().display()\n        )),\n    }\n}\n</code></pre> <p>User sees:</p> <pre><code>$ todo list\nError: Failed to parse todos.json - file may be corrupted\nCaused by: EOF while parsing a value at line 8 column 3\n# Clear what went wrong and why!\n</code></pre> <p>Benefits:</p> <p>\u2705 Specific error messages - Clear what failed \u2705 Rich context - Where and why it failed \u2705 Error chains - See the full cause \u2705 Typed errors - Match on specific error types \u2705 Professional UX - Helpful to users  </p>"},{"location":"advanced/v1.7.0-professional-error-handling/#key-concepts","title":"\ud83e\udde0 Key Concepts","text":""},{"location":"advanced/v1.7.0-professional-error-handling/#the-difference-anyhow-vs-thiserror","title":"The Difference: <code>anyhow</code> vs <code>thiserror</code>","text":"<p>Two crates, two purposes:</p> Crate When to Use Example anyhow Application errors (infrastructure) File I/O, parsing, network thiserror Library errors (domain logic) Invalid task ID, business rules"},{"location":"advanced/v1.7.0-professional-error-handling/#anyhow-application-error-context","title":"<code>anyhow</code> - Application Error Context","text":"<p>Use for external/infrastructure failures:</p> <pre><code>use anyhow::{Context, Result};\n\nfn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;&gt; {\n    fs::read_to_string(\"todos.json\")\n        .context(\"Failed to read todos.json\")?\n}\n</code></pre> <p>What <code>.context()</code> does:</p> <pre><code>// Without context\nErr(\"No such file or directory\")\n\n// With context\nErr(\"Failed to read todos.json\")\nCaused by: No such file or directory (os error 2)\n</code></pre> <p>Key features:</p> <ul> <li>\u2705 Easy to add context with <code>.context()</code></li> <li>\u2705 Automatic error chain display</li> <li>\u2705 Works with any error type</li> <li>\u2705 Zero boilerplate</li> </ul>"},{"location":"advanced/v1.7.0-professional-error-handling/#thiserror-custom-domain-errors","title":"<code>thiserror</code> - Custom Domain Errors","text":"<p>Use for business logic errors:</p> <pre><code>use thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum TodoError {\n    #[error(\"Task ID {id} is invalid (valid range: 1-{max})\")]\n    InvalidTaskId { id: usize, max: usize },\n\n    #[error(\"Task #{id} is already marked as {status}\")]\n    TaskAlreadyInStatus { id: usize, status: String },\n\n    #[error(\"Tag '{0}' not found in any task\")]\n    TagNotFound(String),\n}\n</code></pre> <p>Usage:</p> <pre><code>fn validate_task_id(id: usize, max: usize) -&gt; Result&lt;(), TodoError&gt; {\n    if id == 0 || id &gt; max {\n        return Err(TodoError::InvalidTaskId { id, max });\n    }\n    Ok(())\n}\n</code></pre> <p>Output:</p> <pre><code>$ todo done 15\nError: Task ID 15 is invalid (valid range: 1-10)\n</code></pre> <p>Key features:</p> <ul> <li>\u2705 Type-safe error variants</li> <li>\u2705 Automatic <code>Display</code> implementation</li> <li>\u2705 Rich data in errors (id, max, etc.)</li> <li>\u2705 Pattern matching support</li> </ul>"},{"location":"advanced/v1.7.0-professional-error-handling/#implementation-steps","title":"\ud83d\udce6 Implementation Steps","text":""},{"location":"advanced/v1.7.0-professional-error-handling/#step-1-add-dependencies","title":"Step 1: Add Dependencies","text":"<p>In <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\ncolored = \"2.1\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nchrono = { version = \"0.4\", features = [\"serde\"] }\nclap = { version = \"4.5\", features = [\"derive\"] }\nanyhow = \"1.0\"      # \u2190 NEW: Application errors\nthiserror = \"1.0\"   # \u2190 NEW: Custom errors\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#step-2-update-imports","title":"Step 2: Update Imports","text":"<p>In <code>main.rs</code>:</p> <pre><code>use std::{fs, process};\n\nuse anyhow::{Context, Result};  // \u2190 NEW\nuse chrono::{Local, NaiveDate};\nuse clap::{Args, Parser, Subcommand, ValueEnum};\nuse colored::{ColoredString, Colorize};\nuse serde::{Deserialize, Serialize};\nuse thiserror::Error;  // \u2190 NEW\n</code></pre> <p>What each import does:</p> Import Purpose <code>anyhow::Context</code> Adds <code>.context()</code> method to Results <code>anyhow::Result</code> Shorthand for <code>Result&lt;T, anyhow::Error&gt;</code> <code>thiserror::Error</code> Derive macro for custom errors"},{"location":"advanced/v1.7.0-professional-error-handling/#step-3-define-custom-error-types","title":"Step 3: Define Custom Error Types","text":"<p>Add before <code>main()</code>:</p> <pre><code>#[derive(Error, Debug)]\npub enum TodoError {\n    #[error(\"Task ID {id} is invalid (valid range: 1-{max})\")]\n    InvalidTaskId { id: usize, max: usize },\n\n    #[error(\"Task #{id} is already marked as {status}\")]\n    TaskAlreadyInStatus { id: usize, status: String },\n\n    #[error(\"Tag '{0}' not found in any task\")]\n    TagNotFound(String),\n\n    #[error(\"No tasks found matching the specified filters\")]\n    NoTasksFound,\n\n    #[error(\"No tags found in any task\")]\n    NoTagsFound,\n\n    #[error(\"Search returned no results for query: '{0}'\")]\n    NoSearchResults(String),\n}\n</code></pre> <p>Anatomy of an error variant:</p> <pre><code>#[error(\"Task ID {id} is invalid (valid range: 1-{max})\")]\n//      \u2191 Display message with field interpolation\nInvalidTaskId { id: usize, max: usize },\n//              \u2191 Fields available in error\n</code></pre> <p>Creating errors:</p> <pre><code>// Struct-like variant\nTodoError::InvalidTaskId { id: 15, max: 10 }\n// Message: \"Task ID 15 is invalid (valid range: 1-10)\"\n\n// Tuple variant\nTodoError::TagNotFound(\"urgent\".to_string())\n// Message: \"Tag 'urgent' not found in any task\"\n\n// Unit variant\nTodoError::NoTasksFound\n// Message: \"No tasks found matching the specified filters\"\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#step-4-enhanced-error-display-in-main","title":"Step 4: Enhanced Error Display in <code>main()</code>","text":"<p>Before:</p> <pre><code>fn main() {\n    let cli = Cli::parse();\n\n    if let Err(e) = run(cli) {\n        eprintln!(\"Error: {}\", e);\n        process::exit(1);\n    }\n}\n</code></pre> <p>After:</p> <pre><code>fn main() {\n    let cli = Cli::parse();\n\n    if let Err(e) = run(cli) {\n        // Main error message\n        eprintln!(\"{} {}\", \"Error:\".red().bold(), format!(\"{}\", e).red());\n\n        // Error chain (causes)\n        let mut source = e.source();\n        while let Some(cause) = source {\n            eprintln!(\"{} {}\", \"Caused by:\".red(), cause);\n            source = cause.source();\n        }\n\n        process::exit(1);\n    }\n}\n</code></pre> <p>What this displays:</p> <pre><code>Error: Failed to parse todos.json - file may be corrupted\nCaused by: EOF while parsing a value at line 8 column 3\n</code></pre> <p>The error chain:</p> <pre><code>e.source()  // Returns Option&lt;&amp;dyn Error&gt;\n</code></pre> <ul> <li>First call returns immediate cause</li> <li>Subsequent calls walk up the chain</li> <li>Returns <code>None</code> when no more causes</li> </ul>"},{"location":"advanced/v1.7.0-professional-error-handling/#step-5-update-load_tasks-with-context","title":"Step 5: Update <code>load_tasks()</code> with Context","text":"<p>Before:</p> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt; {\n    match fs::read_to_string(\"todos.json\") {\n        Ok(content) =&gt; {\n            let tasks: Vec&lt;Task&gt; = serde_json::from_str(&amp;content)?;\n            Ok(tasks)\n        }\n        Err(_) =&gt; Ok(Vec::new()),\n    }\n}\n</code></pre> <p>After:</p> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;&gt; {\n    match fs::read_to_string(\"todos.json\") {\n        Ok(content) =&gt; serde_json::from_str(&amp;content)\n            .context(\"Failed to parse todos.json - file may be corrupted\"),\n        Err(e) if e.kind() == std::io::ErrorKind::NotFound =&gt; Ok(Vec::new()),\n        Err(e) =&gt; Err(e).context(format!(\n            \"Failed to read todos.json from current directory: {}\",\n            std::env::current_dir().unwrap_or_default().display()\n        )),\n    }\n}\n</code></pre> <p>Key improvements:</p> <ol> <li>Result type: <code>Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt;</code> \u2192 <code>Result&lt;Vec&lt;Task&gt;&gt;</code></li> <li>Parse error context: Tells user the file is corrupted</li> <li>Specific NotFound handling: Empty list for missing file</li> <li>Read error context: Shows current directory in error</li> </ol> <p>Pattern matching on IO errors:</p> <pre><code>Err(e) if e.kind() == std::io::ErrorKind::NotFound =&gt; Ok(Vec::new())\n</code></pre> <ul> <li>Match guard checks error kind</li> <li>Only <code>NotFound</code> returns empty list</li> <li>Other IO errors propagate with context</li> </ul>"},{"location":"advanced/v1.7.0-professional-error-handling/#step-6-update-save_tasks-with-context","title":"Step 6: Update <code>save_tasks()</code> with Context","text":"<p>Before:</p> <pre><code>fn save_tasks(tasks: &amp;[Task]) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let json = serde_json::to_string_pretty(tasks)?;\n    fs::write(\"todos.json\", json)?;\n    Ok(())\n}\n</code></pre> <p>After:</p> <pre><code>fn save_tasks(tasks: &amp;[Task]) -&gt; Result&lt;()&gt; {\n    let json = serde_json::to_string_pretty(tasks)\n        .context(\"Failed to serialize tasks to JSON\")?;\n\n    fs::write(\"todos.json\", json)\n        .context(\"Failed to write to todos.json - check file permissions\")?;\n\n    Ok(())\n}\n</code></pre> <p>Each operation gets specific context:</p> <pre><code># If serialization fails:\nError: Failed to serialize tasks to JSON\nCaused by: recursion limit exceeded\n\n# If write fails:\nError: Failed to write to todos.json - check file permissions\nCaused by: Permission denied (os error 13)\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#step-7-create-validation-function","title":"Step 7: Create Validation Function","text":"<p>Add helper function:</p> <pre><code>fn validate_task_id(id: usize, max: usize) -&gt; Result&lt;(), TodoError&gt; {\n    if id == 0 || id &gt; max {\n        return Err(TodoError::InvalidTaskId { id, max });\n    }\n    Ok(())\n}\n</code></pre> <p>Return type breakdown:</p> <pre><code>Result&lt;(), TodoError&gt;\n//     \u2191  \u2191\n//     |  Custom error type\n//     Unit type (success returns nothing)\n</code></pre> <p>Why return <code>()</code>?</p> <ul> <li>Validation either succeeds or fails</li> <li>Success doesn't need to return data</li> <li>Failure returns rich error information</li> </ul>"},{"location":"advanced/v1.7.0-professional-error-handling/#step-8-update-commands-with-typed-errors","title":"Step 8: Update Commands with Typed Errors","text":"<p>Example: <code>done</code> command:</p> <p>Before:</p> <pre><code>Commands::Done { id } =&gt; {\n    let mut tasks = load_tasks()?;\n\n    if id == 0 || id &gt; tasks.len() {\n        eprintln!(\"Error: Invalid task ID\");\n        process::exit(1);\n    }\n\n    let index = id - 1;\n    tasks[index].mark_done();\n    save_tasks(&amp;tasks)?;\n    println!(\"{}\", \"\u2713 Task marked as completed\".green());\n}\n</code></pre> <p>After:</p> <pre><code>Commands::Done { id } =&gt; {\n    let mut tasks = load_tasks()?;\n    validate_task_id(id, tasks.len())?;  // \u2190 Typed validation\n    let index = id - 1;\n\n    // Check if already completed\n    if tasks[index].completed {\n        return Err(TodoError::TaskAlreadyInStatus {\n            id,\n            status: \"completed\".to_owned(),\n        }\n        .into());  // \u2190 Convert TodoError \u2192 anyhow::Error\n    }\n\n    tasks[index].mark_done();\n    save_tasks(&amp;tasks)?;\n    println!(\"{}\", \"\u2713 Task marked as completed\".green());\n}\n</code></pre> <p>Key changes:</p> <ol> <li>Typed validation: <code>validate_task_id()</code> returns <code>TodoError</code></li> <li>State check: Prevents marking already completed tasks</li> <li>Error conversion: <code>.into()</code> converts <code>TodoError</code> \u2192 <code>anyhow::Error</code></li> </ol> <p>The <code>.into()</code> conversion:</p> <pre><code>TodoError::TaskAlreadyInStatus { id, status }\n    .into()  // TodoError \u2192 anyhow::Error\n</code></pre> <p>Works because <code>anyhow::Error</code> accepts any type implementing <code>std::error::Error</code>, which <code>thiserror</code> automatically implements.</p>"},{"location":"advanced/v1.7.0-professional-error-handling/#step-9-update-all-commands","title":"Step 9: Update All Commands","text":"<p>Pattern for each command:</p> <pre><code>Commands::Undone { id } =&gt; {\n    let mut tasks = load_tasks()?;\n    validate_task_id(id, tasks.len())?;\n    let index = id - 1;\n\n    if !tasks[index].completed {\n        return Err(TodoError::TaskAlreadyInStatus {\n            id,\n            status: \"pending\".to_owned(),\n        }\n        .into());\n    }\n\n    tasks[index].mark_undone();\n    save_tasks(&amp;tasks)?;\n    println!(\"{}\", \"\u2713 Task unmarked\".yellow());\n}\n</code></pre> <p>For <code>list</code> command:</p> <pre><code>// At the end, after filtering\nif indexed_tasks.is_empty() {\n    return Err(TodoError::NoTasksFound.into());\n}\n</code></pre> <p>For <code>search</code> command:</p> <pre><code>if results.is_empty() {\n    return Err(TodoError::NoSearchResults(query).into());\n}\n</code></pre> <p>For <code>tags</code> command:</p> <pre><code>if all_tags.is_empty() {\n    return Err(TodoError::NoTagsFound.into());\n}\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#step-10-update-function-signatures","title":"Step 10: Update Function Signatures","text":"<p>Change all <code>Result&lt;T, Box&lt;dyn Error&gt;&gt;</code> to <code>Result&lt;T&gt;</code>:</p> <pre><code>// Before\nfn run(cli: Cli) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt;\nfn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt;\nfn save_tasks(tasks: &amp;[Task]) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt;\n\n// After\nfn run(cli: Cli) -&gt; Result&lt;()&gt;\nfn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;&gt;\nfn save_tasks(tasks: &amp;[Task]) -&gt; Result&lt;()&gt;\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#testing-error-messages","title":"\ud83e\uddea Testing Error Messages","text":""},{"location":"advanced/v1.7.0-professional-error-handling/#1-invalid-task-id","title":"1. Invalid Task ID","text":"<pre><code>$ todo done 999\nError: Task ID 999 is invalid (valid range: 1-5)\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#2-already-completed","title":"2. Already Completed","text":"<pre><code>$ todo done 1\n\u2713 Task marked as completed\n\n$ todo done 1\nError: Task #1 is already marked as completed\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#3-tag-not-found","title":"3. Tag Not Found","text":"<pre><code>$ todo list --tag nonexistent\nError: Tag 'nonexistent' not found in any task\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#4-search-no-results","title":"4. Search No Results","text":"<pre><code>$ todo search \"xyzabc\"\nError: Search returned no results for query: 'xyzabc'\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#5-corrupted-json","title":"5. Corrupted JSON","text":"<p>Edit <code>todos.json</code> to be invalid:</p> <pre><code>$ todo list\nError: Failed to parse todos.json - file may be corrupted\nCaused by: EOF while parsing a value at line 3 column 5\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#6-permission-denied","title":"6. Permission Denied","text":"<pre><code>$ chmod 000 todos.json\n$ todo list\nError: Failed to read todos.json from current directory: /home/user/projects\nCaused by: Permission denied (os error 13)\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#impact-summary","title":"\ud83d\udcca Impact Summary","text":""},{"location":"advanced/v1.7.0-professional-error-handling/#before-v170","title":"Before v1.7.0","text":"<p>\u274c Generic errors: <code>\"Error: No such file or directory\"</code> \u274c Lost context: User doesn't know what operation failed \u274c Process::exit scattered: Hard to maintain \u274c String-based errors: Can't distinguish types \u274c No error chains: Root cause lost  </p>"},{"location":"advanced/v1.7.0-professional-error-handling/#after-v170","title":"After v1.7.0","text":"<p>\u2705 Specific errors: <code>\"Task ID 15 is invalid (valid range: 1-10)\"</code> \u2705 Rich context: <code>\"Failed to parse todos.json - file may be corrupted\"</code> \u2705 Error chains: See full cause with <code>\"Caused by:\"</code> \u2705 Typed errors: Pattern match on <code>TodoError</code> variants \u2705 Clean propagation: Use <code>?</code> operator everywhere  </p>"},{"location":"advanced/v1.7.0-professional-error-handling/#code-quality-improvements","title":"Code Quality Improvements","text":"Metric Before After Error types Generic <code>Box&lt;dyn Error&gt;</code> Specific <code>TodoError</code> + <code>anyhow</code> Context None Rich with <code>.context()</code> Error chains Lost Full chain displayed User messages Generic Specific and helpful Maintainability Scattered exits Clean propagation"},{"location":"advanced/v1.7.0-professional-error-handling/#best-practices","title":"\ud83c\udfaf Best Practices","text":""},{"location":"advanced/v1.7.0-professional-error-handling/#1-use-anyhow-for-application-code","title":"1. Use <code>anyhow</code> for Application Code","text":"<pre><code>// Good: Quick context for infrastructure errors\nfs::read_to_string(\"todos.json\")\n    .context(\"Failed to read todos.json\")?\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#2-use-thiserror-for-domain-errors","title":"2. Use <code>thiserror</code> for Domain Errors","text":"<pre><code>// Good: Rich typed errors for business logic\nif id == 0 || id &gt; max {\n    return Err(TodoError::InvalidTaskId { id, max });\n}\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#3-add-context-at-every-layer","title":"3. Add Context at Every Layer","text":"<pre><code>// Good: Each layer adds context\nserde_json::from_str(&amp;content)\n    .context(\"Failed to parse todos.json - file may be corrupted\")?\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#4-pattern-match-on-specific-errors","title":"4. Pattern Match on Specific Errors","text":"<pre><code>// Good: Handle specific error types differently\nmatch fs::read_to_string(\"todos.json\") {\n    Ok(content) =&gt; { /* ... */ }\n    Err(e) if e.kind() == ErrorKind::NotFound =&gt; Ok(Vec::new()),\n    Err(e) =&gt; Err(e).context(\"Failed to read file\"),\n}\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#5-convert-between-error-types","title":"5. Convert Between Error Types","text":"<pre><code>// Good: Custom errors convert to anyhow\nTodoError::InvalidTaskId { id, max }\n    .into()  // TodoError \u2192 anyhow::Error\n</code></pre>"},{"location":"advanced/v1.7.0-professional-error-handling/#resources","title":"\ud83d\udd17 Resources","text":"<ul> <li>Code v1.7.0</li> <li>Full diff</li> <li>anyhow documentation</li> <li>thiserror documentation</li> <li>Rust Error Handling Book</li> </ul>"},{"location":"advanced/v1.7.0-professional-error-handling/#learning-outcomes","title":"\ud83c\udf93 Learning Outcomes","text":"<p>After implementing v1.7.0, you understand:</p> <ol> <li>Error Context: How to add rich context to errors</li> <li>Error Chains: How errors propagate through the call stack</li> <li>Custom Errors: Creating domain-specific error types</li> <li>Error Conversion: Converting between error types</li> <li>Professional UX: Providing helpful error messages</li> <li>Type Safety: Using types to distinguish error cases</li> <li>Clean Propagation: Using <code>?</code> instead of manual handling</li> </ol> <p>This is production-ready error handling! \ud83c\udf89</p>"},{"location":"concepts/advanced-error-handling/","title":"Advanced Error Handling","text":"<p>\ud83d\udcda Overview:</p> <p>This page covers advanced error handling patterns in Rust, focusing on the <code>anyhow</code> and <code>thiserror</code> crates for professional error management.</p> <p>\ud83d\udd17 Related Versions:</p> <ul> <li>v0.1.0 - Basic <code>?</code> operator</li> <li>v0.3.0 - Input validation</li> <li>v0.4.2 - Precondition validation</li> <li>v1.7.0 - Professional error handling</li> </ul>"},{"location":"concepts/advanced-error-handling/#the-error-handling-spectrum","title":"The Error Handling Spectrum","text":""},{"location":"concepts/advanced-error-handling/#level-1-basic-error-propagation","title":"Level 1: Basic Error Propagation","text":"<p>Using <code>Box&lt;dyn Error&gt;</code> for generic errors:</p> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt; {\n    let content = fs::read_to_string(\"todos.json\")?;\n    let tasks: Vec&lt;Task&gt; = serde_json::from_str(&amp;content)?;\n    Ok(tasks)\n}\n</code></pre> <p>Characteristics:</p> <ul> <li>\u2705 Simple to implement</li> <li>\u2705 Works with any error type</li> <li>\u274c No context about what failed</li> <li>\u274c Generic error messages</li> <li>\u274c Can't distinguish error types</li> </ul>"},{"location":"concepts/advanced-error-handling/#level-2-application-errors-with-anyhow","title":"Level 2: Application Errors with <code>anyhow</code>","text":"<p>Adding context to infrastructure errors:</p> <pre><code>use anyhow::{Context, Result};\n\nfn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;&gt; {\n    let content = fs::read_to_string(\"todos.json\")\n        .context(\"Failed to read todos.json\")?;\n\n    serde_json::from_str(&amp;content)\n        .context(\"Failed to parse todos.json - file may be corrupted\")\n}\n</code></pre> <p>Characteristics:</p> <ul> <li>\u2705 Rich context at each layer</li> <li>\u2705 Error chains show root causes</li> <li>\u2705 Works with any error type</li> <li>\u2705 Minimal boilerplate</li> <li>\u274c Can't pattern match on error types</li> </ul>"},{"location":"concepts/advanced-error-handling/#level-3-custom-domain-errors-with-thiserror","title":"Level 3: Custom Domain Errors with <code>thiserror</code>","text":"<p>Type-safe errors for business logic:</p> <pre><code>use thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum TodoError {\n    #[error(\"Task ID {id} is invalid (valid range: 1-{max})\")]\n    InvalidTaskId { id: usize, max: usize },\n\n    #[error(\"Task #{id} is already marked as {status}\")]\n    TaskAlreadyInStatus { id: usize, status: String },\n}\n\nfn validate_task_id(id: usize, max: usize) -&gt; Result&lt;(), TodoError&gt; {\n    if id == 0 || id &gt; max {\n        return Err(TodoError::InvalidTaskId { id, max });\n    }\n    Ok(())\n}\n</code></pre> <p>Characteristics:</p> <ul> <li>\u2705 Type-safe error variants</li> <li>\u2705 Rich data in errors</li> <li>\u2705 Pattern matching support</li> <li>\u2705 Automatic Display implementation</li> <li>\u2705 Professional error messages</li> </ul>"},{"location":"concepts/advanced-error-handling/#the-anyhow-crate","title":"The <code>anyhow</code> Crate","text":""},{"location":"concepts/advanced-error-handling/#core-concept-error-context","title":"Core Concept: Error Context","text":"<p>The <code>.context()</code> method:</p> <pre><code>use anyhow::{Context, Result};\n\nfn operation() -&gt; Result&lt;String&gt; {\n    fs::read_to_string(\"file.txt\")\n        .context(\"Failed to read configuration file\")?\n}\n</code></pre> <p>What <code>.context()</code> does:</p> <ol> <li>Wraps the original error</li> <li>Adds descriptive context</li> <li>Preserves error chain</li> <li>Returns <code>anyhow::Error</code></li> </ol> <p>Error chain display:</p> <pre><code>Error: Failed to read configuration file\nCaused by: No such file or directory (os error 2)\n</code></pre>"},{"location":"concepts/advanced-error-handling/#the-resultt-type-alias","title":"The <code>Result&lt;T&gt;</code> Type Alias","text":"<p>Shorthand for common pattern:</p> <pre><code>// Instead of writing:\nfn operation() -&gt; Result&lt;Vec&lt;Task&gt;, anyhow::Error&gt;\n\n// Use shorthand:\nfn operation() -&gt; Result&lt;Vec&lt;Task&gt;&gt;\n// Automatically means Result&lt;T, anyhow::Error&gt;\n</code></pre> <p>Import:</p> <pre><code>use anyhow::Result;  // Shadows std::result::Result\n</code></pre>"},{"location":"concepts/advanced-error-handling/#advanced-context-patterns","title":"Advanced Context Patterns","text":"<p>Dynamic context with format!:</p> <pre><code>fn load_user_data(id: u32) -&gt; Result&lt;User&gt; {\n    fs::read_to_string(format!(\"user_{}.json\", id))\n        .context(format!(\"Failed to load user {} data\", id))?\n}\n// Error: Failed to load user 42 data\n</code></pre> <p>Conditional context:</p> <pre><code>match fs::read_to_string(\"todos.json\") {\n    Ok(content) =&gt; Ok(content),\n    Err(e) if e.kind() == ErrorKind::NotFound =&gt; {\n        // No context needed - expected case\n        Ok(String::new())\n    }\n    Err(e) =&gt; {\n        // Add context for unexpected errors\n        Err(e).context(\"Failed to read todos.json\")\n    }\n}\n</code></pre>"},{"location":"concepts/advanced-error-handling/#error-chain-traversal","title":"Error Chain Traversal","text":"<p>Walking the error chain:</p> <pre><code>fn display_error_chain(err: &amp;anyhow::Error) {\n    eprintln!(\"Error: {}\", err);\n\n    let mut source = err.source();\n    while let Some(cause) = source {\n        eprintln!(\"Caused by: {}\", cause);\n        source = cause.source();\n    }\n}\n</code></pre> <p>Example output:</p> <pre><code>Error: Failed to parse todos.json - file may be corrupted\nCaused by: EOF while parsing a value at line 8 column 3\n</code></pre>"},{"location":"concepts/advanced-error-handling/#the-thiserror-crate","title":"The <code>thiserror</code> Crate","text":""},{"location":"concepts/advanced-error-handling/#core-concept-custom-error-types","title":"Core Concept: Custom Error Types","text":"<p>The <code>#[derive(Error)]</code> macro:</p> <pre><code>use thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum TodoError {\n    #[error(\"Task ID {id} is invalid (valid range: 1-{max})\")]\n    InvalidTaskId { id: usize, max: usize },\n}\n</code></pre> <p>What the macro generates:</p> <ol> <li><code>std::error::Error</code> implementation</li> <li><code>Display</code> implementation using <code>#[error]</code> template</li> <li>Field access for error data</li> </ol>"},{"location":"concepts/advanced-error-handling/#error-variant-patterns","title":"Error Variant Patterns","text":"<p>Struct-like variants (named fields):</p> <pre><code>#[error(\"Task ID {id} is invalid (valid range: 1-{max})\")]\nInvalidTaskId { id: usize, max: usize },\n\n// Usage:\nTodoError::InvalidTaskId { id: 15, max: 10 }\n// Display: \"Task ID 15 is invalid (valid range: 1-10)\"\n</code></pre> <p>Tuple variants (positional fields):</p> <pre><code>#[error(\"Tag '{0}' not found in any task\")]\nTagNotFound(String),\n\n// Usage:\nTodoError::TagNotFound(\"urgent\".to_string())\n// Display: \"Tag 'urgent' not found in any task\"\n</code></pre> <p>Unit variants (no fields):</p> <pre><code>#[error(\"No tasks found matching the specified filters\")]\nNoTasksFound,\n\n// Usage:\nTodoError::NoTasksFound\n// Display: \"No tasks found matching the specified filters\"\n</code></pre>"},{"location":"concepts/advanced-error-handling/#field-interpolation","title":"Field Interpolation","text":"<p>Accessing fields in error messages:</p> <pre><code>#[error(\"Expected {expected}, found {found}\")]\nTypeMismatch { expected: String, found: String },\n\n// Multiple field access patterns:\n#[error(\"Position: ({x}, {y})\")]\nPosition { x: i32, y: i32 },\n\n// Positional access for tuples:\n#[error(\"First: {0}, Second: {1}\")]\nTwoValues(String, String),\n</code></pre>"},{"location":"concepts/advanced-error-handling/#error-source-chaining","title":"Error Source Chaining","text":"<p>Wrapping other errors:</p> <pre><code>#[derive(Error, Debug)]\npub enum TodoError {\n    #[error(\"Failed to load tasks\")]\n    LoadError(#[from] std::io::Error),\n\n    #[error(\"Failed to parse tasks\")]\n    ParseError(#[from] serde_json::Error),\n}\n</code></pre> <p>The <code>#[from]</code> attribute:</p> <ul> <li>Automatically implements <code>From&lt;IoError&gt;</code> for <code>TodoError</code></li> <li>Enables <code>?</code> operator to convert errors</li> <li>Preserves error chain</li> </ul> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, TodoError&gt; {\n    let content = fs::read_to_string(\"todos.json\")?;\n    // IoError automatically converts to TodoError::LoadError\n\n    let tasks = serde_json::from_str(&amp;content)?;\n    // JsonError automatically converts to TodoError::ParseError\n\n    Ok(tasks)\n}\n</code></pre>"},{"location":"concepts/advanced-error-handling/#combining-anyhow-and-thiserror","title":"Combining <code>anyhow</code> and <code>thiserror</code>","text":""},{"location":"concepts/advanced-error-handling/#the-strategy","title":"The Strategy","text":"<p>Use both together for maximum benefit:</p> <ol> <li><code>thiserror</code> for domain-specific errors</li> <li><code>anyhow</code> for application-level error handling</li> <li>Convert between them with <code>.into()</code></li> </ol>"},{"location":"concepts/advanced-error-handling/#conversion-pattern","title":"Conversion Pattern","text":"<p>Custom error \u2192 anyhow error:</p> <pre><code>use anyhow::Result;\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum TodoError {\n    #[error(\"Invalid task ID: {0}\")]\n    InvalidId(usize),\n}\n\nfn validate_id(id: usize) -&gt; Result&lt;()&gt; {\n    if id == 0 {\n        return Err(TodoError::InvalidId(id).into());\n        //                                    \u2191 Convert to anyhow::Error\n    }\n    Ok(())\n}\n</code></pre> <p>Why this works:</p> <ul> <li><code>anyhow::Error</code> accepts any <code>std::error::Error</code></li> <li><code>thiserror</code> implements <code>std::error::Error</code></li> <li><code>.into()</code> performs the conversion</li> </ul>"},{"location":"concepts/advanced-error-handling/#real-world-example","title":"Real-World Example","text":"<p>Domain errors + application context:</p> <pre><code>#[derive(Error, Debug)]\npub enum TodoError {\n    #[error(\"Task ID {id} is invalid (valid range: 1-{max})\")]\n    InvalidTaskId { id: usize, max: usize },\n}\n\nfn done_command(id: usize) -&gt; Result&lt;()&gt; {\n    let mut tasks = load_tasks()\n        .context(\"Failed to load tasks from file\")?;  // anyhow context\n\n    validate_task_id(id, tasks.len())?;  // TodoError propagates\n\n    let index = id - 1;\n    if tasks[index].completed {\n        return Err(TodoError::TaskAlreadyInStatus {\n            id,\n            status: \"completed\".to_owned(),\n        }\n        .into());  // Convert TodoError \u2192 anyhow::Error\n    }\n\n    tasks[index].mark_done();\n    save_tasks(&amp;tasks)\n        .context(\"Failed to save tasks to file\")?;  // anyhow context\n\n    Ok(())\n}\n</code></pre> <p>Error output:</p> <pre><code># For infrastructure error:\nError: Failed to load tasks from file\nCaused by: Permission denied (os error 13)\n\n# For domain error:\nError: Task #3 is already marked as completed\n</code></pre>"},{"location":"concepts/advanced-error-handling/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"concepts/advanced-error-handling/#pattern-1-granular-error-matching","title":"Pattern 1: Granular Error Matching","text":"<p>Handle specific error types differently:</p> <pre><code>match fs::read_to_string(\"todos.json\") {\n    Ok(content) =&gt; parse_tasks(content),\n    Err(e) if e.kind() == ErrorKind::NotFound =&gt; {\n        // File missing is expected - start with empty list\n        Ok(Vec::new())\n    }\n    Err(e) if e.kind() == ErrorKind::PermissionDenied =&gt; {\n        // Permission error needs different handling\n        Err(e).context(\"No permission to read todos.json - check file permissions\")\n    }\n    Err(e) =&gt; {\n        // Other errors\n        Err(e).context(\"Failed to read todos.json\")\n    }\n}\n</code></pre>"},{"location":"concepts/advanced-error-handling/#pattern-2-early-return-with-context","title":"Pattern 2: Early Return with Context","text":"<p>Validate and add context at each step:</p> <pre><code>fn process_task(id: usize) -&gt; Result&lt;()&gt; {\n    // Validation\n    validate_task_id(id, 10)\n        .context(\"Task ID validation failed\")?;\n\n    // Load with context\n    let mut tasks = load_tasks()\n        .context(\"Failed to load task list\")?;\n\n    // Business logic\n    let task = tasks.get_mut(id - 1)\n        .ok_or_else(|| anyhow!(\"Task {} not found\", id))?;\n\n    task.mark_done();\n\n    // Save with context\n    save_tasks(&amp;tasks)\n        .context(\"Failed to save updated tasks\")?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"concepts/advanced-error-handling/#pattern-3-fallible-iterators","title":"Pattern 3: Fallible Iterators","text":"<p>Handle errors in collection operations:</p> <pre><code>fn load_all_tasks() -&gt; Result&lt;Vec&lt;Task&gt;&gt; {\n    let paths = fs::read_dir(\"tasks\")?;\n\n    let tasks: Result&lt;Vec&lt;Task&gt;&gt; = paths\n        .map(|entry| {\n            let entry = entry?;\n            let content = fs::read_to_string(entry.path())\n                .context(format!(\"Failed to read {:?}\", entry.path()))?;\n            serde_json::from_str(&amp;content)\n                .context(format!(\"Failed to parse {:?}\", entry.path()))\n        })\n        .collect();\n\n    tasks\n}\n</code></pre>"},{"location":"concepts/advanced-error-handling/#pattern-4-custom-error-construction","title":"Pattern 4: Custom Error Construction","text":"<p>Building errors with rich context:</p> <pre><code>fn find_task_by_tag(tag: &amp;str) -&gt; Result&lt;Task&gt; {\n    let tasks = load_tasks()?;\n\n    tasks\n        .into_iter()\n        .find(|t| t.tags.contains(&amp;tag.to_string()))\n        .ok_or_else(|| {\n            anyhow!(\n                \"No task found with tag '{}'. Available tags: {}\",\n                tag,\n                get_all_tags().join(\", \")\n            )\n        })\n}\n</code></pre>"},{"location":"concepts/advanced-error-handling/#best-practices","title":"Best Practices","text":""},{"location":"concepts/advanced-error-handling/#1-context-at-every-layer","title":"1. Context at Every Layer","text":"<p>Add context at each abstraction level:</p> <pre><code>// \u2705 Good: Context at each layer\nfn high_level() -&gt; Result&lt;()&gt; {\n    mid_level()\n        .context(\"High-level operation failed\")?;\n    Ok(())\n}\n\nfn mid_level() -&gt; Result&lt;()&gt; {\n    low_level()\n        .context(\"Mid-level operation failed\")?;\n    Ok(())\n}\n\nfn low_level() -&gt; Result&lt;()&gt; {\n    fs::read_to_string(\"file.txt\")\n        .context(\"Failed to read file\")?;\n    Ok(())\n}\n</code></pre> <p>Error output:</p> <pre><code>Error: High-level operation failed\nCaused by: Mid-level operation failed\nCaused by: Failed to read file\nCaused by: No such file or directory (os error 2)\n</code></pre>"},{"location":"concepts/advanced-error-handling/#2-specific-error-messages","title":"2. Specific Error Messages","text":"<p>Include relevant details in messages:</p> <pre><code>// \u274c Bad: Generic\n.context(\"Operation failed\")\n\n// \u2705 Good: Specific\n.context(\"Failed to read todos.json from current directory\")\n\n// \u2705 Better: With dynamic data\n.context(format!(\"Failed to load user {} data\", user_id))\n</code></pre>"},{"location":"concepts/advanced-error-handling/#3-use-thiserror-for-domain-logic","title":"3. Use <code>thiserror</code> for Domain Logic","text":"<p>Domain errors deserve custom types:</p> <pre><code>// \u2705 Good: Custom error for business rules\n#[derive(Error, Debug)]\npub enum TodoError {\n    #[error(\"Task ID {id} is invalid (valid range: 1-{max})\")]\n    InvalidTaskId { id: usize, max: usize },\n}\n\n// \u274c Bad: Generic error for business rules\nif id &gt; max {\n    return Err(anyhow!(\"Invalid ID\"));\n}\n</code></pre>"},{"location":"concepts/advanced-error-handling/#4-use-anyhow-for-infrastructure","title":"4. Use <code>anyhow</code> for Infrastructure","text":"<p>Infrastructure errors don't need custom types:</p> <pre><code>// \u2705 Good: anyhow for file operations\nfs::read_to_string(\"todos.json\")\n    .context(\"Failed to read todos.json\")?\n\n// \u274c Overkill: Custom error for file operations\n#[derive(Error, Debug)]\nenum FileError {\n    #[error(\"Failed to read file\")]\n    ReadError,\n}\n</code></pre>"},{"location":"concepts/advanced-error-handling/#5-convert-at-api-boundaries","title":"5. Convert at API Boundaries","text":"<p>Keep internal errors typed, convert at boundaries:</p> <pre><code>// Internal function - returns custom error\nfn validate_task_id(id: usize, max: usize) -&gt; Result&lt;(), TodoError&gt; {\n    if id == 0 || id &gt; max {\n        return Err(TodoError::InvalidTaskId { id, max });\n    }\n    Ok(())\n}\n\n// Public API - converts to anyhow\npub fn done_command(id: usize) -&gt; Result&lt;()&gt; {\n    validate_task_id(id, max)?;  // TodoError converts automatically\n    // ... rest of command\n    Ok(())\n}\n</code></pre>"},{"location":"concepts/advanced-error-handling/#testing-error-cases","title":"Testing Error Cases","text":""},{"location":"concepts/advanced-error-handling/#unit-testing-custom-errors","title":"Unit Testing Custom Errors","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_invalid_task_id() {\n        let result = validate_task_id(0, 5);\n        assert!(result.is_err());\n\n        let err = result.unwrap_err();\n        assert!(matches!(err, TodoError::InvalidTaskId { .. }));\n    }\n\n    #[test]\n    fn test_error_message() {\n        let err = TodoError::InvalidTaskId { id: 10, max: 5 };\n        assert_eq!(\n            err.to_string(),\n            \"Task ID 10 is invalid (valid range: 1-5)\"\n        );\n    }\n}\n</code></pre>"},{"location":"concepts/advanced-error-handling/#integration-testing-error-chains","title":"Integration Testing Error Chains","text":"<pre><code>#[test]\nfn test_error_chain() {\n    let result = load_tasks_from_corrupted_file();\n\n    assert!(result.is_err());\n    let err = result.unwrap_err();\n\n    // Check main error\n    let msg = err.to_string();\n    assert!(msg.contains(\"Failed to parse\"));\n\n    // Check error chain\n    let source = err.source().unwrap();\n    assert!(source.to_string().contains(\"EOF while parsing\"));\n}\n</code></pre>"},{"location":"concepts/advanced-error-handling/#performance-considerations","title":"Performance Considerations","text":""},{"location":"concepts/advanced-error-handling/#error-creation-cost","title":"Error Creation Cost","text":"<p>Errors have overhead - use appropriately:</p> <pre><code>// \u2705 Good: Error in error path (infrequent)\nif id == 0 {\n    return Err(TodoError::InvalidTaskId { id, max });\n}\n\n// \u274c Bad: Error in hot path (frequent)\nfor id in 1..1_000_000 {\n    validate_task_id(id, max)?;  // Creating errors constantly\n}\n\n// \u2705 Better: Validate before loop\nvalidate_task_id_range(1, 1_000_000, max)?;\nfor id in 1..1_000_000 {\n    // No validation needed\n}\n</code></pre>"},{"location":"concepts/advanced-error-handling/#string-allocation","title":"String Allocation","text":"<p>Context messages allocate strings:</p> <pre><code>// \u2705 Good: Static string (no allocation)\n.context(\"Failed to read file\")\n\n// \ud83e\udd14 OK: Dynamic string (allocates, but only on error)\n.context(format!(\"Failed to read user {} data\", id))\n\n// \u274c Bad: Unnecessary allocation\n.context(format!(\"Failed\"))  // Just use static string!\n</code></pre>"},{"location":"concepts/advanced-error-handling/#resources","title":"Resources","text":"<ul> <li>anyhow documentation</li> <li>thiserror documentation</li> <li>Rust Error Handling Book</li> <li>Error Handling Survey</li> </ul> <p>\ud83d\udcda See Also:</p> <ul> <li>Error Handling Basics - Foundational patterns</li> <li>Type Safety - Using types to prevent errors</li> <li>Professional Error Handling - Complete implementation</li> </ul>"},{"location":"concepts/cli-design/","title":"CLI Design Patterns","text":"<p>\ud83d\udcda Overview:</p> <p>This page covers command-line interface design patterns used throughout the todo-cli project, from basic argument parsing to professional CLI frameworks.</p> <p>\ud83d\udd17 Related Versions:</p> <ul> <li>v0.1.0 - Basic subcommands</li> <li>v0.7.0 - Flag parsing</li> <li>v1.4.0 - Multiple flags</li> <li>v1.6.0 - Clap framework</li> </ul>"},{"location":"concepts/cli-design/#basic-subcommand-pattern","title":"Basic Subcommand Pattern","text":"<p>Simple command matching:</p> <pre><code>use std::env;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    if args.len() &lt; 2 {\n        return Err(\"Usage: todo &lt;command&gt;\".into());\n    }\n\n    match args[1].as_str() {\n        \"add\" =&gt; handle_add(&amp;args),\n        \"list\" =&gt; handle_list(&amp;args),\n        \"done\" =&gt; handle_done(&amp;args),\n        _ =&gt; return Err(\"Unknown command\".into()),\n    }\n}\n</code></pre> <p>Characteristics:</p> <ul> <li>\u2705 Simple to understand</li> <li>\u2705 No dependencies</li> <li>\u274c Manual parsing required</li> <li>\u274c No auto-generated help</li> </ul>"},{"location":"concepts/cli-design/#flag-parsing-patterns","title":"Flag Parsing Patterns","text":""},{"location":"concepts/cli-design/#single-value-flags","title":"Single Value Flags","text":"<p>Flags with values:</p> <pre><code>\"add\" =&gt; {\n    let mut priority = Priority::Medium;\n    let mut i = 3;  // Start after command and task text\n\n    while i &lt; args.len() {\n        match args[i].as_str() {\n            \"--priority\" =&gt; {\n                if i + 1 &gt;= args.len() {\n                    return Err(\"--priority requires a value\".into());\n                }\n                priority = match args[i + 1].as_str() {\n                    \"high\" =&gt; Priority::High,\n                    \"medium\" =&gt; Priority::Medium,\n                    \"low\" =&gt; Priority::Low,\n                    _ =&gt; return Err(\"Invalid priority\".into()),\n                };\n                i += 1;  // Skip the value\n            }\n            _ =&gt; return Err(format!(\"Unknown flag: {}\", args[i]).into()),\n        }\n        i += 1;\n    }\n}\n</code></pre>"},{"location":"concepts/cli-design/#multiple-value-flags","title":"Multiple Value Flags","text":"<p>Repeatable flags:</p> <pre><code>\"add\" =&gt; {\n    let mut tags: Vec&lt;String&gt; = Vec::new();\n    let mut i = 3;\n\n    while i &lt; args.len() {\n        match args[i].as_str() {\n            \"--tag\" =&gt; {\n                if i + 1 &gt;= args.len() {\n                    return Err(\"--tag requires a value\".into());\n                }\n                tags.push(args[i + 1].clone());\n                i += 1;  // Skip the tag value\n            }\n            _ =&gt; { /* ... */ }\n        }\n        i += 1;\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>todo add \"Task\" --tag work --tag urgent --tag backend\n</code></pre>"},{"location":"concepts/cli-design/#mutual-exclusion-patterns","title":"Mutual Exclusion Patterns","text":""},{"location":"concepts/cli-design/#boolean-flags-with-manual-validation","title":"Boolean Flags with Manual Validation","text":"<p>Preventing conflicting flags:</p> <pre><code>\"list\" =&gt; {\n    let mut status_filter = \"all\";\n    let mut priority_filter: Option&lt;Priority&gt; = None;\n    let mut sort = false;\n\n    // Parse flags...\n\n    // Manual conflict checking\n    if status_filter != \"all\" &amp;&amp; priority_filter.is_some() {\n        return Err(\"Can't combine status and priority filters\".into());\n    }\n}\n</code></pre>"},{"location":"concepts/cli-design/#enum-based-mutual-exclusion","title":"Enum-Based Mutual Exclusion","text":"<p>Type-safe exclusive options:</p> <pre><code>#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]\nenum StatusFilter {\n    Pending,\n    Done,\n    All,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]\nenum DueFilter {\n    Overdue,\n    Soon,\n    WithDue,\n    NoDue,\n}\n\n// Usage in command\nList {\n    #[arg(long, value_enum, default_value_t = StatusFilter::All)]\n    status: StatusFilter,\n\n    #[arg(long, value_enum)]\n    due: Option&lt;DueFilter&gt;,  // None = no filter, Some = exclusive filter\n}\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Compile-time safety - impossible to have conflicts</li> <li>\u2705 Type safety - no string matching</li> <li>\u2705 Auto-validation - clap handles it</li> <li>\u2705 Better help - enum values shown in help</li> </ul>"},{"location":"concepts/cli-design/#command-aliases","title":"Command Aliases","text":"<p>Multiple names for same command:</p> <pre><code>// With clap\n#[command(visible_alias = \"a\")]\nAdd(AddArgs),\n\n#[command(visible_alias = \"ls\")]\nList { /* ... */ },\n\n#[command(visible_aliases = [\"rm\", \"delete\"])]\nRemove { id: usize },\n</code></pre> <p>Usage:</p> <pre><code># All equivalent:\ntodo add \"Task\"\ntodo a \"Task\"\n\n# All equivalent:\ntodo list --status pending\ntodo ls --status pending\n\n# All equivalent:\ntodo remove 3\ntodo rm 3\ntodo delete 3\n</code></pre>"},{"location":"concepts/cli-design/#help-generation-patterns","title":"Help Generation Patterns","text":""},{"location":"concepts/cli-design/#manual-help","title":"Manual Help","text":"<p>Writing help by hand:</p> <pre><code>fn print_help() {\n    println!(\"Usage: todo &lt;command&gt; [options]\");\n    println!(\"\");\n    println!(\"Commands:\");\n    println!(\"  add     Add a new task\");\n    println!(\"  list    List tasks\");\n    println!(\"  done    Mark task as completed\");\n    println!(\"\");\n    println!(\"Examples:\");\n    println!(\"  todo add \\\"Task\\\" --priority high\");\n}\n</code></pre> <p>Problems:</p> <ul> <li>\u274c Must update manually</li> <li>\u274c Easy to forget to update</li> <li>\u274c No command-specific help</li> </ul>"},{"location":"concepts/cli-design/#auto-generated-help","title":"Auto-Generated Help","text":"<p>With clap derive macros:</p> <pre><code>#[derive(Parser)]\n#[command(about = \"A modern task manager\", long_about = None)]\n#[command(after_help = \"EXAMPLES:\n    todo add \\\"Task\\\" --priority high\n    todo list --status pending\n\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    #[command(about = \"Add a new task\")]\n    Add {\n        #[arg(about = \"Task description\")]\n        text: String,\n\n        #[arg(long, about = \"Task priority\")]\n        priority: Priority,\n    },\n}\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Automatic - no manual help writing</li> <li>\u2705 Consistent - same style everywhere</li> <li>\u2705 Complete - includes all options</li> <li>\u2705 Per-command - <code>todo add --help</code> works</li> </ul>"},{"location":"concepts/cli-design/#error-message-patterns","title":"Error Message Patterns","text":""},{"location":"concepts/cli-design/#generic-errors","title":"Generic Errors","text":"<p>Simple but unhelpful:</p> <pre><code>return Err(\"Invalid input\".into());\n</code></pre>"},{"location":"concepts/cli-design/#specific-errors","title":"Specific Errors","text":"<p>Better - tells user what's wrong:</p> <pre><code>return Err(\"Invalid task number. Use 1-5\".into());\n</code></pre>"},{"location":"concepts/cli-design/#contextual-errors","title":"Contextual Errors","text":"<p>Best - shows the actual problem:</p> <pre><code>return Err(format!(\"Task {} doesn't exist. Available: 1-5\", number).into());\n</code></pre>"},{"location":"concepts/cli-design/#professional-cli-errors","title":"Professional CLI Errors","text":"<p>With clap - automatic context:</p> <pre><code>#[arg(value_parser = clap::value_parser!(NaiveDate))]\ndue: Option&lt;NaiveDate&gt;,\n</code></pre> <p>Result:</p> <pre><code>$ todo add \"Task\" --due 2026-13-50\nerror: invalid value '2026-13-50' for '--due &lt;DATE&gt;': input is out of range\n</code></pre>"},{"location":"concepts/cli-design/#input-validation-patterns","title":"Input Validation Patterns","text":""},{"location":"concepts/cli-design/#argument-count-validation","title":"Argument Count Validation","text":"<p>Check minimum required arguments:</p> <pre><code>\"add\" =&gt; {\n    if args.len() &lt; 3 {\n        return Err(\"Usage: todo add &lt;task&gt;\".into());\n    }\n    let task = &amp;args[2];\n    // ...\n}\n</code></pre>"},{"location":"concepts/cli-design/#type-validation","title":"Type Validation","text":"<p>Parse with error handling:</p> <pre><code>\"done\" =&gt; {\n    if args.len() &lt; 3 {\n        return Err(\"Usage: todo done &lt;number&gt;\".into());\n    }\n\n    let number: usize = match args[2].parse() {\n        Ok(n) =&gt; n,\n        Err(_) =&gt; return Err(\"Task number must be a positive integer\".into()),\n    };\n    // ...\n}\n</code></pre>"},{"location":"concepts/cli-design/#range-validation","title":"Range Validation","text":"<p>Check if number is within valid range:</p> <pre><code>if number == 0 || number &gt; tasks.len() {\n    return Err(format!(\"Invalid task number {}. Available: 1-{}\", \n                     number, tasks.len()).into());\n}\n</code></pre>"},{"location":"concepts/cli-design/#user-experience-patterns","title":"User Experience Patterns","text":""},{"location":"concepts/cli-design/#immediate-feedback","title":"Immediate Feedback","text":"<p>Confirm successful operations:</p> <pre><code>\"add\" =&gt; {\n    // ... add task ...\n    println!(\"{}\", \"\u2713 Task added\".green());\n}\n\n\"done\" =&gt; {\n    // ... mark task done ...\n    println!(\"{}\", \"\u2713 Task marked as completed\".green());\n}\n</code></pre>"},{"location":"concepts/cli-design/#semantic-colors","title":"Semantic Colors","text":"<p>Use colors to convey meaning:</p> <pre><code>// Success (positive actions)\nprintln!(\"{}\", \"\u2713 Task added\".green());\nprintln!(\"{}\", \"\u2713 Task completed\".green());\n\n// Neutral (reversible actions)\nprintln!(\"{}\", \"\u2713 Task unmarked\".yellow());\n\n// Destructive (permanent actions)\nprintln!(\"{}\", \"\u2713 Task removed\".red());\nprintln!(\"{}\", \"\u2713 All tasks cleared\".red().bold());\n</code></pre>"},{"location":"concepts/cli-design/#progress-indicators","title":"Progress Indicators","text":"<p>Show progress for operations:</p> <pre><code>\"list\" =&gt; {\n    let tasks = load_tasks()?;\n\n    if tasks.is_empty() {\n        println!(\"No tasks\");\n        return Ok(());\n    }\n\n    let completed = tasks.iter().filter(|t| t.completed).count();\n    let total = tasks.len();\n    let percentage = (completed as f32 / total as f32 * 100.0) as u32;\n\n    // Display tasks...\n\n    println!(\"\\n{} of {} completed ({}%)\", completed, total, percentage);\n\n    if percentage == 100 {\n        println!(\"{}\", \"\ud83c\udf89 All tasks completed!\".green().bold());\n    }\n}\n</code></pre>"},{"location":"concepts/cli-design/#command-discovery-patterns","title":"Command Discovery Patterns","text":""},{"location":"concepts/cli-design/#help-command","title":"Help Command","text":"<p>Show available commands:</p> <pre><code>\"help\" =&gt; {\n    println!(\"Available commands:\");\n    println!(\"  add     - Add a new task\");\n    println!(\"  list    - List tasks\");\n    println!(\"  done    - Mark task as completed\");\n    println!(\"  remove  - Remove a task\");\n    println!(\"  clear   - Remove all tasks\");\n    println!(\"  help    - Show this help\");\n}\n</code></pre>"},{"location":"concepts/cli-design/#list-command","title":"List Command","text":"<p>Discovery command for data:</p> <pre><code>\"tags\" =&gt; {\n    let tasks = load_tasks()?;\n\n    // Collect all unique tags\n    let mut all_tags: Vec&lt;String&gt; = Vec::new();\n    for task in &amp;tasks {\n        for tag in &amp;task.tags {\n            if !all_tags.contains(tag) {\n                all_tags.push(tag.clone());\n            }\n        }\n    }\n\n    if all_tags.is_empty() {\n        println!(\"No tags found\");\n    } else {\n        println!(\"Available tags:\");\n        for tag in &amp;all_tags {\n            let count = tasks.iter().filter(|t| t.tags.contains(tag)).count();\n            println!(\"  {} ({} task{})\", tag, count, \n                    if count == 1 { \"\" } else { \"s\" });\n        }\n    }\n}\n</code></pre>"},{"location":"concepts/cli-design/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Use frameworks - clap for professional CLIs</li> <li>Validate early - fail fast with clear messages</li> <li>Provide feedback - confirm successful operations</li> <li>Use semantic colors - convey meaning visually</li> <li>Handle errors gracefully - helpful error messages</li> <li>Support discovery - help and list commands</li> <li>Use aliases - improve usability</li> <li>Auto-generate help - keep documentation in sync</li> </ol> <p>\ud83d\udcda See Also:</p> <ul> <li>Error Handling - CLI error patterns</li> <li>Type Safety - Using types to prevent CLI errors</li> <li>Professional CLI - Complete clap implementation</li> </ul>"},{"location":"concepts/error-handling/","title":"Error Handling","text":"<p>\ud83d\udcda Overview:</p> <p>This page covers error handling patterns used throughout the todo-cli project, from basic string errors to professional type-safe validation.</p> <p>\ud83d\udd17 Related Versions:</p> <ul> <li>v0.1.0 - Basic <code>?</code> operator</li> <li>v0.3.0 - Input validation</li> <li>v0.4.2 - Precondition validation</li> <li>v1.6.0 - Clap error handling</li> </ul>"},{"location":"concepts/error-handling/#the-operator","title":"The <code>?</code> Operator","text":"<p>Basic error propagation:</p> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt; {\n    let content = fs::read_to_string(\"todos.json\")?;  // Auto-propagate\n    // ...\n}\n</code></pre> <p>What it does:</p> <ul> <li>If <code>Ok(value)</code> \u2192 extracts value</li> <li>If <code>Err(error)</code> \u2192 returns error from current function</li> </ul> <p>Equivalent verbose version:</p> <pre><code>let content = match fs::read_to_string(\"todos.json\") {\n    Ok(content) =&gt; content,\n    Err(e) =&gt; return Err(e.into()),\n};\n</code></pre>"},{"location":"concepts/error-handling/#boxdyn-error-for-generic-errors","title":"<code>Box&lt;dyn Error&gt;</code> for Generic Errors","text":"<p>Why use <code>Box&lt;dyn Error&gt;</code>?</p> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt; {\n    //                                    \u2191 Can hold any error type\n}\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Accepts any error type (<code>std::io::Error</code>, <code>serde_json::Error</code>, etc.)</li> <li>\u2705 No need to specify exact error type</li> <li>\u2705 Users get meaningful error messages</li> </ul> <p>Alternative approaches:</p> <pre><code>// \u274c Too specific - only works for IO errors\nfn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, std::io::Error&gt;\n\n// \u274c Too complex - need to combine all error types\nfn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, CombinedError&gt;\n\n// \u2705 Just right - accepts any error\nfn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt;\n</code></pre>"},{"location":"concepts/error-handling/#input-validation","title":"Input Validation","text":"<p>Validate user input before processing:</p> <pre><code>\"done\" =&gt; {\n    if args.len() &lt; 3 {\n        return Err(\"Usage: todo done &lt;number&gt;\".into());\n    }\n\n    let number: usize = args[2].parse()?;\n\n    if number == 0 || number &gt; tasks.len() {\n        return Err(\"Invalid task number\".into());\n    }\n\n    // ... proceed with valid input\n}\n</code></pre> <p>Validation layers:</p> <ol> <li>Argument count - Right number of arguments</li> <li>Type parsing - String \u2192 number conversion</li> <li>Range validation - Number within valid range</li> <li>State validation - Task is in correct state</li> </ol>"},{"location":"concepts/error-handling/#precondition-validation","title":"Precondition Validation","text":"<p>Check business rules before acting:</p> <pre><code>\"done\" =&gt; {\n    // ... parsing and range validation ...\n\n    let index = number - 1;\n\n    // Precondition: task must be pending\n    if tasks[index].completed {\n        return Err(\"Task is already marked as completed\".into());\n    }\n\n    // If we reach here, precondition is satisfied\n    tasks[index].mark_done();\n}\n</code></pre> <p>Why preconditions matter:</p> <ul> <li>Prevent invalid state transitions</li> <li>Provide specific, helpful error messages</li> <li>Maintain data integrity</li> </ul>"},{"location":"concepts/error-handling/#error-message-design","title":"Error Message Design","text":"<p>Good error messages:</p> <ol> <li>\u2705 Tell user what went wrong</li> <li>\u2705 Explain why it's wrong </li> <li>\u2705 Suggest how to fix it</li> </ol> <p>Examples:</p> <pre><code>// \u274c Generic and unhelpful\nreturn Err(\"Invalid input\".into());\n\n// \u2705 Specific and helpful\nreturn Err(\"Invalid task number. Use a number between 1 and 5\".into());\n\n// \u2705 Even better - shows the actual problem\nreturn Err(format!(\"Task {} doesn't exist. Available tasks: 1-5\", number).into());\n</code></pre>"},{"location":"concepts/error-handling/#clap-error-handling","title":"Clap Error Handling","text":"<p>Professional CLI errors with clap:</p> <pre><code>#[derive(Args)]\nstruct AddArgs {\n    #[arg(value_name = \"DESCRIPTION\")]\n    text: String,\n\n    #[arg(long, value_parser = clap::value_parser!(NaiveDate))]\n    due: Option&lt;NaiveDate&gt;,\n}\n</code></pre> <p>Automatic error handling:</p> <pre><code>$ todo add \"Task\" --due 2026-13-50\nerror: invalid value '2026-13-50' for '--due &lt;DATE&gt;': input is out of range\n\n$ todo add \"Task\" --due tomorrow  \nerror: invalid value 'tomorrow' for '--due &lt;DATE&gt;': premature end of input\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Context-aware errors</li> <li>\u2705 Shows expected format</li> <li>\u2705 Highlights the problematic value</li> <li>\u2705 No manual error writing needed</li> </ul>"},{"location":"concepts/error-handling/#error-recovery-strategies","title":"Error Recovery Strategies","text":"<p>Graceful degradation:</p> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt; {\n    match fs::read_to_string(\"todos.json\") {\n        Ok(content) =&gt; {\n            let tasks: Vec&lt;Task&gt; = serde_json::from_str(&amp;content)?;\n            Ok(tasks)\n        }\n        Err(_) =&gt; {\n            // File doesn't exist or can't be read\n            // Start with empty list instead of crashing\n            Ok(Vec::new())\n        }\n    }\n}\n</code></pre> <p>Idempotent operations:</p> <pre><code>\"clear\" =&gt; {\n    if fs::metadata(\"todos.json\").is_ok() {\n        fs::remove_file(\"todos.json\")?;\n        println!(\"\u2713 All tasks have been removed\");\n    } else {\n        println!(\"No tasks to remove\");  // Not an error!\n    }\n}\n</code></pre>"},{"location":"concepts/error-handling/#testing-error-cases","title":"Testing Error Cases","text":"<p>Test error conditions:</p> <pre><code>#[test]\nfn test_invalid_task_number() {\n    let mut tasks = vec![\n        Task::new(\"Task 1\".into(), Priority::Medium, vec![]),\n        Task::new(\"Task 2\".into(), Priority::Medium, vec![]),\n    ];\n\n    // Try to mark task 3 as done (only 2 exist)\n    let result = mark_done(&amp;mut tasks, 3);\n\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err().to_string(), \"Invalid task number\");\n}\n</code></pre>"},{"location":"concepts/error-handling/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Use <code>?</code> operator for simple error propagation</li> <li>Validate early - fail fast with clear messages</li> <li>Be specific - tell users exactly what's wrong</li> <li>Use types - <code>Option&lt;T&gt;</code> and <code>Result&lt;T, E&gt;</code> for safety</li> <li>Handle gracefully - don't crash on recoverable errors</li> <li>Test errors - ensure error paths work correctly</li> <li>Use frameworks - clap for CLI, serde for serialization</li> </ol> <p>\ud83d\udcda See Also:</p> <ul> <li>File Operations - File-related error handling</li> <li>CLI Design - Command-line interface patterns</li> <li>Type Safety - Using types to prevent errors</li> </ul>"},{"location":"concepts/file-operations/","title":"File Operations","text":"<p>\ud83d\udcda Overview:</p> <p>This page covers file manipulation patterns used throughout the todo-cli project, from basic text file operations to JSON serialization.</p> <p>\ud83d\udd17 Related Versions:</p> <ul> <li>v0.1.0 - Basic file writing</li> <li>v0.3.0 - File reading/writing</li> <li>v0.5.0 - File existence checks</li> <li>v1.3.0 - JSON operations</li> </ul>"},{"location":"concepts/file-operations/#basic-file-writing","title":"Basic File Writing","text":"<p>Using <code>OpenOptions</code> for controlled file creation:</p> <pre><code>use std::fs::OpenOptions;\n\n\"add\" =&gt; {\n    let task = &amp;args[2];\n    let mut file = OpenOptions::new()\n        .create(true)    // Create if doesn't exist\n        .append(true)    // Don't overwrite, add to end\n        .open(\"todos.txt\")?;\n\n    writeln!(file, \"[ ] {}\", task)?;\n}\n</code></pre> <p>Why <code>OpenOptions</code> instead of <code>File::create()</code>?</p> <pre><code>// \u274c This OVERWRITES the entire file!\nlet file = File::create(\"todos.txt\")?;\n\n// \u2705 OpenOptions gives granular control\nlet file = OpenOptions::new()\n    .create(true)    // Create if doesn't exist\n    .append(true)    // Don't overwrite, add to end\n    .open(\"todos.txt\")?;\n</code></pre>"},{"location":"concepts/file-operations/#file-reading","title":"File Reading","text":"<p>Reading entire file content:</p> <pre><code>use std::fs;\n\n\"done\" =&gt; {\n    let content = fs::read_to_string(\"todos.txt\")?;\n\n    let mut lines: Vec&lt;String&gt; = content\n        .lines()\n        .map(|l| l.to_string())\n        .collect();\n\n    // ... process lines ...\n}\n</code></pre> <p>What <code>fs::read_to_string()</code> does:</p> <ul> <li>Opens file for reading</li> <li>Reads entire content into String</li> <li>Closes file automatically</li> <li>Returns Result for error handling</li> </ul>"},{"location":"concepts/file-operations/#file-overwriting","title":"File Overwriting","text":"<p>Replacing entire file content:</p> <pre><code>use std::fs;\n\n\"done\" =&gt; {\n    // ... modify lines in memory ...\n\n    let new_content = lines.join(\"\\n\") + \"\\n\";\n    fs::write(\"todos.txt\", new_content)?;\n\n    println!(\"\u2713 Task marked as completed\");\n}\n</code></pre> <p>When to use <code>fs::write()</code>:</p> <ul> <li>Need to replace entire file</li> <li>Have modified content in memory</li> <li>File is small enough to fit in memory</li> </ul>"},{"location":"concepts/file-operations/#file-existence-checks","title":"File Existence Checks","text":"<p>Checking if file exists without opening:</p> <pre><code>use std::fs;\n\n\"clear\" =&gt; {\n    if fs::metadata(\"todos.txt\").is_ok() {\n        fs::remove_file(\"todos.txt\")?;\n        println!(\"\u2713 All tasks have been removed\");\n    } else {\n        println!(\"No tasks to remove\");\n    }\n}\n</code></pre> <p>Why use <code>fs::metadata()</code> instead of trying to delete?</p> <pre><code>// \u274c Without check - shows error to user\nfs::remove_file(\"todos.txt\")?;\n// If file doesn't exist \u2192 Error propagated to user\n// User sees: \"Error: No such file or directory\"\n\n// \u2705 With check - friendly message\nif fs::metadata(\"todos.txt\").is_ok() {\n    fs::remove_file(\"todos.txt\")?;\n    println!(\"\u2713 All tasks have been removed\");\n} else {\n    println!(\"No tasks to remove\");  // Not an error!\n}\n</code></pre>"},{"location":"concepts/file-operations/#file-deletion","title":"File Deletion","text":"<p>Removing files permanently:</p> <pre><code>use std::fs;\n\n\"clear\" =&gt; {\n    if fs::metadata(\"todos.txt\").is_ok() {\n        fs::remove_file(\"todos.txt\")?;\n        println!(\"\u2713 All tasks have been removed\");\n    }\n}\n</code></pre> <p>Important considerations:</p> <ul> <li>Permanent - no undo available</li> <li>Returns Result - can fail if no permissions</li> <li>Use with caution - always validate before deleting</li> </ul>"},{"location":"concepts/file-operations/#json-file-operations","title":"JSON File Operations","text":"<p>Reading JSON with serde:</p> <pre><code>use serde_json;\n\nfn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt; {\n    match fs::read_to_string(\"todos.json\") {\n        Ok(content) =&gt; {\n            let tasks: Vec&lt;Task&gt; = serde_json::from_str(&amp;content)?;\n            Ok(tasks)\n        }\n        Err(_) =&gt; Ok(Vec::new()),  // Missing file = empty list\n    }\n}\n</code></pre> <p>Writing JSON with serde:</p> <pre><code>fn save_tasks(tasks: &amp;[Task]) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let json = serde_json::to_string_pretty(tasks)?;\n    fs::write(\"todos.json\", json)?;\n    Ok(())\n}\n</code></pre> <p>Benefits of JSON format:</p> <ul> <li>\u2705 Standard - universal format</li> <li>\u2705 Automatic - serde handles everything</li> <li>\u2705 Validated - type checking and structure validation</li> <li>\u2705 Readable - pretty format for debugging</li> <li>\u2705 Extensible - add fields easily</li> </ul>"},{"location":"concepts/file-operations/#file-format-migration","title":"File Format Migration","text":"<p>When changing file formats:</p> <pre><code>// From custom text to JSON (v1.3.0)\nfn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt; {\n    match fs::read_to_string(\"todos.json\") {  // New file name\n        Ok(content) =&gt; {\n            let tasks: Vec&lt;Task&gt; = serde_json::from_str(&amp;content)?;\n            Ok(tasks)\n        }\n        Err(_) =&gt; Ok(Vec::new()),  // Graceful for missing file\n    }\n}\n</code></pre> <p>Migration strategies:</p> <ol> <li>Change file name - <code>todos.txt</code> \u2192 <code>todos.json</code></li> <li>Handle missing file - start with empty list</li> <li>Backward compatibility - use <code>#[serde(default)]</code> for new fields</li> </ol>"},{"location":"concepts/file-operations/#error-handling-for-file-operations","title":"Error Handling for File Operations","text":"<p>Common file errors and handling:</p> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt; {\n    match fs::read_to_string(\"todos.json\") {\n        Ok(content) =&gt; {\n            // Parse JSON\n            match serde_json::from_str::&lt;Vec&lt;Task&gt;&gt;(&amp;content) {\n                Ok(tasks) =&gt; Ok(tasks),\n                Err(e) =&gt; {\n                    // File exists but JSON is invalid\n                    Err(format!(\"Invalid JSON format: {}\", e).into())\n                }\n            }\n        }\n        Err(e) =&gt; {\n            // File doesn't exist or can't be read\n            match e.kind() {\n                std::io::ErrorKind::NotFound =&gt; {\n                    // File doesn't exist - start with empty list\n                    Ok(Vec::new())\n                }\n                _ =&gt; {\n                    // Permission denied, etc.\n                    Err(format!(\"Cannot read tasks file: {}\", e).into())\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"concepts/file-operations/#file-permissions-and-security","title":"File Permissions and Security","text":"<p>Considerations for file operations:</p> <pre><code>// Check if file is readable\nif fs::metadata(\"todos.json\")?.permissions().readonly() {\n    return Err(\"Tasks file is read-only\".into());\n}\n\n// Safe file writing (atomic operation)\nfn save_tasks_atomic(tasks: &amp;[Task]) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let json = serde_json::to_string_pretty(tasks)?;\n\n    // Write to temporary file first\n    let temp_file = \"todos.json.tmp\";\n    fs::write(temp_file, json)?;\n\n    // Rename temp file to final file (atomic on most systems)\n    fs::rename(temp_file, \"todos.json\")?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"concepts/file-operations/#performance-considerations","title":"Performance Considerations","text":"<p>When file operations become expensive:</p> <pre><code>// \u274c Bad: Read/write for every operation\n\"add\" =&gt; {\n    let tasks = load_tasks()?;  // Read all tasks\n    tasks.push(new_task);        // Add one task\n    save_tasks(&amp;tasks)?;         // Write all tasks\n}\n\n// \u2705 Good: Batch operations when possible\n\"add\" =&gt; {\n    // For single add, current approach is fine\n    // For bulk operations, consider batching\n}\n</code></pre> <p>File size considerations:</p> <ul> <li>Small files (&lt; 1MB): Load entire file into memory</li> <li>Large files (&gt; 10MB): Consider streaming or database</li> <li>Our use case: Hundreds of tasks = small file</li> </ul>"},{"location":"concepts/file-operations/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Use <code>OpenOptions</code> for controlled file creation</li> <li>Handle missing files gracefully with default values</li> <li>Validate before deleting - check existence first</li> <li>Use standard formats - JSON for structured data</li> <li>Consider atomic operations for critical writes</li> <li>Handle permissions - check if file is accessible</li> <li>Test file operations - including error cases</li> <li>Use appropriate I/O patterns - based on file size</li> </ol> <p>\ud83d\udcda See Also:</p> <ul> <li>Error Handling - File operation errors</li> <li>JSON Serialization - Serde patterns</li> <li>Type Safety - Using types to prevent file format errors</li> </ul>"},{"location":"concepts/type-safety/","title":"Type Safety","text":"<p>\ud83d\udcda Overview:</p> <p>This page covers type safety patterns used throughout the todo-cli project, from basic string handling to advanced type-safe enums and structs.</p> <p>\ud83d\udd17 Related Versions:</p> <ul> <li>v1.2.0 - Structs and enums</li> <li>v1.3.0 - Serde type safety</li> <li>v1.6.0 - Clap type safety</li> </ul>"},{"location":"concepts/type-safety/#string-vs-enum-types","title":"String vs Enum Types","text":""},{"location":"concepts/type-safety/#string-based-approach-early-versions","title":"String-Based Approach (Early Versions)","text":"<p>Error-prone string matching:</p> <pre><code>// \u274c Can have typos that compile\nlet priority = \"hihg\";  // Typo! Compiles fine\nif priority == \"high\" { }  // Won't match, silent bug\n\n// \u274c No exhaustiveness checking\nmatch priority.as_str() {\n    \"high\" =&gt; \"\ud83d\udd34\",\n    \"medium\" =&gt; \"\ud83d\udfe1\",\n    // Forgot \"low\"? \u274c No compiler error\n    _ =&gt; \"\u2753\",  // Catch-all needed\n}\n</code></pre>"},{"location":"concepts/type-safety/#enum-based-approach-mature-versions","title":"Enum-Based Approach (Mature Versions)","text":"<p>Type-safe with compile-time checking:</p> <pre><code>#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nenum Priority {\n    High,\n    Medium,\n    Low,\n}\n\n// \u2705 Typos = compile error\nlet priority = Priority::Hihg;  // ERROR: no variant `Hihg`\n\n// \u2705 Exhaustive matching enforced\nmatch priority {\n    Priority::High =&gt; \"\ud83d\udd34\",\n    Priority::Medium =&gt; \"\ud83d\udfe1\",\n    Priority::Low =&gt; \"\ud83d\udfe2\",\n    // Can't forget any variant - compiler error!\n}\n</code></pre>"},{"location":"concepts/type-safety/#when-to-use-strings-vs-enums","title":"When to Use Strings vs Enums","text":""},{"location":"concepts/type-safety/#use-strings-when","title":"Use Strings When:","text":"<ul> <li>User-provided data: Task text, descriptions</li> <li>Open-ended values: Free-form input</li> <li>Display purposes: Formatting for output</li> <li>Simple prototypes: Quick development phase</li> </ul>"},{"location":"concepts/type-safety/#use-enums-when","title":"Use Enums When:","text":"<ul> <li>Fixed set of values: Priorities, statuses, filters</li> <li>Need compile-time validation: Prevent invalid states</li> <li>Want exhaustive matching: Handle all cases</li> <li>Values are fundamental to domain: Core business concepts</li> </ul> <p>Our evolution:</p> <pre><code>// v0.1-v1.1: Strings for everything (learning)\n// v1.2+: Enums for priority, strings for task text (mature)\n</code></pre>"},{"location":"concepts/type-safety/#option-type-for-optional-values","title":"Option Type for Optional Values","text":""},{"location":"concepts/type-safety/#avoiding-magic-values","title":"Avoiding \"Magic Values\"","text":"<p>\u274c Using special values:</p> <pre><code>struct Task {\n    text: String,\n    completed: bool,\n    priority: String,  // \"\" could mean \"no priority\" or \"medium\"\n    due_date: String,  // \"\" could mean \"no due date\"\n}\n</code></pre> <p>\u2705 Using Option for clarity:</p> <pre><code>struct Task {\n    text: String,\n    completed: bool,\n    priority: Priority,  // Always has a priority\n    due_date: Option&lt;NaiveDate&gt;,  // None = no due date\n}\n</code></pre>"},{"location":"concepts/type-safety/#pattern-matching-on-option","title":"Pattern Matching on Option","text":"<p>Safe handling of optional values:</p> <pre><code>fn is_overdue(&amp;self) -&gt; bool {\n    if let Some(due) = self.due_date {\n        let today = Local::now().naive_local().date();\n        due &lt; today &amp;&amp; !self.completed\n    } else {\n        false  // No due date = can't be overdue\n    }\n}\n</code></pre> <p>Alternative with <code>map</code>:</p> <pre><code>fn days_until_due(&amp;self) -&gt; Option&lt;i64&gt; {\n    self.due_date.map(|due| {\n        let today = Local::now().naive_local().date();\n        (due - today).num_days()\n    })\n}\n</code></pre>"},{"location":"concepts/type-safety/#result-type-for-error-handling","title":"Result Type for Error Handling","text":""},{"location":"concepts/type-safety/#type-safe-error-propagation","title":"Type-Safe Error Propagation","text":"<p>Using Result for operations that can fail:</p> <pre><code>fn load_tasks() -&gt; Result&lt;Vec&lt;Task&gt;, Box&lt;dyn Error&gt;&gt; {\n    match fs::read_to_string(\"todos.json\") {\n        Ok(content) =&gt; {\n            let tasks: Vec&lt;Task&gt; = serde_json::from_str(&amp;content)?;\n            Ok(tasks)\n        }\n        Err(_) =&gt; Ok(Vec::new()),\n    }\n}\n</code></pre> <p>Chaining operations with <code>?</code>:</p> <pre><code>fn save_tasks(tasks: &amp;[Task]) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let json = serde_json::to_string_pretty(tasks)?;\n    fs::write(\"todos.json\", json)?;\n    Ok(())\n}\n</code></pre>"},{"location":"concepts/type-safety/#struct-based-data-organization","title":"Struct-Based Data Organization","text":""},{"location":"concepts/type-safety/#grouping-related-data","title":"Grouping Related Data","text":"<p>Before - scattered variables:</p> <pre><code>fn display_task(number: usize, text: &amp;str, completed: bool, priority: &amp;str) {\n    // Hard to pass around, easy to mix up parameters\n}\n</code></pre> <p>After - organized struct:</p> <pre><code>#[derive(Debug, Clone)]\nstruct Task {\n    text: String,\n    completed: bool,\n    priority: Priority,\n    due_date: Option&lt;NaiveDate&gt;,\n    tags: Vec&lt;String&gt;,\n}\n\nfn display_task(number: usize, task: &amp;Task) {\n    // Clear data organization, type-safe access\n    if task.completed {\n        println!(\"\u2713 {}\", task.text);\n    }\n}\n</code></pre>"},{"location":"concepts/type-safety/#method-encapsulation","title":"Method Encapsulation","text":"<p>Business logic on types:</p> <pre><code>impl Task {\n    // Constructor - ensures valid initial state\n    fn new(text: String, priority: Priority, tags: Vec&lt;String&gt;, \n            due_date: Option&lt;NaiveDate&gt;) -&gt; Self {\n        Self {\n            text,\n            completed: false,  // Always starts incomplete\n            priority,\n            tags,\n            due_date,\n            created_at: Local::now().naive_local().date(),\n        }\n    }\n\n    // State transitions - type-safe operations\n    fn mark_done(&amp;mut self) {\n        self.completed = true;\n    }\n\n    fn mark_undone(&amp;mut self) {\n        self.completed = false;\n    }\n\n    // Queries - clear return types\n    fn is_overdue(&amp;self) -&gt; bool {\n        if let Some(due) = self.due_date {\n            let today = Local::now().naive_local().date();\n            due &lt; today &amp;&amp; !self.completed\n        } else {\n            false\n        }\n    }\n}\n</code></pre>"},{"location":"concepts/type-safety/#serde-type-safety","title":"Serde Type Safety","text":""},{"location":"concepts/type-safety/#automatic-serialization-validation","title":"Automatic Serialization Validation","text":"<p>Type-safe JSON operations:</p> <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Task {\n    text: String,\n    completed: bool,\n    priority: Priority,\n    tags: Vec&lt;String&gt;,\n    due_date: Option&lt;NaiveDate&gt;,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\nenum Priority {\n    High,\n    Medium,\n    Low,\n}\n</code></pre> <p>What serde provides automatically:</p> <ol> <li>Structure validation - JSON must match struct fields</li> <li>Type validation - \"completed\" must be boolean</li> <li>Enum validation - \"priority\" must be valid variant</li> <li>Optional field handling - <code>Option&lt;T&gt;</code> fields can be missing</li> </ol> <p>Error examples:</p> <pre><code>// \u274c Missing required field\n{\n  \"text\": \"Task\",\n  \"completed\": false\n  // Missing \"priority\"\n}\n// Error: missing field `priority`\n\n// \u274c Wrong type\n{\n  \"text\": \"Task\",\n  \"completed\": \"yes\",  // Should be boolean\n  \"priority\": \"High\"\n}\n// Error: invalid type: string \"yes\", expected boolean\n\n// \u274c Invalid enum value\n{\n  \"text\": \"Task\",\n  \"completed\": false,\n  \"priority\": \"urgent\"  // Not a valid variant\n}\n// Error: unknown variant `urgent`, expected one of `High`, `Medium`, `Low`\n</code></pre>"},{"location":"concepts/type-safety/#clap-type-safety","title":"Clap Type Safety","text":""},{"location":"concepts/type-safety/#type-safe-cli-parsing","title":"Type-Safe CLI Parsing","text":"<p>ValueEnum for CLI values:</p> <pre><code>#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]\nenum StatusFilter {\n    /// Show only pending tasks\n    Pending,\n    /// Show only completed tasks\n    Done,\n    /// Show all tasks (default)\n    All,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]\nenum DueFilter {\n    /// Tasks past their due date\n    Overdue,\n    /// Tasks due in the next 7 days\n    Soon,\n    /// Tasks with any due date set\n    WithDue,\n    /// Tasks without a due date\n    NoDue,\n}\n</code></pre> <p>Usage in CLI:</p> <pre><code>List {\n    #[arg(long, value_enum, default_value_t = StatusFilter::All)]\n    status: StatusFilter,\n\n    #[arg(long, value_enum)]\n    due: Option&lt;DueFilter&gt;,\n}\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Compile-time safety - invalid values rejected</li> <li>\u2705 Auto-completion - shell knows valid values</li> <li>\u2705 Help generation - values shown in help</li> <li>\u2705 Mutual exclusion - <code>Option&lt;DueFilter&gt;</code> prevents conflicts</li> </ul>"},{"location":"concepts/type-safety/#custom-type-parsers","title":"Custom Type Parsers","text":"<p>Automatic type parsing with value_parser:</p> <pre><code>#[derive(Args)]\nstruct AddArgs {\n    #[arg(long, value_parser = clap::value_parser!(NaiveDate))]\n    due: Option&lt;NaiveDate&gt;,\n}\n</code></pre> <p>How it works:</p> <ol> <li>Clap takes string from CLI</li> <li>Calls <code>NaiveDate::from_str()</code></li> <li>Returns parsed value or error</li> <li>Error includes context and suggestions</li> </ol> <p>Error example:</p> <pre><code>$ todo add \"Task\" --due 2026-13-50\nerror: invalid value '2026-13-50' for '--due &lt;DATE&gt;': input is out of range\n</code></pre>"},{"location":"concepts/type-safety/#type-safety-benefits","title":"Type Safety Benefits","text":""},{"location":"concepts/type-safety/#compile-time-error-prevention","title":"Compile-Time Error Prevention","text":"<p>Strings allow runtime errors:</p> <pre><code>// This compiles but fails at runtime\nlet priority = \"hihg\";  // Typo\nif priority == \"high\" { }  // Silent bug\n</code></pre> <p>Enums prevent runtime errors:</p> <pre><code>// This doesn't compile - catches bug immediately\nlet priority = Priority::Hihg;  // Compile error!\n</code></pre>"},{"location":"concepts/type-safety/#self-documenting-code","title":"Self-Documenting Code","text":"<p>Strings require external knowledge:</p> <pre><code>// What values are valid? Need to read source code\nlet status = \"pending\";  // Is this valid? Who knows\n</code></pre> <p>Enums are self-documenting:</p> <pre><code>// IDE shows all valid options\nlet status = StatusFilter::Pending;  // Only valid values possible\n</code></pre>"},{"location":"concepts/type-safety/#refactoring-safety","title":"Refactoring Safety","text":"<p>Changing string values is risky:</p> <pre><code>// Change \"high\" to \"critical\"?\n// Must search entire codebase for \"high\"\n// Easy to miss some occurrences\nif priority == \"high\" { }  // Might miss this one\n</code></pre> <p>Changing enum values is safe:</p> <pre><code>// Rename High to Critical?\n// Compiler finds all occurrences automatically\nif priority == Priority::High { }  // Compile error forces update\n</code></pre>"},{"location":"concepts/type-safety/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Use enums for fixed domains - priorities, statuses, filters</li> <li>Use Option for optional data - due dates, optional fields</li> <li>Use Result for fallible operations - file I/O, parsing</li> <li>Group related data in structs - clear organization</li> <li>Use method encapsulation - business logic on types</li> <li>Leverage serde for serialization - automatic validation</li> <li>Use clap for CLI type safety - ValueEnum patterns</li> <li>Prefer compile-time checks over runtime validation</li> </ol> <p>\ud83d\udcda See Also:</p> <ul> <li>Struct Refactoring - Complete type safety migration</li> <li>JSON Serialization - Serde type patterns</li> <li>Professional CLI - Clap type safety</li> </ul>"},{"location":"getting-started/v0.1.0-basic-cli/","title":"v0.1.0 - Basic CLI","text":"<p>\ud83c\udfaf Goal: Create the foundation of a CLI with add/list functionality</p> <p>\ud83d\udce6 Implementation:</p> <pre><code>\"add\" =&gt; {\n    let task = &amp;args[2];\n    let mut file = OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(\"todos.txt\")?;\n    writeln!(file, \"[ ] {}\", task)?;\n}\n</code></pre> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"getting-started/v0.1.0-basic-cli/#why-openoptions-instead-of-filecreate","title":"Why <code>OpenOptions</code> instead of <code>File::create()</code>?","text":"<pre><code>// \u274c This OVERWRITES the entire file!\nlet file = File::create(\"todos.txt\")?;\n\n// \u2705 OpenOptions gives granular control\nlet file = OpenOptions::new()\n    .create(true)    // Create if doesn't exist\n    .append(true)    // Don't overwrite, add to end\n    .open(\"todos.txt\")?;\n</code></pre>"},{"location":"getting-started/v0.1.0-basic-cli/#the-operator","title":"The <code>?</code> operator","text":"<pre><code>let file = open_file()?;  // Automatically propagates error\n</code></pre> <p>Equivalent verbose version:</p> <pre><code>let file = match open_file() {\n    Ok(f) =&gt; f,\n    Err(e) =&gt; return Err(e.into()),\n};\n</code></pre> <p>Why <code>?</code> is better:</p> <ul> <li>Less code</li> <li>Clear intention</li> <li>Idiomatic Rust</li> </ul>"},{"location":"getting-started/v0.1.0-basic-cli/#pattern-matching-for-subcommands","title":"Pattern matching for subcommands","text":"<pre><code>match args[1].as_str() {\n    \"add\" =&gt; { /* ... */ }\n    \"list\" =&gt; { /* ... */ }\n    _ =&gt; { eprintln!(\"Unknown command\"); }\n}\n</code></pre> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v0.1.0</li> <li>Full diff</li> </ul>"},{"location":"getting-started/v0.2.0-done-command/","title":"v0.2.0 - Done Command","text":"<p>\ud83c\udfaf Goal: Mark tasks as completed</p> <p>\ud83d\udce6 Implementation:</p> <pre><code>\"done\" =&gt; {\n    if args.len() &lt; 3 {\n        return Err(\"Usage: todo done &lt;number&gt;\".into());\n    }\n\n    let number: usize = args[2].parse()?;\n    let content = fs::read_to_string(\"todos.txt\")?;\n\n    let mut lines: Vec&lt;String&gt; = content\n        .lines()\n        .map(|l| l.to_string())\n        .collect();\n\n    let index = number - 1;\n    lines[index] = lines[index].replace(\"[ ]\", \"[x]\");\n\n    fs::write(\"todos.txt\", lines.join(\"\\n\") + \"\\n\")?;\n    println!(\"\u2713 Task marked as completed\");\n}\n</code></pre> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"getting-started/v0.2.0-done-command/#mapcollect-pattern","title":"<code>.map().collect()</code> pattern","text":"<pre><code>let mut lines: Vec&lt;String&gt; = content\n    .lines()           // Iterator of &amp;str\n    .map(|l| l.to_string())  // Transform each &amp;str \u2192 String\n    .collect();        // Gather into Vec&lt;String&gt;\n</code></pre> <p>This is the iterator pattern - lazy evaluation until <code>collect()</code>.</p> <p>Why this pattern?</p> <ul> <li><code>.lines()</code> returns an iterator (doesn't allocate yet)</li> <li><code>.map()</code> transforms each item (still lazy)</li> <li><code>.collect()</code> forces evaluation and builds the Vec</li> </ul>"},{"location":"getting-started/v0.2.0-done-command/#why-to_string-is-needed","title":"Why <code>.to_string()</code> is needed","text":"<pre><code>content.lines()  // Returns Iterator&lt;Item = &amp;str&gt;\n</code></pre> <p>Each line is a borrowed reference (<code>&amp;str</code>) to data in <code>content</code>. We need owned <code>String</code> values so we can:</p> <ol> <li>Modify them (<code>.replace()</code>)</li> <li>Store them in a Vec that outlives <code>content</code></li> </ol> <pre><code>.map(|l| l.to_string())  // Converts &amp;str \u2192 String (owned)\n</code></pre>"},{"location":"getting-started/v0.2.0-done-command/#parsing-user-input","title":"Parsing user input","text":"<pre><code>let number: usize = args[2].parse()?;\n</code></pre> <p>What's happening:</p> <ul> <li><code>args[2]</code> is a <code>String</code> (e.g., <code>\"3\"</code>)</li> <li><code>.parse()</code> tries to convert it to <code>usize</code></li> <li><code>:usize</code> type annotation tells <code>parse()</code> what to produce</li> <li><code>?</code> propagates error if user typed invalid number</li> </ul> <p>Error handling:</p> <pre><code>// If user types \"abc\"\nargs[2].parse()?  // Returns Err \u2192 propagated to main\n// User sees: \"Error: invalid digit found in string\"\n</code></pre>"},{"location":"getting-started/v0.2.0-done-command/#index-conversion-1-based-0-based","title":"Index conversion: 1-based \u2192 0-based","text":"<pre><code>let number: usize = args[2].parse()?;  // User sees: 1, 2, 3...\nlet index = number - 1;                 // Vec uses: 0, 1, 2...\nlines[index] = lines[index].replace(\"[ ]\", \"[x]\");\n</code></pre> <p>Why this matters:</p> <ul> <li>Users think in 1-based numbers (1<sup>st</sup> task, 2<sup>nd</sup> task)</li> <li>Rust Vecs are 0-indexed</li> <li>Must convert to avoid off-by-one errors</li> </ul>"},{"location":"getting-started/v0.2.0-done-command/#writing-back-to-file","title":"Writing back to file","text":"<pre><code>fs::write(\"todos.txt\", lines.join(\"\\n\") + \"\\n\")?;\n</code></pre> <p>Breaking it down:</p> <ul> <li><code>lines.join(\"\\n\")</code> - combines Vec elements with newlines between</li> <li><code>+ \"\\n\"</code> - adds final newline at end of file</li> <li><code>fs::write()</code> - overwrites entire file with new content</li> </ul> <p>Why overwrite instead of append?</p> <ul> <li>Can't \"edit middle\" of file efficiently</li> <li>Must read entire file, modify in memory, write back</li> <li>This is fine for small files (hundreds of tasks)</li> </ul>"},{"location":"getting-started/v0.2.0-done-command/#the-replace-method","title":"The <code>.replace()</code> method","text":"<pre><code>lines[index] = lines[index].replace(\"[ ]\", \"[x]\");\n</code></pre> <p>What it does:</p> <ul> <li>Finds first occurrence of <code>\"[ ]\"</code></li> <li>Replaces it with <code>\"[x]\"</code></li> <li>Returns a new String (doesn't modify original)</li> </ul> <p>Example:</p> <pre><code>let task = \"[ ] Buy milk\";\nlet done = task.replace(\"[ ]\", \"[x]\");\n// done = \"[x] Buy milk\"\n// task is unchanged (because String is immutable)\n</code></pre> <p>Limitations not handled yet:</p> <ul> <li>\u274c No validation if index is out of bounds</li> <li>\u274c No check if task is already done</li> <li>\u274c Empty file would panic</li> </ul> <p>These will be fixed in v0.3.0 and v0.4.2</p> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v0.2.0</li> <li>Full diff</li> </ul>"},{"location":"getting-started/v0.3.0-remove-command/","title":"v0.3.0 - Remove Command","text":"<p>\ud83c\udfaf Goal: Delete specific tasks</p> <p>\ud83d\udce6 Implementation:</p> <pre><code>\"remove\" =&gt; {\n    if args.len() &lt; 3 {\n        return Err(\"Usage: todo remove &lt;number&gt;\".into());\n    }\n\n    let number: usize = args[2].parse()?;\n    let content = fs::read_to_string(\"todos.txt\")?;\n    let mut lines: Vec&lt;String&gt; = content.lines().map(|l| l.to_string()).collect();\n\n    if number == 0 || number &gt; lines.len() {\n        return Err(\"Invalid task number\".into());\n    }\n\n    let index = number - 1;\n    lines.remove(index);\n\n    fs::write(\"todos.txt\", lines.join(\"\\n\") + \"\\n\")?;\n    println!(\"\u2713 Task removed\");\n}\n</code></pre> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"getting-started/v0.3.0-remove-command/#index-validation","title":"Index validation","text":"<pre><code>if number == 0 || number &gt; lines.len() {\n    return Err(\"Invalid task number\".into());\n}\n</code></pre> <p>Why this validation is critical:</p> <p>Case 1: Zero index</p> <pre><code>// User types: todo remove 0\nnumber == 0  // Invalid! Users see tasks numbered 1, 2, 3...\n</code></pre> <p>Case 2: Out of bounds</p> <pre><code>// File has 5 tasks, user types: todo remove 10\nnumber &gt; lines.len()  // Would panic at lines.remove(9)\n</code></pre> <p>Without validation:</p> <pre><code>lines.remove(9)  // panics: \"index out of bounds\"\n// User sees: \"thread 'main' panicked at...\" \u274c Bad UX\n</code></pre> <p>With validation:</p> <pre><code>return Err(\"Invalid task number\".into());\n// User sees: \"Error: Invalid task number\" \u2705 Clear message\n</code></pre>"},{"location":"getting-started/v0.3.0-remove-command/#vecremove-method","title":"<code>Vec::remove()</code> method","text":"<pre><code>lines.remove(index);\n</code></pre> <p>What it does:</p> <ul> <li>Removes element at index <code>index</code></li> <li>Shifts all following elements left</li> <li>Reduces Vec length by 1</li> </ul> <p>Example:</p> <pre><code>let mut tasks = vec![\"Task 1\", \"Task 2\", \"Task 3\", \"Task 4\"];\ntasks.remove(1);  // Remove \"Task 2\"\n// Result: [\"Task 1\", \"Task 3\", \"Task 4\"]\n//                     \u2191 shifted left\n</code></pre> <p>Performance note:</p> <ul> <li>O(n) operation - must shift all elements after removed index</li> <li>For small lists (hundreds of tasks), this is fine</li> <li>For large lists (thousands), might need different data structure</li> </ul>"},{"location":"getting-started/v0.3.0-remove-command/#comparison-remove-vs-replace","title":"Comparison: <code>remove()</code> vs <code>replace()</code>","text":"<pre><code>// done command (v0.2.0) - modifies content\nlines[index] = lines[index].replace(\"[ ]\", \"[x]\");\n\n// remove command (v0.3.0) - deletes entire element\nlines.remove(index);\n</code></pre> <p>Key difference:</p> <ul> <li><code>replace()</code> - task still exists, just changed</li> <li><code>remove()</code> - task is gone, indices shift</li> </ul> <p>This affects user experience:</p> <pre><code>Before remove(1):        After remove(1):\n1. Task A                1. Task B  \u2190 was 2, now 1\n2. Task B                2. Task C  \u2190 was 3, now 2\n3. Task C\n</code></pre> <p>Users need to <code>list</code> again to see new numbers.</p>"},{"location":"getting-started/v0.3.0-remove-command/#validation-added-to-done-command","title":"Validation added to <code>done</code> command","text":"<p>Notice the improvement in v0.3.0:</p> <pre><code>\"done\" =&gt; {\n    // ... parsing ...\n\n    // \u2705 NEW: Validation added!\n    if number == 0 || number &gt; lines.len() {\n        return Err(\"Invalid task number\".into());\n    }\n\n    let index = number - 1;\n    lines[index] = lines[index].replace(\"[ ]\", \"[x]\");\n    // ...\n}\n</code></pre> <p>Before v0.3.0: <code>done</code> command could panic on invalid index After v0.3.0: Both <code>done</code> and <code>remove</code> have proper validation</p> <p>This is iterative improvement - recognizing a pattern (validation) and applying it consistently.</p> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v0.3.0</li> <li>Full diff</li> </ul>"},{"location":"getting-started/v0.4.0-undone-command/","title":"v0.4.0 - Undone Command","text":"<p>\ud83c\udfaf Goal: Unmark completed tasks (reverse of <code>done</code>)</p> <p>\ud83d\udce6 Implementation:</p> <pre><code>\"undone\" =&gt; {\n    if args.len() &lt; 3 {\n        return Err(\"Usage: todo undone &lt;number&gt;\".into());\n    }\n\n    let number: usize = args[2].parse()?;\n    let content = fs::read_to_string(\"todos.txt\")?;\n    let mut lines: Vec&lt;String&gt; = content.lines().map(|l| l.to_string()).collect();\n\n    if number == 0 || number &gt; lines.len() {\n        return Err(\"Invalid task number\".into());\n    }\n\n    let index = number - 1;\n    lines[index] = lines[index].replace(\"[x]\", \"[ ]\");  // \u2190 Reverse!\n\n    fs::write(\"todos.txt\", lines.join(\"\\n\") + \"\\n\")?;\n    println!(\"\u2713 Task unmarked\");\n}\n</code></pre> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"getting-started/v0.4.0-undone-command/#inverse-operations","title":"Inverse operations","text":"<pre><code>// done: marks as completed\nlines[index].replace(\"[ ]\", \"[x]\")\n\n// undone: marks as pending  \nlines[index].replace(\"[x]\", \"[ ]\")\n</code></pre> <p>This is the power of simple data representation:</p> <ul> <li>State is just text: <code>\"[ ]\"</code> or <code>\"[x]\"</code></li> <li>Changing state is just string replacement</li> <li>Inverse operation is trivial</li> </ul> <p>Alternative design (that would be more complex):</p> <pre><code>// If we had stored status separately:\nstruct Task {\n    text: String,\n    completed: bool,  // Now we need struct, serialization, etc.\n}\n</code></pre> <p>Our choice: Keep it simple - plain text format enables easy state changes.</p>"},{"location":"getting-started/v0.4.0-undone-command/#code-duplication-notice","title":"Code duplication notice","text":"<p>Look at the pattern:</p> <pre><code>// done, undone, and remove all have:\nif args.len() &lt; 3 { return Err(...); }\nlet number: usize = args[2].parse()?;\nlet content = fs::read_to_string(\"todos.txt\")?;\nlet mut lines: Vec&lt;String&gt; = content.lines().map(|l| l.to_string()).collect();\nif number == 0 || number &gt; lines.len() { return Err(...); }\nlet index = number - 1;\n// ... specific operation ...\nfs::write(\"todos.txt\", lines.join(\"\\n\") + \"\\n\")?;\n</code></pre> <p>This duplication is intentional at this stage:</p> <ul> <li>\u2705 Learning step-by-step</li> <li>\u2705 Each command is self-contained</li> <li>\u2705 Easy to understand</li> </ul> <p>Later (v1.0.0+), this will be refactored into helper functions. For now, repetition helps learning.</p>"},{"location":"getting-started/v0.4.0-undone-command/#boolean-logic-in-action","title":"Boolean logic in action","text":"<p>The command structure now forms a state machine:</p> <pre><code>      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 Pending \u2502\n      \u2502  [ ]    \u2502\n      \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n           \u2502\n     done   \u2502   undone\n     \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n           \u2502\n      \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n      \u2502Completed\u2502\n      \u2502  [x]    \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Tasks can toggle between states, and <code>remove</code> deletes from any state.</p> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v0.4.0</li> <li>Full diff</li> </ul>"},{"location":"getting-started/v0.4.1-list-bug-fix/","title":"v0.4.1 - List Bug Fix","text":"<p>\ud83c\udfaf Goal: Handle empty lines properly in the list command</p> <p>\ud83d\udce6 The Bug:</p> <p>Before v0.4.1:</p> <pre><code>\"list\" =&gt; match fs::read_to_string(\"todos.txt\") {\n    Ok(content) =&gt; {\n        for (i, line) in content.lines().enumerate() {\n            println!(\"{}. {}\", i + 1, line);  // Shows empty lines!\n        }\n    }\n    // ...\n}\n</code></pre> <p>Problem:</p> <pre><code>File content:          Display output:\n[ ] Task 1             1. [ ] Task 1\n                       2.              \u2190 Empty line!\n[ ] Task 2             3. [ ] Task 2\n</code></pre> <p>After v0.4.1:</p> <pre><code>\"list\" =&gt; match fs::read_to_string(\"todos.txt\") {\n    Ok(content) =&gt; {\n        let valid_lines: Vec&lt;&amp;str&gt; = content\n            .lines()\n            .filter(|l| !l.trim().is_empty())  // \u2190 The fix!\n            .collect();\n\n        if valid_lines.is_empty() {\n            println!(\"No tasks\");\n        } else {\n            for (i, line) in valid_lines.iter().enumerate() {\n                println!(\"{}. {}\", i + 1, line);\n            }\n        }\n    }\n    Err(_) =&gt; {\n        println!(\"No tasks\");\n    }\n}\n</code></pre> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"getting-started/v0.4.1-list-bug-fix/#why-trim-is-necessary","title":"Why <code>.trim()</code> is necessary","text":"<p>Where do empty lines come from?</p> <pre><code>// When we write file:\nfs::write(\"todos.txt\", lines.join(\"\\n\") + \"\\n\")?;\n//                                          \u2191 adds final newline\n\n// File content:\n\"[ ] Task 1\\n[ ] Task 2\\n\"\n//                      \u2191 this creates an empty line when splitting\n</code></pre> <p>Without trim:</p> <pre><code>\"[ ] Task 1\\n[ ] Task 2\\n\".lines()\n// Results in: [\"[ ] Task 1\", \"[ ] Task 2\", \"\"]\n//                                            \u2191 empty string!\n</code></pre> <p>With trim:</p> <pre><code>.filter(|l| !l.trim().is_empty())\n// \"\".trim() = \"\" (still empty) \u2192 filtered out\n// \"   \".trim() = \"\" \u2192 also filtered out (whitespace-only lines)\n</code></pre>"},{"location":"getting-started/v0.4.1-list-bug-fix/#the-filter-method","title":"The <code>.filter()</code> method","text":"<pre><code>content.lines()\n    .filter(|l| !l.trim().is_empty())\n    .collect()\n</code></pre> <p>How it works:</p> <ul> <li>Takes each line from iterator</li> <li>Applies predicate: <code>!l.trim().is_empty()</code></li> <li>Keeps only lines where predicate is <code>true</code></li> </ul> <p>Example:</p> <pre><code>let lines = vec![\"Task 1\", \"\", \"  \", \"Task 2\"];\nlet valid: Vec&lt;_&gt; = lines.iter()\n    .filter(|l| !l.trim().is_empty())\n    .collect();\n// Result: [\"Task 1\", \"Task 2\"]\n</code></pre>"},{"location":"getting-started/v0.4.1-list-bug-fix/#improved-empty-file-handling","title":"Improved empty file handling","text":"<p>Also added check for empty list:</p> <pre><code>if valid_lines.is_empty() {\n    println!(\"No tasks\");\n} else {\n    // display tasks\n}\n</code></pre> <p>Why this matters:</p> <ul> <li>File exists but has only empty lines</li> <li>Better UX than showing nothing</li> </ul>"},{"location":"getting-started/v0.4.1-list-bug-fix/#edge-cases-now-handled","title":"Edge cases now handled","text":"<p>\u2705 Empty file \u2705 File with only whitespace \u2705 File with trailing newlines \u2705 File with blank lines between tasks  </p> <p>Bug lesson: Always test with \"weird\" input (empty files, extra newlines, whitespace).</p> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v0.4.1</li> <li>Full diff</li> </ul>"},{"location":"getting-started/v0.4.2-state-validations/","title":"v0.4.2 - State Validations","text":"<p>\ud83c\udfaf Goal: Prevent invalid state transitions with specific error messages</p> <p>\ud83d\udce6 Implementation:</p> <p>Validation in <code>done</code> command:</p> <pre><code>\"done\" =&gt; {\n    // ... parsing and validation ...\n\n    let index = number - 1;\n\n    // \u2705 NEW: Check if already completed\n    if lines[index].contains(\"[x]\") {\n        return Err(\"Task is already marked as completed\".into());\n    }\n\n    lines[index] = lines[index].replace(\"[ ]\", \"[x]\");\n    // ...\n}\n</code></pre> <p>Validation in <code>undone</code> command:</p> <pre><code>\"undone\" =&gt; {\n    // ... parsing and validation ...\n\n    let index = number - 1;\n\n    // \u2705 NEW: Check if already pending\n    if lines[index].contains(\"[ ]\") {\n        return Err(\"Task is already unmarked\".into());\n    }\n\n    lines[index] = lines[index].replace(\"[x]\", \"[ ]\");\n    // ...\n}\n</code></pre> <p>Improved error message in <code>remove</code>:</p> <pre><code>\"remove\" =&gt; {\n    // ...\n    if number == 0 || number &gt; lines.len() {\n        // \u2705 More specific message\n        return Err(\"This task doesn't exist or was already removed\".into());\n    }\n    // ...\n}\n</code></pre> <p>Consistent filtering in all commands:</p> <pre><code>// done, undone, and remove now all filter empty lines\nlet mut lines: Vec&lt;String&gt; = content\n    .lines()\n    .filter(|l| !l.trim().is_empty())  // \u2190 Applied everywhere\n    .map(|l| l.to_string())\n    .collect();\n</code></pre> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"getting-started/v0.4.2-state-validations/#precondition-validation","title":"Precondition validation","text":"<p>What are preconditions?</p> <ul> <li>Conditions that must be true before an operation</li> <li>Checked before performing the action</li> <li>Prevent invalid state transitions</li> </ul> <p>Example:</p> <pre><code>// Precondition: task must be pending ([ ])\nif lines[index].contains(\"[x]\") {\n    return Err(\"Task is already marked as completed\".into());\n}\n// If we reach here, precondition is satisfied\nlines[index] = lines[index].replace(\"[ ]\", \"[x]\");\n</code></pre>"},{"location":"getting-started/v0.4.2-state-validations/#specific-vs-generic-error-messages","title":"Specific vs generic error messages","text":"<p>Before v0.4.2:</p> <pre><code>// Generic - doesn't tell user what's wrong\nif number &gt; lines.len() {\n    return Err(\"Invalid task number\".into());\n}\n</code></pre> <p>After v0.4.2:</p> <pre><code>// Specific - explains the actual problem\nif lines[index].contains(\"[x]\") {\n    return Err(\"Task is already marked as completed\".into());\n}\n</code></pre> <p>Why this matters:</p> <p>User experience comparison:</p> <pre><code># Generic error\n$ todo done 1\nError: Invalid task number\n# User thinks: \"But 1 is valid! What's wrong?\"\n\n# Specific error  \n$ todo done 1\nError: Task is already marked as completed\n# User thinks: \"Oh, I already did this one!\"\n</code></pre> <p>Good error messages:</p> <ol> <li>\u2705 Tell user what went wrong</li> <li>\u2705 Explain why it's wrong</li> <li>\u2705 (Ideally) Suggest how to fix it</li> </ol>"},{"location":"getting-started/v0.4.2-state-validations/#state-machine-enforcement","title":"State machine enforcement","text":"<p>Valid transitions:</p> <pre><code>[ ] \u2500\u2500done\u2500\u2500&gt; [x]\n[x] \u2500\u2500undone\u2500\u2500&gt; [ ]\n</code></pre> <p>Invalid transitions (now prevented):</p> <pre><code>[x] \u2500\u2500done\u2500\u2500&gt; [x]  \u274c \"Task is already marked as completed\"\n[ ] \u2500\u2500undone\u2500\u2500&gt; [ ]  \u274c \"Task is already unmarked\"\n</code></pre> <p>This is defensive programming:</p> <ul> <li>Assume user will make mistakes</li> <li>Validate before acting</li> <li>Provide helpful feedback</li> </ul>"},{"location":"getting-started/v0.4.2-state-validations/#consistency-across-commands","title":"Consistency across commands","text":"<p>Pattern established:</p> <p>All mutation commands now follow:</p> <ol> <li>Parse arguments</li> <li>Validate arguments (bounds)</li> <li>Read file with empty line filtering</li> <li>Validate preconditions (state)</li> <li>Perform operation</li> <li>Write file</li> <li>Confirm to user</li> </ol> <p>This consistency:</p> <ul> <li>\u2705 Makes code predictable</li> <li>\u2705 Easier to maintain</li> <li>\u2705 Easier to add new commands</li> </ul> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v0.4.2</li> <li>Full diff</li> </ul>"},{"location":"getting-started/v0.5.0-clear-command/","title":"v0.5.0 - Clear Command","text":"<p>\ud83c\udfaf Goal: Remove all tasks at once</p> <p>\ud83d\udce6 Implementation:</p> <pre><code>\"clear\" =&gt; {\n    if fs::metadata(\"todos.txt\").is_ok() {\n        fs::remove_file(\"todos.txt\")?;\n        println!(\"\u2713 All tasks have been removed\");\n    } else {\n        println!(\"No tasks to remove\");\n    }\n}\n</code></pre> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"getting-started/v0.5.0-clear-command/#fsmetadata-for-file-existence-check","title":"<code>fs::metadata()</code> for file existence check","text":"<pre><code>if fs::metadata(\"todos.txt\").is_ok() {\n    // File exists\n} else {\n    // File doesn't exist\n}\n</code></pre> <p>Why not just try to delete?</p> <pre><code>// Without check\nfs::remove_file(\"todos.txt\")?;  \n// If file doesn't exist \u2192 Error propagated to user\n// User sees: \"Error: No such file or directory\" \u274c\n</code></pre> <p>With check:</p> <pre><code>// With check\nif fs::metadata(\"todos.txt\").is_ok() {\n    fs::remove_file(\"todos.txt\")?;\n    println!(\"\u2713 All tasks have been removed\");\n} else {\n    println!(\"No tasks to remove\");  // \u2705 Friendly message\n}\n</code></pre> <p>User experience:</p> <pre><code># First time - file exists\n$ todo clear\n\u2713 All tasks have been removed\n\n# Second time - already cleared\n$ todo clear\nNo tasks to remove  # Not an error!\n</code></pre>"},{"location":"getting-started/v0.5.0-clear-command/#why-is_ok-instead-of-unwrap","title":"Why <code>.is_ok()</code> instead of <code>.unwrap()</code>?","text":"<pre><code>fs::metadata(\"todos.txt\").is_ok()  // Returns bool: true or false\n</code></pre> <p>We don't care about the metadata, only if the file exists.</p> <p>Alternatives:</p> <pre><code>// \u274c Overkill\nlet metadata = fs::metadata(\"todos.txt\")?;\n// Why get metadata if we're just going to delete it?\n\n// \u2705 Simple\nfs::metadata(\"todos.txt\").is_ok()\n</code></pre>"},{"location":"getting-started/v0.5.0-clear-command/#fsremove_file-behavior","title":"<code>fs::remove_file()</code> behavior","text":"<pre><code>fs::remove_file(\"todos.txt\")?;\n</code></pre> <p>What it does:</p> <ul> <li>Deletes the file from filesystem</li> <li>Permanent - no undo!</li> <li>Returns <code>Result</code> - can fail if no permissions</li> </ul> <p>Different from clearing contents:</p> <pre><code>// This would clear contents but keep file\nfs::write(\"todos.txt\", \"\")?;\n\n// This deletes the file entirely\nfs::remove_file(\"todos.txt\")?;\n</code></pre> <p>Why delete instead of clear?</p> <ul> <li>Cleaner - file truly gone</li> <li><code>list</code> command already handles missing file</li> <li>Consistent with \"no tasks\" state</li> </ul>"},{"location":"getting-started/v0.5.0-clear-command/#idempotent-operations","title":"Idempotent operations","text":"<p>What's idempotency?</p> <p>An operation that can be called multiple times with the same result</p> <p>clear is idempotent:</p> <pre><code>todo clear  # Deletes file\ntodo clear  # No file to delete, but still succeeds\ntodo clear  # Still succeeds\n</code></pre> <p>Why this matters:</p> <ul> <li>\u2705 No confusing errors</li> <li>\u2705 Scripts can call it safely</li> <li>\u2705 User doesn't have to check first</li> </ul> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v0.5.0</li> <li>Full diff</li> </ul>"},{"location":"intermediate/v0.6.0-visual-interface-colors/","title":"v0.6.0 - Visual Interface with Colors","text":"<p>\ud83c\udfaf Goal: Add colorful visual hierarchy and progress statistics</p> <p>\ud83d\udce6 Implementation:</p> <p>Import colored crate:</p> <pre><code>use colored::Colorize;\n</code></pre> <p>Enhanced list display:</p> <pre><code>\"list\" =&gt; match fs::read_to_string(\"todos.txt\") {\n    Ok(content) =&gt; {\n        let valid_lines: Vec&lt;&amp;str&gt; = content\n            .lines()\n            .filter(|l| !l.trim().is_empty())\n            .collect();\n\n        if valid_lines.is_empty() {\n            println!(\"No tasks\");\n        } else {\n            println!(\"\\n\ud83d\udccb Tasks:\\n\");\n\n            let mut completed = 0;\n            let total = valid_lines.len();\n\n            for (i, line) in valid_lines.iter().enumerate() {\n                let number = format!(\"{}.\", i + 1);\n\n                if line.contains(\"[x]\") {\n                    let text = line.replace(\"[x]\", \"\").trim().to_string();\n\n                    println!(\n                        \"{} {} {}\",\n                        number.dimmed(),\n                        \"\u2705\".green(),\n                        text.green().strikethrough()\n                    );\n                    completed += 1;\n                } else {\n                    let text = line.replace(\"[ ]\", \"\").trim().to_string();\n                    println!(\n                        \"{} {} {}\",\n                        number.dimmed(),\n                        \"\u23f3\".yellow(),\n                        text.bright_white()\n                    );\n                }\n            }\n\n            println!(\"\\n{}\", \"\u2500\".repeat(30).dimmed());\n\n            let percentage = (completed as f32 / total as f32 * 100.0) as u32;\n            let stats = format!(\"{} of {} completed ({}%)\", completed, total, percentage);\n\n            if percentage == 100 {\n                println!(\"{}\", stats.green().bold());\n            } else if percentage &gt;= 50 {\n                println!(\"{}\", stats.yellow());\n            } else {\n                println!(\"{}\", stats.red());\n            }\n\n            println!();\n        }\n    }\n    Err(_) =&gt; {\n        println!(\"No tasks\");\n    }\n}\n</code></pre> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"intermediate/v0.6.0-visual-interface-colors/#the-colored-crate","title":"The <code>colored</code> crate","text":"<pre><code>use colored::Colorize;\n\n\"text\".red()            // Red text\n\"text\".green()          // Green text\n\"text\".yellow()         // Yellow text\n\"text\".dimmed()         // Dim/gray text\n\"text\".bold()           // Bold text\n\"text\".strikethrough()  // Strike\u0336t\u0336h\u0336r\u0336o\u0336u\u0336g\u0336h\u0336\n</code></pre> <p>These are chainable:</p> <pre><code>\"text\".green().bold()           // Bold green\n\"text\".red().strikethrough()    // Red with strikethrough\n</code></pre>"},{"location":"intermediate/v0.6.0-visual-interface-colors/#visual-hierarchy","title":"Visual hierarchy","text":"<pre><code>number.dimmed()          // De-emphasize task numbers\n\"\u2705\".green()              // Completed indicator\ntext.green().strikethrough()  // Completed task\n\"\u23f3\".yellow()             // Pending indicator\ntext.bright_white()     // Pending task (prominent)\n</code></pre> <p>Design principle:</p> <ol> <li>Numbers are dimmed - helper info, not main content</li> <li>Icons are colored - quick visual scan</li> <li>Completed tasks strikethrough - clearly done</li> <li>Pending tasks bright - what needs attention</li> </ol>"},{"location":"intermediate/v0.6.0-visual-interface-colors/#progress-statistics-with-percentage","title":"Progress statistics with percentage","text":"<pre><code>let completed = 0;\nlet total = valid_lines.len();\n\n// Count completed during loop\nif line.contains(\"[x]\") {\n    completed += 1;\n}\n\n// Calculate percentage\nlet percentage = (completed as f32 / total as f32 * 100.0) as u32;\n</code></pre> <p>Type conversions explained:</p> <pre><code>completed as f32   // usize \u2192 f32 (for division)\ntotal as f32       // usize \u2192 f32\n* 100.0            // f32 result\nas u32             // f32 \u2192 u32 (truncate decimals)\n</code></pre> <p>Why this chain?</p> <pre><code>// Without conversion\nlet percentage = completed / total * 100;\n// 2 / 5 * 100 = 0 * 100 = 0  \u274c Integer division!\n\n// With f32\nlet percentage = (2 as f32 / 5 as f32 * 100.0) as u32;\n// 2.0 / 5.0 * 100.0 = 40.0 \u2192 40  \u2705 Correct!\n</code></pre>"},{"location":"intermediate/v0.6.0-visual-interface-colors/#dynamic-color-based-on-progress","title":"Dynamic color based on progress","text":"<pre><code>if percentage == 100 {\n    println!(\"{}\", stats.green().bold());     // \ud83c\udf89 All done!\n} else if percentage &gt;= 50 {\n    println!(\"{}\", stats.yellow());            // \ud83d\udcca Making progress\n} else {\n    println!(\"{}\", stats.red());               // \ud83d\udd34 Just started\n}\n</code></pre> <p>Psychology:</p> <ul> <li>Green = Achievement, success, positive reinforcement</li> <li>Yellow = In progress, keep going</li> <li>Red = Attention needed, urgency</li> </ul>"},{"location":"intermediate/v0.6.0-visual-interface-colors/#separator-line","title":"Separator line","text":"<pre><code>println!(\"\\n{}\", \"\u2500\".repeat(30).dimmed());\n</code></pre> <p>Creates visual separation:</p> <pre><code>1. \u23f3 Task 1\n2. \u2705 Task 2\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2190 separator\n2 of 2 completed (100%)\n</code></pre> <p>Why dimmed?</p> <ul> <li>Visual break without being loud</li> <li>Guides eye but doesn't distract</li> </ul>"},{"location":"intermediate/v0.6.0-visual-interface-colors/#colored-feedback-messages","title":"Colored feedback messages","text":"<pre><code>println!(\"{}\", \"\u2713 Task added\".green());                 // Success\nprintln!(\"{}\", \"\u2713 Task marked as completed\".green());   // Success\nprintln!(\"{}\", \"\u2713 Task unmarked\".yellow());             // Neutral\nprintln!(\"{}\", \"\u2713 Task removed\".red());                  // Destructive\nprintln!(\"{}\", \"\u2713 All tasks have been removed\".red().bold());  // Very destructive\n</code></pre> <p>Semantic coloring:</p> <ul> <li>Green - Creating, completing (positive actions)</li> <li>Yellow - Undoing (neutral/reversible)</li> <li>Red - Deleting (destructive/permanent)</li> <li>Red + Bold - Very destructive (clear all)</li> </ul> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v0.6.0</li> <li>Full diff</li> <li>colored crate docs</li> </ul>"},{"location":"intermediate/v0.7.0-advanced-filters/","title":"v0.7.0 - Advanced Filters (--pending, --done)","text":"<p>\ud83c\udfaf Goal: Filter tasks by status with helper function for display</p> <p>\ud83d\udce6 Implementation:</p> <p>Helper function extracted:</p> <pre><code>fn display_tasks(tasks: &amp;[&amp;str], title: &amp;str) {\n    println!(\"\\n\ud83d\udccb {}:\\n\", title);\n\n    let mut completed = 0;\n    let total = tasks.len();\n\n    for (i, line) in tasks.iter().enumerate() {\n        // ... display logic (same as v0.6.0) ...\n    }\n\n    // ... statistics ...\n}\n</code></pre> <p>Filter logic in list command:</p> <pre><code>\"list\" =&gt; {\n    let filter = if args.len() &gt; 2 {\n        args[2].as_str()\n    } else {\n        \"all\"\n    };\n\n    match fs::read_to_string(\"todos.txt\") {\n        Ok(content) =&gt; {\n            let valid_lines: Vec&lt;&amp;str&gt; = content\n                .lines()\n                .filter(|l| !l.trim().is_empty())\n                .collect();\n\n            if valid_lines.is_empty() {\n                println!(\"No tasks\");\n                return Ok(());\n            }\n\n            match filter {\n                \"--pending\" =&gt; {\n                    let pending: Vec&lt;&amp;str&gt; = valid_lines\n                        .iter()\n                        .filter(|line| line.contains(\"[ ]\"))\n                        .copied()\n                        .collect();\n\n                    if pending.is_empty() {\n                        println!(\"No pending tasks\");\n                    } else {\n                        display_tasks(&amp;pending, \"Pending tasks\");\n                    }\n                }\n\n                \"--done\" =&gt; {\n                    let completed: Vec&lt;&amp;str&gt; = valid_lines\n                        .iter()\n                        .filter(|line| line.contains(\"[x]\"))\n                        .copied()\n                        .collect();\n\n                    if completed.is_empty() {\n                        println!(\"No completed tasks\");\n                    } else {\n                        display_tasks(&amp;completed, \"Completed tasks\");\n                    }\n                }\n\n                \"all\" =&gt; {\n                    display_tasks(&amp;valid_lines, \"Tasks\");\n                }\n\n                _ =&gt; {\n                    return Err(format!(\n                        \"Invalid filter: {}. Use --pending or --done\",\n                        filter\n                    ).into());\n                }\n            }\n        }\n        Err(_) =&gt; {\n            println!(\"No tasks\");\n        }\n    }\n}\n</code></pre> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"intermediate/v0.7.0-advanced-filters/#dry-principle-dont-repeat-yourself","title":"DRY Principle - Don't Repeat Yourself","text":"<p>Before v0.7.0: Display logic was duplicated in <code>list</code> command After v0.7.0: Extracted to <code>display_tasks()</code> helper function</p> <p>Why this matters:</p> <pre><code>// Before: 50+ lines of display code in list command\n\"list\" =&gt; {\n    // ... filtering ...\n    // ... 50 lines of display logic ...\n    // ... statistics ...\n}\n\n// After: Clean separation\n\"list\" =&gt; {\n    // ... filtering ...\n    display_tasks(&amp;filtered, \"Title\");  // 1 line!\n}\n\nfn display_tasks(tasks: &amp;[&amp;str], title: &amp;str) {\n    // ... display logic (reusable) ...\n}\n</code></pre>"},{"location":"intermediate/v0.7.0-advanced-filters/#function-signatures-and-slices","title":"Function Signatures and Slices","text":"<pre><code>fn display_tasks(tasks: &amp;[&amp;str], title: &amp;str) {\n    //                    \u2191 slice of string references\n}\n</code></pre> <p>Why <code>&amp;[&amp;str]</code> instead of <code>Vec&lt;&amp;str&gt;</code>?</p> <pre><code>// This works but creates unnecessary copy\nfn display_tasks(tasks: Vec&lt;&amp;str&gt;) { /* ... */ }\n\n// This is more efficient - borrows without copying\nfn display_tasks(tasks: &amp;[&amp;str]) { /* ... */ }\n</code></pre> <p>Slice benefits:</p> <ul> <li>\u2705 No allocation/copying</li> <li>\u2705 Can accept Vec, array, or another slice</li> <li>\u2705 More flexible API</li> </ul>"},{"location":"intermediate/v0.7.0-advanced-filters/#the-copied-method","title":"The <code>.copied()</code> method","text":"<pre><code>let pending: Vec&lt;&amp;str&gt; = valid_lines\n    .iter()\n    .filter(|line| line.contains(\"[ ]\"))\n    .copied()  // \u2190 Important!\n    .collect();\n</code></pre> <p>Why <code>.copied()</code> is needed:</p> <pre><code>valid_lines.iter()  // Returns Iterator&lt;Item = &amp;&amp;str&gt;\n                    //                    \u2191 double reference!\n\n.filter(|line| line.contains(\"[ ]\"))  // &amp;&amp;str \u2192 bool\n// After filter, we still have &amp;&amp;str\n\n.copied()  // &amp;&amp;str \u2192 &amp;str (copies the reference)\n</code></pre> <p>Without <code>.copied()</code>:</p> <pre><code>// Type mismatch error!\nlet pending: Vec&lt;&amp;str&gt; = valid_lines\n    .iter()\n    .filter(|line| line.contains(\"[ ]\"))\n    .collect();  // Tries to collect Vec&lt;&amp;&amp;str&gt;\n</code></pre>"},{"location":"intermediate/v0.7.0-advanced-filters/#pipeline-architecture","title":"Pipeline Architecture","text":"<p>The filtering pipeline:</p> <pre><code>let pending: Vec&lt;&amp;str&gt; = valid_lines\n    .iter()                    // Step 1: Get iterator\n    .filter(|line| line.contains(\"[ ]\"))  // Step 2: Filter\n    .copied()                  // Step 3: Fix reference type\n    .collect();                // Step 4: Build Vec\n</code></pre> <p>This is functional programming:</p> <ul> <li>Each step transforms data</li> <li>Steps are composable</li> <li>No intermediate variables needed</li> <li>Easy to read and modify</li> </ul>"},{"location":"intermediate/v0.7.0-advanced-filters/#error-handling-with-format","title":"Error Handling with <code>format!</code>","text":"<pre><code>return Err(format!(\n    \"Invalid filter: {}. Use --pending or --done\",\n    filter\n).into());\n</code></pre> <p>Breaking it down:</p> <pre><code>format!(\"Invalid filter: {}. Use --pending or --done\", filter)\n// Creates String with dynamic content\n\n.into()  // String \u2192 Box&lt;dyn Error&gt;\n// Converts to error type expected by function\n</code></pre> <p>Why <code>format!</code> instead of <code>println!</code> style?</p> <ul> <li><code>format!</code> returns String (can be used in error)</li> <li><code>println!</code> prints to console (can't be used in error)</li> <li>Same syntax, different purpose</li> </ul>"},{"location":"intermediate/v0.7.0-advanced-filters/#match-expression-as-filter-router","title":"Match Expression as Filter Router","text":"<pre><code>match filter {\n    \"--pending\" =&gt; { /* pending logic */ }\n    \"--done\" =&gt; { /* done logic */ }\n    \"all\" =&gt; { /* all logic */ }\n    _ =&gt; { /* error case */ }\n}\n</code></pre> <p>This is a routing pattern:</p> <ul> <li>Each arm handles one filter type</li> <li><code>_</code> catches invalid filters</li> <li>Easy to add new filters later</li> </ul> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v0.7.0</li> <li>Full diff</li> </ul>"},{"location":"intermediate/v0.8.0-priority-system/","title":"v0.8.0 - Priority System + Priority Filters","text":"<p>\ud83c\udfaf Goal: Add three-level priority system with visual indicators and filtering</p> <p>\ud83d\udce6 Key Implementations:</p> <p>Priority extraction function:</p> <pre><code>fn extract_priority(line: &amp;str) -&gt; (&amp;str, String) {\n    let without_checkbox = line\n        .replace(\"[ ]\", \"\")\n        .replace(\"[x]\", \"\")\n        .trim()\n        .to_string();\n\n    if without_checkbox.contains(\"(high)\") {\n        let text = without_checkbox.replace(\"(high)\", \"\").trim().to_string();\n        (\"high\", text)\n    } else if without_checkbox.contains(\"(low)\") {\n        let text = without_checkbox.replace(\"(low)\", \"\").trim().to_string();\n        (\"low\", text)\n    } else {\n        (\"medium\", without_checkbox)\n    }\n}\n</code></pre> <p>Priority emoji function:</p> <pre><code>fn priority_emoji(priority: &amp;str) -&gt; String {\n    match priority {\n        \"high\" =&gt; \"\ud83d\udd34\".red().to_string(),\n        \"low\" =&gt; \"\ud83d\udfe2\".green().to_string(),\n        _ =&gt; \"\ud83d\udfe1\".yellow().to_string(),\n    }\n}\n</code></pre> <p>Adding tasks with priority:</p> <pre><code>\"add\" =&gt; {\n    // ... validation ...\n\n    let line = match args.len() {\n        3 =&gt; format!(\"[ ] {}\", task),  // No flag = medium\n\n        4 =&gt; {\n            let flag = args[3].as_str();\n            match flag {\n                \"--high\" =&gt; format!(\"[ ] (high) {}\", task),\n                \"--low\" =&gt; format!(\"[ ] (low) {}\", task),\n                _ =&gt; return Err(format!(\"Invalid flag '{}'. Use --high or --low\", flag).into()),\n            }\n        }\n\n        _ =&gt; return Err(\"Usage: todo add &lt;task&gt; [--high | --low]. Only one flag allowed\".into()),\n    };\n\n    // Write to file...\n}\n</code></pre> <p>Multi-flag parsing in list:</p> <pre><code>\"list\" =&gt; {\n    let mut status_filter = \"all\";\n    let mut priority_filter: Option&lt;&amp;str&gt; = None;\n\n    for arg in &amp;args[2..] {\n        match arg.as_str() {\n            \"--pending\" =&gt; {\n                if status_filter != \"all\" {\n                    return Err(\"Use only one status filter (--pending or --done)\".into());\n                }\n                status_filter = \"pending\";\n            }\n            \"--done\" =&gt; {\n                if status_filter != \"all\" {\n                    return Err(\"Use only one status filter\".into());\n                }\n                status_filter = \"done\";\n            }\n            \"--high\" =&gt; {\n                if priority_filter.is_some() {\n                    return Err(\"Use only one priority filter\".into());\n                }\n                priority_filter = Some(\"high\");\n            }\n            \"--low\" =&gt; {\n                if priority_filter.is_some() {\n                    return Err(\"Use only one priority filter\".into());\n                }\n                priority_filter = Some(\"low\");\n            }\n            _ =&gt; return Err(format!(\"Invalid filter: {}\", arg).into()),\n        }\n    }\n\n    // Apply filters sequentially...\n\n    // First filter by status\n    valid_lines = match status_filter {\n        \"pending\" =&gt; valid_lines.iter().filter(|l| l.contains(\"[ ]\")).copied().collect(),\n        \"done\" =&gt; valid_lines.iter().filter(|l| l.contains(\"[x]\")).copied().collect(),\n        _ =&gt; valid_lines,\n    };\n\n    // Then filter by priority (if specified)\n    if let Some(pri) = priority_filter {\n        valid_lines = valid_lines\n            .iter()\n            .filter(|line| {\n                let (priority, _) = extract_priority(line);\n                priority == pri\n            })\n            .copied()\n            .collect();\n    }\n\n    // Dynamic title based on filters\n    let title = match (status_filter, priority_filter) {\n        (\"pending\", Some(\"high\")) =&gt; \"High priority pending tasks\",\n        (\"pending\", Some(\"low\")) =&gt; \"Low priority pending tasks\",\n        (\"pending\", None) =&gt; \"Pending tasks\",\n        (\"done\", Some(\"high\")) =&gt; \"High priority completed tasks\",\n        (\"done\", Some(\"low\")) =&gt; \"Low priority completed tasks\",\n        (\"done\", None) =&gt; \"Completed tasks\",\n        (_, Some(\"high\")) =&gt; \"High priority\",\n        (_, Some(\"low\")) =&gt; \"Low priority\",\n        _ =&gt; \"Tasks\",\n    };\n}\n</code></pre> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"intermediate/v0.8.0-priority-system/#tuple-return-types","title":"Tuple Return Types","text":"<pre><code>fn extract_priority(line: &amp;str) -&gt; (&amp;str, String) {\n    //                \u2191 tuple of priority and cleaned text\n}\n</code></pre> <p>Why return a tuple?</p> <pre><code>// Single return would need two function calls\nlet priority = get_priority(line);\nlet text = get_clean_text(line);\n\n// Tuple return gets both at once\nlet (priority, text) = extract_priority(line);\n</code></pre> <p>Tuple destructuring:</p> <pre><code>let (priority, text) = extract_priority(line);\n//  \u2191 priority    \u2191 text\n</code></pre>"},{"location":"intermediate/v0.8.0-priority-system/#optiont-for-optional-filters","title":"<code>Option&lt;T&gt;</code> for Optional Filters","text":"<pre><code>let mut priority_filter: Option&lt;&amp;str&gt; = None;\n</code></pre> <p>Why <code>Option</code> instead of just <code>&amp;str</code>?</p> <pre><code>// Without Option - what value means \"no filter\"?\nlet mut priority_filter: &amp;str = \"\";  // Empty string?\n// Or maybe \"none\"? Or \"all\"? Ambiguous!\n\n// With Option - clear meaning\nlet mut priority_filter: Option&lt;&amp;str&gt; = None;  // No filter\npriority_filter = Some(\"high\");                 // High filter\n</code></pre> <p>Pattern matching on Option:</p> <pre><code>if let Some(pri) = priority_filter {\n    // Only runs if filter is set\n    // pri is the &amp;str value inside Some\n}\n</code></pre>"},{"location":"intermediate/v0.8.0-priority-system/#string-manipulation-pipeline","title":"String Manipulation Pipeline","text":"<pre><code>let without_checkbox = line\n    .replace(\"[ ]\", \"\")\n    .replace(\"[x]\", \"\")\n    .trim()\n    .to_string();\n</code></pre> <p>Step-by-step transformation:</p> <pre><code>\"[ ] (high) Buy milk\"\n    .replace(\"[ ]\", \"\")  // \"(high) Buy milk\"\n    .replace(\"[x]\", \"\")  // \"(high) Buy milk\" (no change)\n    .trim()              // \"(high) Buy milk\" (no extra spaces)\n    .to_string()         // Owned String for further manipulation\n</code></pre>"},{"location":"intermediate/v0.8.0-priority-system/#match-with-guards","title":"Match with Guards","text":"<pre><code>match flag {\n    \"--high\" =&gt; format!(\"[ ] (high) {}\", task),\n    \"--low\" =&gt; format!(\"[ ] (low) {}\", task),\n    _ =&gt; return Err(format!(\"Invalid flag '{}'. Use --high or --low\", flag).into()),\n}\n</code></pre> <p>The <code>_</code> pattern catches everything else:</p> <ul> <li>Invalid flags</li> <li>Missing flags</li> <li>Typos</li> </ul> <p>Error message includes the actual invalid value for better UX.</p>"},{"location":"intermediate/v0.8.0-priority-system/#multi-flag-argument-parsing","title":"Multi-Flag Argument Parsing","text":"<p>Challenge: Users can combine flags in any order:</p> <pre><code>todo list --pending --high\ntodo list --high --pending\ntodo list --done --low\n</code></pre> <p>Solution: Sequential processing with validation:</p> <pre><code>for arg in &amp;args[2..] {\n    match arg.as_str() {\n        \"--pending\" =&gt; { /* validate and set */ }\n        \"--high\" =&gt; { /* validate and set */ }\n        _ =&gt; return Err(format!(\"Invalid filter: {}\", arg).into()),\n    }\n}\n</code></pre> <p>Validation prevents conflicts:</p> <pre><code>if status_filter != \"all\" {\n    return Err(\"Use only one status filter (--pending or --done)\".into());\n}\n</code></pre>"},{"location":"intermediate/v0.8.0-priority-system/#pipeline-filtering-architecture","title":"Pipeline Filtering Architecture","text":"<p>Two-stage filtering:</p> <pre><code>// Stage 1: Filter by status\nvalid_lines = match status_filter {\n    \"pending\" =&gt; /* filter pending */,\n    \"done\" =&gt; /* filter done */,\n    _ =&gt; /* no change */,\n};\n\n// Stage 2: Filter by priority (if specified)\nif let Some(pri) = priority_filter {\n    valid_lines = /* filter by priority */;\n}\n</code></pre> <p>Why sequential filtering?</p> <ul> <li>Composable - Can add more filter stages</li> <li>Efficient - Each stage works on smaller dataset</li> <li>Clear - Easy to understand and debug</li> </ul>"},{"location":"intermediate/v0.8.0-priority-system/#dynamic-title-generation","title":"Dynamic Title Generation","text":"<pre><code>let title = match (status_filter, priority_filter) {\n    (\"pending\", Some(\"high\")) =&gt; \"High priority pending tasks\",\n    (\"pending\", Some(\"low\")) =&gt; \"Low priority pending tasks\",\n    // ... all combinations ...\n    _ =&gt; \"Tasks\",\n};\n</code></pre> <p>Tuple pattern matching:</p> <ul> <li>First element = status filter</li> <li>Second element = priority filter (Option)</li> <li>Covers all possible combinations</li> <li>Provides descriptive titles</li> </ul> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v0.8.0</li> <li>Full diff</li> </ul>"},{"location":"intermediate/v0.9.0-priority-sorting/","title":"v0.9.0 - Priority Sorting","text":"<p>\ud83c\udfaf Goal: Sort tasks by priority (high \u2192 medium \u2192 low)</p> <p>\ud83d\udce6 Key Implementation:</p> <p>Priority mapping function:</p> <pre><code>fn priority_order(pri: &amp;str) -&gt; u8 {\n    match pri {\n        \"high\" =&gt; 0,      // First\n        \"medium\" =&gt; 1,    // Middle\n        \"low\" =&gt; 2,       // Last\n        _ =&gt; 3,           // Unknown (end)\n    }\n}\n</code></pre> <p>Sort flag handling:</p> <pre><code>\"list\" =&gt; {\n    let mut status_filter = \"all\";\n    let mut priority_filter: Option&lt;&amp;str&gt; = None;\n    let mut sort = false;  // \u2190 NEW\n\n    for arg in &amp;args[2..] {\n        match arg.as_str() {\n            // ... other flags ...\n            \"--sort\" =&gt; {\n                if sort {\n                    return Err(\"Use --sort only once.\".into());\n                }\n                sort = true;\n            }\n            _ =&gt; return Err(format!(\"Invalid filter: {}\", arg).into()),\n        }\n    }\n\n    // ... filter tasks ...\n\n    // Sort AFTER filtering (optimization!)\n    if sort {\n        valid_lines.sort_by(|a, b| {\n            let (pri_a, _) = extract_priority(a);\n            let (pri_b, _) = extract_priority(b);\n            priority_order(pri_a).cmp(&amp;priority_order(pri_b))\n        });\n    }\n\n    // ... display ...\n}\n</code></pre> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"intermediate/v0.9.0-priority-sorting/#numeric-priority-mapping","title":"Numeric Priority Mapping","text":"<pre><code>fn priority_order(pri: &amp;str) -&gt; u8 {\n    match pri {\n        \"high\" =&gt; 0,      // First (highest priority)\n        \"medium\" =&gt; 1,    // Middle\n        \"low\" =&gt; 2,       // Last (lowest priority)\n        _ =&gt; 3,           // Unknown (end)\n    }\n}\n</code></pre> <p>Why numbers instead of strings?</p> <pre><code>// String comparison doesn't work for priority order\n\"high\" &gt; \"low\"    // true alphabetically, but wrong for priority!\n\"medium\" &gt; \"high\" // true alphabetically, but wrong!\n\n// Numeric comparison works correctly\n0 &lt; 1 &lt; 2 &lt; 3     // Perfect for sorting!\n</code></pre> <p>Why <code>u8</code>?</p> <ul> <li>Small range (0-255) - perfect for 4 priority levels</li> <li>Memory efficient</li> <li>Fast comparisons</li> </ul>"},{"location":"intermediate/v0.9.0-priority-sorting/#the-sort_by-method","title":"The <code>.sort_by()</code> Method","text":"<pre><code>valid_lines.sort_by(|a, b| {\n    let (pri_a, _) = extract_priority(a);\n    let (pri_b, _) = extract_priority(b);\n    priority_order(pri_a).cmp(&amp;priority_order(pri_b))\n});\n</code></pre> <p>Breaking it down:</p> <pre><code>|a, b|  // Closure - takes two elements to compare\n{\n    let (pri_a, _) = extract_priority(a);  // Get priority of first\n    let (pri_b, _) = extract_priority(b);  // Get priority of second\n    priority_order(pri_a).cmp(&amp;priority_order(pri_b))  // Compare\n}\n</code></pre> <p>The <code>.cmp()</code> method:</p> <pre><code>priority_order(pri_a).cmp(&amp;priority_order(pri_b))\n// Returns: Ordering::Less, Ordering::Equal, or Ordering::Greater\n</code></pre> <p>How <code>.sort_by()</code> uses this:</p> <ul> <li>If <code>cmp()</code> returns <code>Less</code> - <code>a</code> comes before <code>b</code></li> <li>If <code>cmp()</code> returns <code>Equal</code> - order doesn't matter</li> <li>If <code>cmp()</code> returns <code>Greater</code> - <code>b</code> comes before <code>a</code></li> </ul>"},{"location":"intermediate/v0.9.0-priority-sorting/#performance-optimization","title":"Performance Optimization","text":"<p>Key insight: Sort AFTER filtering</p> <pre><code>// \u274c Bad: Sort first, then filter\nlet all_tasks = read_all_tasks();           // 100 tasks\nall_tasks.sort_by(...);                     // O(100 log 100)\nlet filtered = filter_tasks(all_tasks);    // 10 tasks\n\n// \u2705 Good: Filter first, then sort\nlet all_tasks = read_all_tasks();           // 100 tasks\nlet filtered = filter_tasks(all_tasks);    // 10 tasks\nfiltered.sort_by(...);                      // O(10 log 10)\n</code></pre> <p>Why this matters:</p> <pre><code>O(100 log 100) \u2248 664 comparisons\nO(10 log 10)   \u2248 33 comparisons\n20x faster! \ud83d\ude80\n</code></pre> <p>Real-world impact:</p> <ul> <li>Small lists (10-50 tasks): Minor improvement</li> <li>Large lists (1000+ tasks): Major improvement</li> <li>Always good practice for data pipelines</li> </ul>"},{"location":"intermediate/v0.9.0-priority-sorting/#closure-syntax-deep-dive","title":"Closure Syntax Deep Dive","text":"<pre><code>|a, b| {\n    // closure body\n}\n</code></pre> <p>This is equivalent to:</p> <pre><code>fn compare_closure(a: &amp;str, b: &amp;str) -&gt; std::cmp::Ordering {\n    let (pri_a, _) = extract_priority(a);\n    let (pri_b, _) = extract_priority(b);\n    priority_order(pri_a).cmp(&amp;priority_order(pri_b))\n}\n\n// Used as:\nvalid_lines.sort_by(compare_closure);\n</code></pre> <p>Why use closure instead of named function?</p> <ul> <li>Concise - Defined inline where used</li> <li>Captures context - Can access variables from scope</li> <li>Standard pattern - idiomatic Rust for <code>.sort_by()</code></li> </ul>"},{"location":"intermediate/v0.9.0-priority-sorting/#sorting-stability","title":"Sorting Stability","text":"<p>What happens with equal priorities?</p> <pre><code>// Tasks with same priority maintain original order\n\"[ ] (high) Task A\"  // Original position 1\n\"[ ] (high) Task B\"  // Original position 3\n// After sort: Task A still comes before Task B\n</code></pre> <p>This is \"stable sorting\" - Rust's <code>.sort_by()</code> is stable.</p> <p>Why stability matters:</p> <ul> <li>Predictable results</li> <li>Preserves chronological order within priority</li> <li>Better user experience</li> </ul>"},{"location":"intermediate/v0.9.0-priority-sorting/#error-handling-for-sort-flag","title":"Error Handling for Sort Flag","text":"<pre><code>\"--sort\" =&gt; {\n    if sort {\n        return Err(\"Use --sort only once.\".into());\n    }\n    sort = true;\n}\n</code></pre> <p>Why prevent duplicate <code>--sort</code>?</p> <pre><code># This would be confusing\ntodo list --sort --sort --high\n# Which sort takes effect? Both? First? Last?\n</code></pre> <p>Clear error message:</p> <ul> <li>Tells user what's wrong</li> <li>Explains the constraint</li> <li>Prevents ambiguous behavior</li> </ul>"},{"location":"intermediate/v0.9.0-priority-sorting/#integration-with-existing-pipeline","title":"Integration with Existing Pipeline","text":"<p>How sorting fits into the pipeline:</p> <pre><code>// 1. Read file\nlet content = fs::read_to_string(\"todos.txt\")?;\n\n// 2. Filter empty lines\nlet valid_lines: Vec&lt;&amp;str&gt; = content.lines()...collect();\n\n// 3. Filter by status (--pending/--done)\nvalid_lines = filter_by_status(valid_lines, status_filter);\n\n// 4. Filter by priority (--high/--low)\nvalid_lines = filter_by_priority(valid_lines, priority_filter);\n\n// 5. Sort by priority (--sort) \u2190 NEW\nif sort {\n    valid_lines.sort_by(...);\n}\n\n// 6. Display\ndisplay_tasks(&amp;valid_lines, title);\n</code></pre> <p>Each stage is independent and composable.</p>"},{"location":"intermediate/v0.9.0-priority-sorting/#future-extensibility","title":"Future Extensibility","text":"<p>Easy to add more sorting options:</p> <pre><code>// Future: sort by due date\n\"--sort-due\" =&gt; {\n    valid_lines.sort_by(|a, b| {\n        extract_due_date(a).cmp(&amp;extract_due_date(b))\n    });\n}\n\n// Future: sort by creation date\n\"--sort-created\" =&gt; {\n    valid_lines.sort_by(|a, b| {\n        extract_created_date(a).cmp(&amp;extract_created_date(b))\n    });\n}\n</code></pre> <p>The pattern is established - just add new sort functions.</p> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v0.9.0</li> <li>Full diff</li> </ul>"},{"location":"intermediate/v1.0.0-search-refactoring/","title":"v1.0.0 - Search + Display Refactoring","text":"<p>\ud83c\udfaf Goal: Add search command and refactor display into atomic/orchestrated functions</p> <p>\ud83d\udce6 Key Implementations:</p> <p>Atomic rendering function:</p> <pre><code>fn display_task(number: usize, line: &amp;str) {\n    let number_fmt = format!(\"{}.\", number);\n    let completed = line.contains(\"[x]\");\n\n    let (priority, text) = extract_priority(line);\n    let emoji = priority_emoji(priority);\n\n    if completed {\n        println!(\n            \"{} {} {} {}\",\n            number_fmt.dimmed(),\n            emoji,\n            \"\u2705\".green(),\n            text.green().strikethrough()\n        );\n    } else {\n        println!(\n            \"{} {} {} {}\",\n            number_fmt.dimmed(),\n            emoji,\n            \"\u23f3\".yellow(),\n            text.bright_white()\n        );\n    }\n}\n</code></pre> <p>Orchestrated rendering function (renamed):</p> <pre><code>fn display_lists(tasks: &amp;[&amp;str], title: &amp;str) {\n    println!(\"\\n\ud83d\udccb {}:\\n\", title);\n\n    let mut completed = 0;\n    let total = tasks.len();\n\n    for (i, line) in tasks.iter().enumerate() {\n        display_task(i + 1, line);  // \u2190 Uses atomic function\n\n        if line.contains(\"[x]\") {\n            completed += 1;\n        }\n    }\n\n    // ... statistics ...\n}\n</code></pre> <p>Search command:</p> <pre><code>\"search\" =&gt; {\n    if args.len() &lt; 3 {\n        return Err(\"Usage: todo search &lt;term&gt;\".into());\n    }\n\n    let term = &amp;args[2];\n\n    match fs::read_to_string(\"todos.txt\") {\n        Ok(content) =&gt; {\n            let valid_lines: Vec&lt;&amp;str&gt; = content\n                .lines()\n                .filter(|l| !l.trim().is_empty())\n                .collect();\n\n            if valid_lines.is_empty() {\n                println!(\"No tasks\");\n                return Ok(());\n            }\n\n            let mut results: Vec&lt;(usize, &amp;str)&gt; = Vec::new();\n\n            for (i, line) in valid_lines.iter().enumerate() {\n                if line.to_lowercase().contains(&amp;term.to_lowercase()) {\n                    results.push((i + 1, line));  // Keep original number!\n                }\n            }\n\n            if results.is_empty() {\n                println!(\"No results for '{}'\", term);\n            } else {\n                println!(\"\\n\ud83d\udccb Results for \\\"{}\\\":\\n\", term);\n\n                for (number, line) in &amp;results {\n                    display_task(*number, line);  // \u2190 Uses atomic function\n                }\n\n                println!(\"\\n{} result(s) found\\n\", results.len());\n            }\n        }\n        Err(_) =&gt; {\n            println!(\"No tasks\");\n        }\n    }\n}\n</code></pre> <p>\ud83e\udde0 Key Design:</p>"},{"location":"intermediate/v1.0.0-search-refactoring/#atomic-vs-orchestrated-functions","title":"Atomic vs Orchestrated Functions","text":"<p>Atomic function - <code>display_task()</code>: - Renders ONE task - Takes specific task number - No statistics - Reusable across contexts</p> <p>Orchestrated function - <code>display_lists()</code>: - Renders LIST of tasks - Handles numbering internally - Calculates statistics - Manages overall layout</p> <p>Why this separation?</p> <pre><code>// List command - needs statistics and sequential numbering\ndisplay_lists(&amp;tasks, \"Tasks\");\n\n// Search command - needs original numbering, no statistics\nfor (number, line) in &amp;results {\n    display_task(*number, line);\n}\n</code></pre>"},{"location":"intermediate/v1.0.0-search-refactoring/#preserving-original-task-numbers","title":"Preserving Original Task Numbers","text":"<p>Critical design decision for search:</p> <pre><code>for (i, line) in valid_lines.iter().enumerate() {\n    if line.to_lowercase().contains(&amp;term.to_lowercase()) {\n        results.push((i + 1, line));  // \u2190 Original number!\n    }\n}\n</code></pre> <p>Why this matters:</p> <pre><code>$ todo list\n1. [ ] Buy milk\n2. [ ] Call mom\n3. [ ] Learn Rust\n\n$ todo search \"rust\"\n\ud83d\udccb Results for \"rust\":\n3. [ ] Learn Rust  \u2190 Shows as #3, not #1!\n\n$ todo done 3      # User can use the original number!\n\u2713 Task marked as completed\n</code></pre> <p>Without original numbering:</p> <pre><code>// Wrong approach - renumbers search results\nfor (i, line) in search_results.iter().enumerate() {\n    display_task(i + 1, line);  // Shows as #1, but is really #3!\n}\n\n// User tries: todo done 1\n// Error: Invalid task number! \u274c\n</code></pre>"},{"location":"intermediate/v1.0.0-search-refactoring/#case-insensitive-search","title":"Case-Insensitive Search","text":"<pre><code>line.to_lowercase().contains(&amp;term.to_lowercase())\n</code></pre> <p>Why convert both sides:</p> <pre><code>// Case-sensitive search (bad)\n\"Learn Rust\".contains(\"rust\")  // false \u274c\n\"learn rust\".contains(\"RUST\")  // false \u274c\n\n// Case-insensitive search (good)\n\"Learn Rust\".to_lowercase().contains(\"rust\".to_lowercase())  // true \u2705\n\"learn rust\".to_lowercase().contains(\"RUST\".to_lowercase())  // true \u2705\n</code></pre> <p>User experience:</p> <pre><code>$ todo search \"RUST\"\n\ud83d\udccb Results for \"RUST\":\n3. [ ] Learn Rust\n\n$ todo search \"rust\"\n\ud83d\udccb Results for \"rust\":\n3. [ ] Learn Rust\n\n$ todo search \"LeArN\"\n\ud83d\udccb Results for \"LeArN\":\n3. [ ] Learn Rust\n</code></pre> <p>All work the same - much more forgiving!</p>"},{"location":"intermediate/v1.0.0-search-refactoring/#tuple-vec-for-search-results","title":"Tuple Vec for Search Results","text":"<pre><code>let mut results: Vec&lt;(usize, &amp;str)&gt; = Vec::new();\n//                \u2191 tuple of (original_number, task_line)\n\nresults.push((i + 1, line));\n</code></pre> <p>Why store tuples instead of just lines?</p> <pre><code>// Option 1: Just lines\nlet results: Vec&lt;&amp;str&gt; = vec![\"[ ] Learn Rust\"];\n// Lost original number information!\n\n// Option 2: Tuples (chosen)\nlet results: Vec&lt;(usize, &amp;str)&gt; = vec![(3, \"[ ] Learn Rust\")];\n// Keep both number and line!\n</code></pre> <p>Destructuring in display:</p> <pre><code>for (number, line) in &amp;results {\n    display_task(*number, line);\n}\n//  \u2191 number    \u2191 line\n</code></pre>"},{"location":"intermediate/v1.0.0-search-refactoring/#function-refactoring-benefits","title":"Function Refactoring Benefits","text":"<p>Before v1.0.0: Display code was duplicated <pre><code>// In list command - 50+ lines\nfor (i, line) in tasks.iter().enumerate() {\n    let number = format!(\"{}.\", i + 1);\n    let completed = line.contains(\"[x]\");\n    let (priority, text) = extract_priority(line);\n    let emoji = priority_emoji(priority);\n    if completed {\n        println!(\"{} {} {} {}\", number.dimmed(), emoji, \"\u2705\".green(), text.green().strikethrough());\n    } else {\n        println!(\"{} {} {} {}\", number.dimmed(), emoji, \"\u23f3\".yellow(), text.bright_white());\n    }\n}\n\n// In search command - same 50+ lines duplicated!\n</code></pre></p> <p>After v1.0.0: Single reusable function <pre><code>// In list command\ndisplay_task(i + 1, line);\n\n// In search command  \ndisplay_task(*number, line);\n</code></pre></p> <p>Benefits:</p> <ul> <li>\u2705 DRY - Don't Repeat Yourself</li> <li>\u2705 Maintainable - Change once, affects everywhere</li> <li>\u2705 Testable - Can test display logic independently</li> <li>\u2705 Readable - Intent is clear from function name</li> </ul>"},{"location":"intermediate/v1.0.0-search-refactoring/#separation-of-concerns","title":"Separation of Concerns","text":"<p>Each function has one responsibility:</p> <pre><code>display_task()    // Render single task\ndisplay_lists()   // Render list with statistics\nextract_priority() // Parse priority from line\npriority_emoji()   // Get visual indicator\n</code></pre> <p>This is mature software architecture:</p> <ul> <li>Functions are composable</li> <li>Each can be tested independently</li> <li>Easy to modify individual pieces</li> <li>Clear interfaces between components</li> </ul>"},{"location":"intermediate/v1.0.0-search-refactoring/#search-ux-considerations","title":"Search UX Considerations","text":"<p>Empty results handling:</p> <pre><code>if results.is_empty() {\n    println!(\"No results for '{}'\", term);\n} else {\n    // Show results with count\n    println!(\"\\n{} result(s) found\\n\", results.len());\n}\n</code></pre> <p>Why show the search term in error?</p> <pre><code>$ todo search \"xyz\"\nNo results for 'xyz'  // Clear what was searched for\n</code></pre> <p>Why show result count?</p> <ul> <li>User knows if search was too broad or too narrow</li> <li>Helps refine search terms</li> <li>Sets expectations</li> </ul> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v1.0.0</li> <li>Full diff</li> </ul>"},{"location":"intermediate/v1.1.0-medium-priority-filter/","title":"v1.1.0 - Medium Priority Filter","text":"<p>\ud83c\udfaf Goal: Add <code>--medium</code> filter to complete priority filtering system</p> <p>\ud83d\udce6 Problem Identified:</p> <p>Users could create medium priority tasks but couldn't filter by them:</p> <pre><code># \u2705 Can create medium priority\ntodo add \"Normal task\"              # Creates as medium (default)\ntodo add \"Normal task\" --medium     # Future: explicit medium\n\n# \u274c Can't filter medium priority\ntodo list --high    # Works\ntodo list --low     # Works\ntodo list --medium  # Error: Invalid filter \u274c\n</code></pre> <p>This was a design flaw - asymmetry between creation and querying.</p> <p>\ud83d\udce6 Implementation:</p> <pre><code>\"list\" =&gt; {\n    // ... existing code ...\n\n    for arg in &amp;args[2..] {\n        match arg.as_str() {\n            \"--pending\" =&gt; { /* ... */ }\n            \"--done\" =&gt; { /* ... */ }\n            \"--high\" =&gt; {\n                if priority_filter.is_some() {\n                    return Err(\"Use only one priority filter (--high, --medium or --low)\".into());\n                }\n                priority_filter = Some(\"high\");\n            }\n            \"--medium\" =&gt; {  // \u2190 NEW\n                if priority_filter.is_some() {\n                    return Err(\"Use only one priority filter (--high, --medium or --low)\".into());\n                }\n                priority_filter = Some(\"medium\");\n            }\n            \"--low\" =&gt; {\n                if priority_filter.is_some() {\n                    return Err(\"Use only one priority filter (--high, --medium or --low)\".into());\n                }\n                priority_filter = Some(\"low\");\n            }\n            _ =&gt; return Err(format!(\"Invalid filter: {}\", arg).into()),\n        }\n    }\n\n    // ... filtering logic works automatically! ...\n\n    // Dynamic title updated\n    let title = match (status_filter, priority_filter) {\n        (\"pending\", Some(\"high\")) =&gt; \"High priority pending tasks\",\n        (\"pending\", Some(\"medium\")) =&gt; \"Medium priority pending tasks\",  // \u2190 NEW\n        (\"pending\", Some(\"low\")) =&gt; \"Low priority pending tasks\",\n        (\"pending\", None) =&gt; \"Pending tasks\",\n        (\"done\", Some(\"high\")) =&gt; \"High priority completed tasks\",\n        (\"done\", Some(\"medium\")) =&gt; \"Medium priority completed tasks\",  // \u2190 NEW\n        (\"done\", Some(\"low\")) =&gt; \"Low priority completed tasks\",\n        (\"done\", None) =&gt; \"Completed tasks\",\n        (_, Some(\"high\")) =&gt; \"High priority\",\n        (_, Some(\"medium\")) =&gt; \"Medium priority\",  // \u2190 NEW\n        (_, Some(\"low\")) =&gt; \"Low priority\",\n        _ =&gt; \"Tasks\",\n    };\n}\n</code></pre> <p>\ud83e\udde0 Key Concepts:</p>"},{"location":"intermediate/v1.1.0-medium-priority-filter/#api-completeness-principle","title":"API Completeness Principle","text":"<p>The problem: Incomplete feature set</p> <pre><code>// Creation API (complete)\ntodo add \"Task\"        // Creates medium\ntodo add \"Task\" --high  // Creates high\ntodo add \"Task\" --low   // Creates low\n\n// Query API (incomplete before v1.1.0)\ntodo list --high  // Works\ntodo list --low   // Works\ntodo list --medium // Missing! \u274c\n</code></pre> <p>The solution: Symmetric API design</p> <pre><code>// After v1.1.0 - complete symmetry\ntodo add \"Task\"        // Creates medium\ntodo add \"Task\" --high  // Creates high\ntodo add \"Task\" --low   // Creates low\n\ntodo list --high    // Queries high\ntodo list --medium  // Queries medium \u2705 NEW\ntodo list --low     // Queries low\n</code></pre> <p>Why this matters:</p> <ul> <li>Predictable - Users can guess what works</li> <li>Complete - No \"missing features\"</li> <li>Professional - Polished API design</li> </ul>"},{"location":"intermediate/v1.1.0-medium-priority-filter/#minimal-code-change","title":"Minimal Code Change","text":"<p>Amazing fact: Only added parsing logic, filtering worked automatically!</p> <pre><code>// extract_priority() already handled medium\nfn extract_priority(line: &amp;str) -&gt; (&amp;str, String) {\n    // ... \n    if without_checkbox.contains(\"(high)\") {\n        (\"high\", text)\n    } else if without_checkbox.contains(\"(low)\") {\n        (\"low\", text)\n    } else {\n        (\"medium\", without_checkbox)  // \u2190 Already worked!\n    }\n}\n\n// priority_emoji() already handled medium\nfn priority_emoji(priority: &amp;str) -&gt; String {\n    match priority {\n        \"high\" =&gt; \"\ud83d\udd34\".red().to_string(),\n        \"low\" =&gt; \"\ud83d\udfe2\".green().to_string(),\n        _ =&gt; \"\ud83d\udfe1\".yellow().to_string(),  // \u2190 Already worked for medium!\n    }\n}\n</code></pre> <p>This is good architecture:</p> <ul> <li>Functions were designed to handle all cases</li> <li>Adding new use case required minimal changes</li> <li>Existing code didn't need modification</li> </ul>"},{"location":"intermediate/v1.1.0-medium-priority-filter/#error-message-consistency","title":"Error Message Consistency","text":"<p>Updated all error messages to include \"medium\":</p> <pre><code>// Before\nreturn Err(\"Use only one priority filter (--high or --low)\".into());\n\n// After  \nreturn Err(\"Use only one priority filter (--high, --medium or --low)\".into());\n</code></pre> <p>Why this matters:</p> <ul> <li>Accurate - Error reflects actual capabilities</li> <li>Helpful - Shows user all valid options</li> <li>Consistent - All error messages updated</li> </ul>"},{"location":"intermediate/v1.1.0-medium-priority-filter/#pattern-matching-exhaustiveness","title":"Pattern Matching Exhaustiveness","text":"<p>The match expression was already ready:</p> <pre><code>let title = match (status_filter, priority_filter) {\n    // ... existing patterns ...\n    (\"pending\", Some(\"medium\")) =&gt; \"Medium priority pending tasks\",  // Just add\n    (\"done\", Some(\"medium\")) =&gt; \"Medium priority completed tasks\",   // Just add\n    (_, Some(\"medium\")) =&gt; \"Medium priority\",                       // Just add\n    // ... rest unchanged ...\n};\n</code></pre> <p>Rust's exhaustiveness checking helps:</p> <ul> <li>Compiler warns if patterns are missing</li> <li>Forces complete coverage</li> <li>Prevents runtime panics</li> </ul>"},{"location":"intermediate/v1.1.0-medium-priority-filter/#default-value-handling","title":"Default Value Handling","text":"<p>Medium is the \"default\" priority:</p> <pre><code>// In extract_priority()\nelse {\n    (\"medium\", without_checkbox)  // No explicit marker = medium\n}\n</code></pre> <p>This design choice:</p> <ul> <li>Common case - Most tasks are medium priority</li> <li>Simple - No flags needed for normal tasks</li> <li>Explicit - High/low require explicit flags</li> </ul>"},{"location":"intermediate/v1.1.0-medium-priority-filter/#user-experience-flow","title":"User Experience Flow","text":"<p>Complete user journey now possible:</p> <pre><code># 1. Add tasks with different priorities\n$ todo add \"Urgent bug fix\" --high\n$ todo add \"Documentation update\" --medium  \n$ todo add \"Code cleanup\" --low\n\n# 2. Filter by each priority level\n$ todo list --high\n\ud83d\udccb High priority:\n1. \ud83d\udd34 \u23f3 Urgent bug fix\n\n$ todo list --medium\n\ud83d\udccb Medium priority:\n1. \ud83d\udfe1 \u23f3 Documentation update\n\n$ todo list --low\n\ud83d\udccb Low priority:\n1. \ud83d\udfe2 \u23f3 Code cleanup\n</code></pre> <p>Before v1.1.0: <code>todo list --medium</code> would error After v1.1.0: Complete workflow works seamlessly</p>"},{"location":"intermediate/v1.1.0-medium-priority-filter/#testing-considerations","title":"Testing Considerations","text":"<p>What should be tested:</p> <pre><code>// Test that medium filter works\ntodo add \"Test task\"  // Creates medium\ntodo list --medium   // Should show the task\n\n// Test that medium tasks don't appear in other filters\ntodo list --high     // Should NOT show medium task\ntodo list --low      // Should NOT show medium task\n\n// Test error messages\ntodo list --medium --high  // Should error about multiple filters\n</code></pre> <p>Good architecture makes testing easy:</p> <ul> <li>Each filter is independent</li> <li>Error conditions are clear</li> <li>Expected behavior is well-defined</li> </ul>"},{"location":"intermediate/v1.1.0-medium-priority-filter/#future-extensibility","title":"Future Extensibility","text":"<p>Easy to add more priorities later:</p> <pre><code>// Future: add critical priority\n\"--critical\" =&gt; {\n    if priority_filter.is_some() {\n        return Err(\"Use only one priority filter (--critical, --high, --medium or --low)\".into());\n    }\n    priority_filter = Some(\"critical\");\n}\n\n// Update extract_priority()\nif without_checkbox.contains(\"(critical)\") {\n    (\"critical\", text)\n} else if without_checkbox.contains(\"(high)\") {\n    (\"high\", text)\n// ... etc\n\n// Update priority_emoji()\n\"critical\" =&gt; \"\ud83d\udea8\".red().bold().to_string(),\n</code></pre> <p>The pattern is established - just follow it.</p> <p>\ud83d\udd17 Resources:</p> <ul> <li>Code v1.1.0</li> <li>Full diff</li> </ul>"}]}