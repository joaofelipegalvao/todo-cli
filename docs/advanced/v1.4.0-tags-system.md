# v1.4.0 - Tags System

**ğŸ¯ Goal:** Add categorization system with tags and fix critical numbering bug

**ğŸ“¦ What We're Adding:**

**Tags for task organization:**

```bash
# Before - no categorization:
todo add "Study Rust" --high
todo add "Fix bug" --high
# How to separate work from personal? No way!

# After - with tags:
todo add "Study Rust" --high --tag learning --tag programming
todo add "Fix bug" --high --tag work --tag urgent
todo list --tag work  # Show only work tasks
```

**Why tags matter:**

âœ… **Categorization** - Group tasks by project, context, etc.  
âœ… **Flexible filtering** - Multiple tags per task  
âœ… **Easy to add** - Thanks to JSON/serde  
âœ… **Visual feedback** - Tags shown in list  
âœ… **Discovery** - `tags` command shows all tags  

**ğŸ§  Key Concepts:**

### Adding a field to existing struct

**This is where JSON/serde shines!**

```rust
// Before (v1.3.0):
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Task {
    text: String,
    completed: bool,
    priority: Priority,
}

// After (v1.4.0):
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Task {
    text: String,
    completed: bool,
    priority: Priority,
    tags: Vec<String>,  // â† Add ONE line
}
```

**That's it!** Serde handles everything automatically.

**Handling backward compatibility:**

```rust
// Problem: Old JSON doesn't have "tags" field
{
  "text": "Old task",
  "completed": false,
  "priority": "High"
  // Missing "tags"!
}

// Serde error: "missing field `tags`"
```

**Solution: Use `#[serde(default)]`:**

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Task {
    text: String,
    completed: bool,
    priority: Priority,
    #[serde(default)]  // â† Use Vec::default() if missing
    tags: Vec<String>,
}
```

**Now:**

- New tasks: `"tags": ["work"]` âœ…
- Old tasks: Missing field â†’ `tags: vec![]` âœ…

### `Vec<String>` for multiple values

**Why `Vec<String>` instead of single `String`?**

```rust
// âŒ Single tag - limited
tags: String  // Can only have one tag

// âœ… Multiple tags - flexible
tags: Vec<String>  // Can have many tags
```

**In JSON:**

```json
{
  "tags": ["learning", "programming"]
}
```

### Parsing multiple flags of same type

**Challenge:** Allow `--tag` multiple times:

```bash
todo add "Study Rust" --tag learning --tag programming --tag rust
```

**Solution: Loop and collect:**

```rust
let mut tags: Vec<String> = Vec::new();
let mut i = 3;  // Start after command and task text

while i < args.len() {
    match args[i].as_str() {
        "--high" => priority = Priority::High,
        "--medium" => priority = Priority::Medium,
        "--low" => priority = Priority::Low,
        "--tag" => {
            if i + 1 >= args.len() {
                return Err("--tag requires a value".into());
            }
            tags.push(args[i + 1].clone());  // Add tag to vector
            i += 1;  // Skip the tag value
        }
        _ => return Err(format!("Invalid flag: {}", args[i]).into()),
    }
    i += 1;
}
```

### Filtering with `retain()`

**Before (v1.3.0):** Creating new vectors

```rust
let mut valid_lines: Vec<&str> = all_lines
    .iter()
    .filter(|line| !line.is_empty())
    .copied()
    .collect();  // Creates NEW vector
```

**After (v1.4.0):** Modifying in-place

```rust
let mut indexed_tasks: Vec<(usize, &Task)> = /* ... */;

// Filter in-place
indexed_tasks.retain(|(_, t)| !t.completed);  // Removes items
```

**What's `.retain()`?**

```rust
vec.retain(|item| predicate);
// Keeps only items where predicate returns true
// Modifies vector IN PLACE
```

### The critical numbering bug

**The Problem:**

**Before fix:**

```rust
// Load all tasks
let tasks = load_tasks()?;  // [Task1, Task2, Task3, Task4, Task5]

// Filter to pending only
let pending: Vec<&Task> = tasks
    .iter()
    .filter(|t| !t.completed)
    .collect();
// Result: [Task1, Task3, Task5]

// Display with NEW numbering
for (i, task) in pending.iter().enumerate() {
    println!("{}. {}", i + 1, task.text);  // âŒ 1, 2, 3
}
// Output:
// 1. Task1  (was index 0)
// 2. Task3  (was index 2)
// 3. Task5  (was index 4)
```

**User sees:**

```bash
$ todo list --pending
1. Study Rust
2. Fix bug
3. Write docs

$ todo done 2  # User wants to mark "Fix bug" as done
```

**What actually happens:**

```rust
// "2" maps to index 1 in the FULL array
tasks[1].mark_done();  // Marks Task2, not Task3!
```

**Bug:** User marked the WRONG task! ğŸ›

**The Solution: Preserve original indices**

```rust
// Create tuples with ORIGINAL indices
let mut indexed_tasks: Vec<(usize, &Task)> = tasks
    .iter()
    .enumerate()
    .map(|(i, task)| (i + 1, task))  // Store (number, task)
    .collect();
// Result: [(1, Task1), (2, Task2), (3, Task3), (4, Task4), (5, Task5)]

// Filter while KEEPING original numbers
indexed_tasks.retain(|(_, t)| !t.completed);
// Result: [(1, Task1), (3, Task3), (5, Task5)]

// Display with ORIGINAL numbers
for (number, task) in &indexed_tasks {
    println!("{}. {}", number, task.text);  // âœ… 1, 3, 5
}
```

**User sees:**

```bash
$ todo list --pending
1. Study Rust
3. Fix bug      â† Original number preserved!
5. Write docs

$ todo done 3   # Correctly marks Task3
```

**Now it works!** âœ…

### New command: `tags`

**Purpose:** Show all tags in use with counts

```rust
"tags" => {
    let tasks = load_tasks()?;

    // Collect all unique tags
    let mut all_tags: Vec<String> = Vec::new();
    for task in &tasks {
        for tag in &task.tags {
            if !all_tags.contains(tag) {
                all_tags.push(tag.clone());
            }
        }
    }

    all_tags.sort();  // Alphabetical order

    println!("\n Tags:\n");
    for tag in &all_tags {
        let count = tasks.iter().filter(|t| t.tags.contains(tag)).count();
        println!(
            "  {} ({} task{})",
            tag.cyan(),
            count,
            if count == 1 { "" } else { "s" }  // Grammar!
        );
    }

    println!()
}
```

**Output:**

```bash
$ todo tags

 Tags:

  learning (1 task)
  urgent (2 tasks)
  work (2 tasks)
```

### Visual feedback for tags

**Updated `display_task()`:**

```rust
fn display_task(number: usize, task: &Task) {
    // ... priority and status display ...

    // Format tags
    let tags_str = if task.tags.is_empty() {
        String::new()  // No tags = empty string
    } else {
        format!(" [{}]", task.tags.join(", "))  // [tag1, tag2]
    };

    // Display with tags
    if task.completed {
        println!(
            "{} {} {} {}{}",
            number_fmt.dimmed(),
            emoji,
            "âœ…".green(),
            task.text.green().strikethrough(),
            tags_str.dimmed()  // â† Dimmed for completed
        );
    } else {
        println!(
            "{} {} {} {}{}",
            number_fmt.dimmed(),
            emoji,
            "â³".yellow(),
            task.text.bright_white(),
            tags_str.cyan()  // â† Cyan for pending
        );
    }
}
```

**Output examples:**

```bash
# Completed task with tags
1. ğŸ”´ âœ… Study Rust [learning, programming]
                   â†‘ dimmed

# Pending task with tags
2. ğŸŸ¡ â³ Fix bug [work, urgent]
             â†‘ cyan (stands out)

# Task without tags
3. ğŸŸ¢ â³ Buy coffee
```

**ğŸ”— Resources:**

- [Code v1.4.0](https://github.com/joaofelipegalvao/todo-cli/tree/v1.4.0)
- [Full diff](https://github.com/joaofelipegalvao/todo-cli/compare/v1.3.0...v1.4.0)