# v0.9.0 - Priority Sorting

**ðŸŽ¯ Goal:** Sort tasks by priority (high â†’ medium â†’ low)

**ðŸ“¦ Key Implementation:**

**Priority mapping function:**

```rust
fn priority_order(pri: &str) -> u8 {
    match pri {
        "high" => 0,      // First
        "medium" => 1,    // Middle
        "low" => 2,       // Last
        _ => 3,           // Unknown (end)
    }
}
```

**Sort flag handling:**

```rust
"list" => {
    let mut status_filter = "all";
    let mut priority_filter: Option<&str> = None;
    let mut sort = false;  // â† NEW

    for arg in &args[2..] {
        match arg.as_str() {
            // ... other flags ...
            "--sort" => {
                if sort {
                    return Err("Use --sort only once.".into());
                }
                sort = true;
            }
            _ => return Err(format!("Invalid filter: {}", arg).into()),
        }
    }

    // ... filter tasks ...

    // Sort AFTER filtering (optimization!)
    if sort {
        valid_lines.sort_by(|a, b| {
            let (pri_a, _) = extract_priority(a);
            let (pri_b, _) = extract_priority(b);
            priority_order(pri_a).cmp(&priority_order(pri_b))
        });
    }
    
    // ... display ...
}
```

**ðŸ§  Key Concepts:**

### Numeric Priority Mapping

```rust
fn priority_order(pri: &str) -> u8 {
    match pri {
        "high" => 0,      // First (highest priority)
        "medium" => 1,    // Middle
        "low" => 2,       // Last (lowest priority)
        _ => 3,           // Unknown (end)
    }
}
```

**Why numbers instead of strings?**

```rust
// String comparison doesn't work for priority order
"high" > "low"    // true alphabetically, but wrong for priority!
"medium" > "high" // true alphabetically, but wrong!

// Numeric comparison works correctly
0 < 1 < 2 < 3     // Perfect for sorting!
```

**Why `u8`?**

- Small range (0-255) - perfect for 4 priority levels
- Memory efficient
- Fast comparisons

### The `.sort_by()` Method

```rust
valid_lines.sort_by(|a, b| {
    let (pri_a, _) = extract_priority(a);
    let (pri_b, _) = extract_priority(b);
    priority_order(pri_a).cmp(&priority_order(pri_b))
});
```

**Breaking it down:**

```rust
|a, b|  // Closure - takes two elements to compare
{
    let (pri_a, _) = extract_priority(a);  // Get priority of first
    let (pri_b, _) = extract_priority(b);  // Get priority of second
    priority_order(pri_a).cmp(&priority_order(pri_b))  // Compare
}
```

**The `.cmp()` method:**

```rust
priority_order(pri_a).cmp(&priority_order(pri_b))
// Returns: Ordering::Less, Ordering::Equal, or Ordering::Greater
```

**How `.sort_by()` uses this:**

- If `cmp()` returns `Less` - `a` comes before `b`
- If `cmp()` returns `Equal` - order doesn't matter
- If `cmp()` returns `Greater` - `b` comes before `a`

### Performance Optimization

**Key insight: Sort AFTER filtering**

```rust
// âŒ Bad: Sort first, then filter
let all_tasks = read_all_tasks();           // 100 tasks
all_tasks.sort_by(...);                     // O(100 log 100)
let filtered = filter_tasks(all_tasks);    // 10 tasks

// âœ… Good: Filter first, then sort
let all_tasks = read_all_tasks();           // 100 tasks
let filtered = filter_tasks(all_tasks);    // 10 tasks
filtered.sort_by(...);                      // O(10 log 10)
```

**Why this matters:**

```
O(100 log 100) â‰ˆ 664 comparisons
O(10 log 10)   â‰ˆ 33 comparisons
20x faster! ðŸš€
```

**Real-world impact:**

- Small lists (10-50 tasks): Minor improvement
- Large lists (1000+ tasks): Major improvement
- Always good practice for data pipelines

### Closure Syntax Deep Dive

```rust
|a, b| {
    // closure body
}
```

**This is equivalent to:**

```rust
fn compare_closure(a: &str, b: &str) -> std::cmp::Ordering {
    let (pri_a, _) = extract_priority(a);
    let (pri_b, _) = extract_priority(b);
    priority_order(pri_a).cmp(&priority_order(pri_b))
}

// Used as:
valid_lines.sort_by(compare_closure);
```

**Why use closure instead of named function?**

- **Concise** - Defined inline where used
- **Captures context** - Can access variables from scope
- **Standard pattern** - idiomatic Rust for `.sort_by()`

### Sorting Stability

**What happens with equal priorities?**

```rust
// Tasks with same priority maintain original order
"[ ] (high) Task A"  // Original position 1
"[ ] (high) Task B"  // Original position 3
// After sort: Task A still comes before Task B
```

**This is "stable sorting"** - Rust's `.sort_by()` is stable.

**Why stability matters:**

- Predictable results
- Preserves chronological order within priority
- Better user experience

### Error Handling for Sort Flag

```rust
"--sort" => {
    if sort {
        return Err("Use --sort only once.".into());
    }
    sort = true;
}
```

**Why prevent duplicate `--sort`?**

```bash
# This would be confusing
todo list --sort --sort --high
# Which sort takes effect? Both? First? Last?
```

**Clear error message:**

- Tells user what's wrong
- Explains the constraint
- Prevents ambiguous behavior

### Integration with Existing Pipeline

**How sorting fits into the pipeline:**

```rust
// 1. Read file
let content = fs::read_to_string("todos.txt")?;

// 2. Filter empty lines
let valid_lines: Vec<&str> = content.lines()...collect();

// 3. Filter by status (--pending/--done)
valid_lines = filter_by_status(valid_lines, status_filter);

// 4. Filter by priority (--high/--low)
valid_lines = filter_by_priority(valid_lines, priority_filter);

// 5. Sort by priority (--sort) â† NEW
if sort {
    valid_lines.sort_by(...);
}

// 6. Display
display_tasks(&valid_lines, title);
```

**Each stage is independent and composable.**

### Future Extensibility

**Easy to add more sorting options:**

```rust
// Future: sort by due date
"--sort-due" => {
    valid_lines.sort_by(|a, b| {
        extract_due_date(a).cmp(&extract_due_date(b))
    });
}

// Future: sort by creation date
"--sort-created" => {
    valid_lines.sort_by(|a, b| {
        extract_created_date(a).cmp(&extract_created_date(b))
    });
}
```

**The pattern is established - just add new sort functions.**

**ðŸ”— Resources:**

- [Code v0.9.0](https://github.com/joaofelipegalvao/todo-cli/tree/v0.9.0)
- [Full diff](https://github.com/joaofelipegalvao/todo-cli/compare/v0.8.0...v0.9.0)