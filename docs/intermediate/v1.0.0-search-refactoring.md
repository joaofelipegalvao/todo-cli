# v1.0.0 - Search + Display Refactoring

**ğŸ¯ Goal:** Add search command and refactor display into atomic/orchestrated functions

**ğŸ“¦ Key Implementations:**

**Atomic rendering function:**

```rust
fn display_task(number: usize, line: &str) {
    let number_fmt = format!("{}.", number);
    let completed = line.contains("[x]");

    let (priority, text) = extract_priority(line);
    let emoji = priority_emoji(priority);

    if completed {
        println!(
            "{} {} {} {}",
            number_fmt.dimmed(),
            emoji,
            "âœ…".green(),
            text.green().strikethrough()
        );
    } else {
        println!(
            "{} {} {} {}",
            number_fmt.dimmed(),
            emoji,
            "â³".yellow(),
            text.bright_white()
        );
    }
}
```

**Orchestrated rendering function (renamed):**

```rust
fn display_lists(tasks: &[&str], title: &str) {
    println!("\nğŸ“‹ {}:\n", title);

    let mut completed = 0;
    let total = tasks.len();

    for (i, line) in tasks.iter().enumerate() {
        display_task(i + 1, line);  // â† Uses atomic function

        if line.contains("[x]") {
            completed += 1;
        }
    }

    // ... statistics ...
}
```

**Search command:**

```rust
"search" => {
    if args.len() < 3 {
        return Err("Usage: todo search <term>".into());
    }

    let term = &args[2];

    match fs::read_to_string("todos.txt") {
        Ok(content) => {
            let valid_lines: Vec<&str> = content
                .lines()
                .filter(|l| !l.trim().is_empty())
                .collect();

            if valid_lines.is_empty() {
                println!("No tasks");
                return Ok(());
            }

            let mut results: Vec<(usize, &str)> = Vec::new();

            for (i, line) in valid_lines.iter().enumerate() {
                if line.to_lowercase().contains(&term.to_lowercase()) {
                    results.push((i + 1, line));  // Keep original number!
                }
            }

            if results.is_empty() {
                println!("No results for '{}'", term);
            } else {
                println!("\nğŸ“‹ Results for \"{}\":\n", term);

                for (number, line) in &results {
                    display_task(*number, line);  // â† Uses atomic function
                }

                println!("\n{} result(s) found\n", results.len());
            }
        }
        Err(_) => {
            println!("No tasks");
        }
    }
}
```

**ğŸ§  Key Design:**

### Atomic vs Orchestrated Functions

**Atomic function - `display_task()`:**
- Renders **ONE** task
- Takes specific task number
- No statistics
- Reusable across contexts

**Orchestrated function - `display_lists()`:**
- Renders **LIST** of tasks
- Handles numbering internally
- Calculates statistics
- Manages overall layout

**Why this separation?**

```rust
// List command - needs statistics and sequential numbering
display_lists(&tasks, "Tasks");

// Search command - needs original numbering, no statistics
for (number, line) in &results {
    display_task(*number, line);
}
```

### Preserving Original Task Numbers

**Critical design decision for search:**

```rust
for (i, line) in valid_lines.iter().enumerate() {
    if line.to_lowercase().contains(&term.to_lowercase()) {
        results.push((i + 1, line));  // â† Original number!
    }
}
```

**Why this matters:**

```bash
$ todo list
1. [ ] Buy milk
2. [ ] Call mom
3. [ ] Learn Rust

$ todo search "rust"
ğŸ“‹ Results for "rust":
3. [ ] Learn Rust  â† Shows as #3, not #1!

$ todo done 3      # User can use the original number!
âœ“ Task marked as completed
```

**Without original numbering:**

```rust
// Wrong approach - renumbers search results
for (i, line) in search_results.iter().enumerate() {
    display_task(i + 1, line);  // Shows as #1, but is really #3!
}

// User tries: todo done 1
// Error: Invalid task number! âŒ
```

### Case-Insensitive Search

```rust
line.to_lowercase().contains(&term.to_lowercase())
```

**Why convert both sides:**

```rust
// Case-sensitive search (bad)
"Learn Rust".contains("rust")  // false âŒ
"learn rust".contains("RUST")  // false âŒ

// Case-insensitive search (good)
"Learn Rust".to_lowercase().contains("rust".to_lowercase())  // true âœ…
"learn rust".to_lowercase().contains("RUST".to_lowercase())  // true âœ…
```

**User experience:**

```bash
$ todo search "RUST"
ğŸ“‹ Results for "RUST":
3. [ ] Learn Rust

$ todo search "rust"
ğŸ“‹ Results for "rust":
3. [ ] Learn Rust

$ todo search "LeArN"
ğŸ“‹ Results for "LeArN":
3. [ ] Learn Rust
```

All work the same - much more forgiving!

### Tuple Vec for Search Results

```rust
let mut results: Vec<(usize, &str)> = Vec::new();
//                â†‘ tuple of (original_number, task_line)

results.push((i + 1, line));
```

**Why store tuples instead of just lines?**

```rust
// Option 1: Just lines
let results: Vec<&str> = vec!["[ ] Learn Rust"];
// Lost original number information!

// Option 2: Tuples (chosen)
let results: Vec<(usize, &str)> = vec![(3, "[ ] Learn Rust")];
// Keep both number and line!
```

**Destructuring in display:**

```rust
for (number, line) in &results {
    display_task(*number, line);
}
//  â†‘ number    â†‘ line
```

### Function Refactoring Benefits

**Before v1.0.0:** Display code was duplicated
```rust
// In list command - 50+ lines
for (i, line) in tasks.iter().enumerate() {
    let number = format!("{}.", i + 1);
    let completed = line.contains("[x]");
    let (priority, text) = extract_priority(line);
    let emoji = priority_emoji(priority);
    if completed {
        println!("{} {} {} {}", number.dimmed(), emoji, "âœ…".green(), text.green().strikethrough());
    } else {
        println!("{} {} {} {}", number.dimmed(), emoji, "â³".yellow(), text.bright_white());
    }
}

// In search command - same 50+ lines duplicated!
```

**After v1.0.0:** Single reusable function
```rust
// In list command
display_task(i + 1, line);

// In search command  
display_task(*number, line);
```

**Benefits:**

- âœ… **DRY** - Don't Repeat Yourself
- âœ… **Maintainable** - Change once, affects everywhere
- âœ… **Testable** - Can test display logic independently
- âœ… **Readable** - Intent is clear from function name

### Separation of Concerns

**Each function has one responsibility:**

```rust
display_task()    // Render single task
display_lists()   // Render list with statistics
extract_priority() // Parse priority from line
priority_emoji()   // Get visual indicator
```

**This is mature software architecture:**

- Functions are composable
- Each can be tested independently
- Easy to modify individual pieces
- Clear interfaces between components

### Search UX Considerations

**Empty results handling:**

```rust
if results.is_empty() {
    println!("No results for '{}'", term);
} else {
    // Show results with count
    println!("\n{} result(s) found\n", results.len());
}
```

**Why show the search term in error?**

```bash
$ todo search "xyz"
No results for 'xyz'  // Clear what was searched for
```

**Why show result count?**

- User knows if search was too broad or too narrow
- Helps refine search terms
- Sets expectations

**ğŸ”— Resources:**

- [Code v1.0.0](https://github.com/joaofelipegalvao/todo-cli/tree/v1.0.0)
- [Full diff](https://github.com/joaofelipegalvao/todo-cli/compare/v0.9.0...v1.0.0)