# v1.7.0 - Professional Error Handling with `anyhow` and `thiserror`

**üéØ Goal:** Transform generic error messages into professional, informative error handling

**üì¶ The Problem We're Solving:**

**Before v1.7.0 - Generic error handling:**

```rust
fn load_tasks() -> Result<Vec<Task>, Box<dyn Error>> {
    let content = fs::read_to_string("todos.json")?;
    let tasks: Vec<Task> = serde_json::from_str(&content)?;
    Ok(tasks)
}
```

**User sees:**

```bash
$ todo list
Error: No such file or directory (os error 2)
# Where? What file? How to fix?
```

**Problems:**

‚ùå Generic error messages  
‚ùå No context about what operation failed  
‚ùå Can't distinguish error types programmatically  
‚ùå No error chains (root cause lost)  
‚ùå Stack traces not helpful  

**After v1.7.0 - Professional error handling:**

```rust
fn load_tasks() -> Result<Vec<Task>> {
    match fs::read_to_string("todos.json") {
        Ok(content) => serde_json::from_str(&content)
            .context("Failed to parse todos.json - file may be corrupted"),
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => Ok(Vec::new()),
        Err(e) => Err(e).context(format!(
            "Failed to read todos.json from current directory: {}",
            std::env::current_dir().unwrap_or_default().display()
        )),
    }
}
```

**User sees:**

```bash
$ todo list
Error: Failed to parse todos.json - file may be corrupted
Caused by: EOF while parsing a value at line 8 column 3
# Clear what went wrong and why!
```

**Benefits:**

‚úÖ **Specific error messages** - Clear what failed  
‚úÖ **Rich context** - Where and why it failed  
‚úÖ **Error chains** - See the full cause  
‚úÖ **Typed errors** - Match on specific error types  
‚úÖ **Professional UX** - Helpful to users  

---

## üß† Key Concepts

### The Difference: `anyhow` vs `thiserror`

**Two crates, two purposes:**

| Crate | When to Use | Example |
|-------|-------------|---------|
| **anyhow** | Application errors (infrastructure) | File I/O, parsing, network |
| **thiserror** | Library errors (domain logic) | Invalid task ID, business rules |

### `anyhow` - Application Error Context

**Use for external/infrastructure failures:**

```rust
use anyhow::{Context, Result};

fn load_tasks() -> Result<Vec<Task>> {
    fs::read_to_string("todos.json")
        .context("Failed to read todos.json")?
}
```

**What `.context()` does:**

```rust
// Without context
Err("No such file or directory")

// With context
Err("Failed to read todos.json")
Caused by: No such file or directory (os error 2)
```

**Key features:**

- ‚úÖ Easy to add context with `.context()`
- ‚úÖ Automatic error chain display
- ‚úÖ Works with any error type
- ‚úÖ Zero boilerplate

### `thiserror` - Custom Domain Errors

**Use for business logic errors:**

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum TodoError {
    #[error("Task ID {id} is invalid (valid range: 1-{max})")]
    InvalidTaskId { id: usize, max: usize },

    #[error("Task #{id} is already marked as {status}")]
    TaskAlreadyInStatus { id: usize, status: String },

    #[error("Tag '{0}' not found in any task")]
    TagNotFound(String),
}
```

**Usage:**

```rust
fn validate_task_id(id: usize, max: usize) -> Result<(), TodoError> {
    if id == 0 || id > max {
        return Err(TodoError::InvalidTaskId { id, max });
    }
    Ok(())
}
```

**Output:**

```bash
$ todo done 15
Error: Task ID 15 is invalid (valid range: 1-10)
```

**Key features:**

- ‚úÖ Type-safe error variants
- ‚úÖ Automatic `Display` implementation
- ‚úÖ Rich data in errors (id, max, etc.)
- ‚úÖ Pattern matching support

---

## üì¶ Implementation Steps

### Step 1: Add Dependencies

**In `Cargo.toml`:**

```toml
[dependencies]
colored = "2.1"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
clap = { version = "4.5", features = ["derive"] }
anyhow = "1.0"      # ‚Üê NEW: Application errors
thiserror = "1.0"   # ‚Üê NEW: Custom errors
```

### Step 2: Update Imports

**In `main.rs`:**

```rust
use std::{fs, process};

use anyhow::{Context, Result};  // ‚Üê NEW
use chrono::{Local, NaiveDate};
use clap::{Args, Parser, Subcommand, ValueEnum};
use colored::{ColoredString, Colorize};
use serde::{Deserialize, Serialize};
use thiserror::Error;  // ‚Üê NEW
```

**What each import does:**

| Import | Purpose |
|--------|---------|
| `anyhow::Context` | Adds `.context()` method to Results |
| `anyhow::Result` | Shorthand for `Result<T, anyhow::Error>` |
| `thiserror::Error` | Derive macro for custom errors |

### Step 3: Define Custom Error Types

**Add before `main()`:**

```rust
#[derive(Error, Debug)]
pub enum TodoError {
    #[error("Task ID {id} is invalid (valid range: 1-{max})")]
    InvalidTaskId { id: usize, max: usize },

    #[error("Task #{id} is already marked as {status}")]
    TaskAlreadyInStatus { id: usize, status: String },

    #[error("Tag '{0}' not found in any task")]
    TagNotFound(String),

    #[error("No tasks found matching the specified filters")]
    NoTasksFound,

    #[error("No tags found in any task")]
    NoTagsFound,

    #[error("Search returned no results for query: '{0}'")]
    NoSearchResults(String),
}
```

**Anatomy of an error variant:**

```rust
#[error("Task ID {id} is invalid (valid range: 1-{max})")]
//      ‚Üë Display message with field interpolation
InvalidTaskId { id: usize, max: usize },
//              ‚Üë Fields available in error
```

**Creating errors:**

```rust
// Struct-like variant
TodoError::InvalidTaskId { id: 15, max: 10 }
// Message: "Task ID 15 is invalid (valid range: 1-10)"

// Tuple variant
TodoError::TagNotFound("urgent".to_string())
// Message: "Tag 'urgent' not found in any task"

// Unit variant
TodoError::NoTasksFound
// Message: "No tasks found matching the specified filters"
```

### Step 4: Enhanced Error Display in `main()`

**Before:**

```rust
fn main() {
    let cli = Cli::parse();
    
    if let Err(e) = run(cli) {
        eprintln!("Error: {}", e);
        process::exit(1);
    }
}
```

**After:**

```rust
fn main() {
    let cli = Cli::parse();

    if let Err(e) = run(cli) {
        // Main error message
        eprintln!("{} {}", "Error:".red().bold(), format!("{}", e).red());

        // Error chain (causes)
        let mut source = e.source();
        while let Some(cause) = source {
            eprintln!("{} {}", "Caused by:".red(), cause);
            source = cause.source();
        }

        process::exit(1);
    }
}
```

**What this displays:**

```bash
Error: Failed to parse todos.json - file may be corrupted
Caused by: EOF while parsing a value at line 8 column 3
```

**The error chain:**

```rust
e.source()  // Returns Option<&dyn Error>
```

- First call returns immediate cause
- Subsequent calls walk up the chain
- Returns `None` when no more causes

### Step 5: Update `load_tasks()` with Context

**Before:**

```rust
fn load_tasks() -> Result<Vec<Task>, Box<dyn Error>> {
    match fs::read_to_string("todos.json") {
        Ok(content) => {
            let tasks: Vec<Task> = serde_json::from_str(&content)?;
            Ok(tasks)
        }
        Err(_) => Ok(Vec::new()),
    }
}
```

**After:**

```rust
fn load_tasks() -> Result<Vec<Task>> {
    match fs::read_to_string("todos.json") {
        Ok(content) => serde_json::from_str(&content)
            .context("Failed to parse todos.json - file may be corrupted"),
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => Ok(Vec::new()),
        Err(e) => Err(e).context(format!(
            "Failed to read todos.json from current directory: {}",
            std::env::current_dir().unwrap_or_default().display()
        )),
    }
}
```

**Key improvements:**

1. **Result type:** `Result<Vec<Task>, Box<dyn Error>>` ‚Üí `Result<Vec<Task>>`
2. **Parse error context:** Tells user the file is corrupted
3. **Specific NotFound handling:** Empty list for missing file
4. **Read error context:** Shows current directory in error

**Pattern matching on IO errors:**

```rust
Err(e) if e.kind() == std::io::ErrorKind::NotFound => Ok(Vec::new())
```

- Match guard checks error kind
- Only `NotFound` returns empty list
- Other IO errors propagate with context

### Step 6: Update `save_tasks()` with Context

**Before:**

```rust
fn save_tasks(tasks: &[Task]) -> Result<(), Box<dyn Error>> {
    let json = serde_json::to_string_pretty(tasks)?;
    fs::write("todos.json", json)?;
    Ok(())
}
```

**After:**

```rust
fn save_tasks(tasks: &[Task]) -> Result<()> {
    let json = serde_json::to_string_pretty(tasks)
        .context("Failed to serialize tasks to JSON")?;

    fs::write("todos.json", json)
        .context("Failed to write to todos.json - check file permissions")?;

    Ok(())
}
```

**Each operation gets specific context:**

```bash
# If serialization fails:
Error: Failed to serialize tasks to JSON
Caused by: recursion limit exceeded

# If write fails:
Error: Failed to write to todos.json - check file permissions
Caused by: Permission denied (os error 13)
```

### Step 7: Create Validation Function

**Add helper function:**

```rust
fn validate_task_id(id: usize, max: usize) -> Result<(), TodoError> {
    if id == 0 || id > max {
        return Err(TodoError::InvalidTaskId { id, max });
    }
    Ok(())
}
```

**Return type breakdown:**

```rust
Result<(), TodoError>
//     ‚Üë  ‚Üë
//     |  Custom error type
//     Unit type (success returns nothing)
```

**Why return `()`?**

- Validation either succeeds or fails
- Success doesn't need to return data
- Failure returns rich error information

### Step 8: Update Commands with Typed Errors

**Example: `done` command:**

**Before:**

```rust
Commands::Done { id } => {
    let mut tasks = load_tasks()?;
    
    if id == 0 || id > tasks.len() {
        eprintln!("Error: Invalid task ID");
        process::exit(1);
    }
    
    let index = id - 1;
    tasks[index].mark_done();
    save_tasks(&tasks)?;
    println!("{}", "‚úì Task marked as completed".green());
}
```

**After:**

```rust
Commands::Done { id } => {
    let mut tasks = load_tasks()?;
    validate_task_id(id, tasks.len())?;  // ‚Üê Typed validation
    let index = id - 1;

    // Check if already completed
    if tasks[index].completed {
        return Err(TodoError::TaskAlreadyInStatus {
            id,
            status: "completed".to_owned(),
        }
        .into());  // ‚Üê Convert TodoError ‚Üí anyhow::Error
    }

    tasks[index].mark_done();
    save_tasks(&tasks)?;
    println!("{}", "‚úì Task marked as completed".green());
}
```

**Key changes:**

1. **Typed validation:** `validate_task_id()` returns `TodoError`
2. **State check:** Prevents marking already completed tasks
3. **Error conversion:** `.into()` converts `TodoError` ‚Üí `anyhow::Error`

**The `.into()` conversion:**

```rust
TodoError::TaskAlreadyInStatus { id, status }
    .into()  // TodoError ‚Üí anyhow::Error
```

Works because `anyhow::Error` accepts any type implementing `std::error::Error`, which `thiserror` automatically implements.

### Step 9: Update All Commands

**Pattern for each command:**

```rust
Commands::Undone { id } => {
    let mut tasks = load_tasks()?;
    validate_task_id(id, tasks.len())?;
    let index = id - 1;

    if !tasks[index].completed {
        return Err(TodoError::TaskAlreadyInStatus {
            id,
            status: "pending".to_owned(),
        }
        .into());
    }

    tasks[index].mark_undone();
    save_tasks(&tasks)?;
    println!("{}", "‚úì Task unmarked".yellow());
}
```

**For `list` command:**

```rust
// At the end, after filtering
if indexed_tasks.is_empty() {
    return Err(TodoError::NoTasksFound.into());
}
```

**For `search` command:**

```rust
if results.is_empty() {
    return Err(TodoError::NoSearchResults(query).into());
}
```

**For `tags` command:**

```rust
if all_tags.is_empty() {
    return Err(TodoError::NoTagsFound.into());
}
```

### Step 10: Update Function Signatures

**Change all `Result<T, Box<dyn Error>>` to `Result<T>`:**

```rust
// Before
fn run(cli: Cli) -> Result<(), Box<dyn Error>>
fn load_tasks() -> Result<Vec<Task>, Box<dyn Error>>
fn save_tasks(tasks: &[Task]) -> Result<(), Box<dyn Error>>

// After
fn run(cli: Cli) -> Result<()>
fn load_tasks() -> Result<Vec<Task>>
fn save_tasks(tasks: &[Task]) -> Result<()>
```

---

## üß™ Testing Error Messages

### 1. Invalid Task ID

```bash
$ todo done 999
Error: Task ID 999 is invalid (valid range: 1-5)
```

### 2. Already Completed

```bash
$ todo done 1
‚úì Task marked as completed

$ todo done 1
Error: Task #1 is already marked as completed
```

### 3. Tag Not Found

```bash
$ todo list --tag nonexistent
Error: Tag 'nonexistent' not found in any task
```

### 4. Search No Results

```bash
$ todo search "xyzabc"
Error: Search returned no results for query: 'xyzabc'
```

### 5. Corrupted JSON

Edit `todos.json` to be invalid:

```bash
$ todo list
Error: Failed to parse todos.json - file may be corrupted
Caused by: EOF while parsing a value at line 3 column 5
```

### 6. Permission Denied

```bash
$ chmod 000 todos.json
$ todo list
Error: Failed to read todos.json from current directory: /home/user/projects
Caused by: Permission denied (os error 13)
```

---

## üìä Impact Summary

### Before v1.7.0

‚ùå Generic errors: `"Error: No such file or directory"`  
‚ùå Lost context: User doesn't know what operation failed  
‚ùå Process::exit scattered: Hard to maintain  
‚ùå String-based errors: Can't distinguish types  
‚ùå No error chains: Root cause lost  

### After v1.7.0

‚úÖ Specific errors: `"Task ID 15 is invalid (valid range: 1-10)"`  
‚úÖ Rich context: `"Failed to parse todos.json - file may be corrupted"`  
‚úÖ Error chains: See full cause with `"Caused by:"`  
‚úÖ Typed errors: Pattern match on `TodoError` variants  
‚úÖ Clean propagation: Use `?` operator everywhere  

### Code Quality Improvements

| Metric | Before | After |
|--------|--------|-------|
| Error types | Generic `Box<dyn Error>` | Specific `TodoError` + `anyhow` |
| Context | None | Rich with `.context()` |
| Error chains | Lost | Full chain displayed |
| User messages | Generic | Specific and helpful |
| Maintainability | Scattered exits | Clean propagation |

---

## üéØ Best Practices

### 1. Use `anyhow` for Application Code

```rust
// Good: Quick context for infrastructure errors
fs::read_to_string("todos.json")
    .context("Failed to read todos.json")?
```

### 2. Use `thiserror` for Domain Errors

```rust
// Good: Rich typed errors for business logic
if id == 0 || id > max {
    return Err(TodoError::InvalidTaskId { id, max });
}
```

### 3. Add Context at Every Layer

```rust
// Good: Each layer adds context
serde_json::from_str(&content)
    .context("Failed to parse todos.json - file may be corrupted")?
```

### 4. Pattern Match on Specific Errors

```rust
// Good: Handle specific error types differently
match fs::read_to_string("todos.json") {
    Ok(content) => { /* ... */ }
    Err(e) if e.kind() == ErrorKind::NotFound => Ok(Vec::new()),
    Err(e) => Err(e).context("Failed to read file"),
}
```

### 5. Convert Between Error Types

```rust
// Good: Custom errors convert to anyhow
TodoError::InvalidTaskId { id, max }
    .into()  // TodoError ‚Üí anyhow::Error
```

---

## üîó Resources

- [Code v1.7.0](https://github.com/joaofelipegalvao/todo-cli/tree/v1.7.0)
- [Full diff](https://github.com/joaofelipegalvao/todo-cli/compare/v1.6.0...v1.7.0)
- [anyhow documentation](https://docs.rs/anyhow/)
- [thiserror documentation](https://docs.rs/thiserror/)
- [Rust Error Handling Book](https://doc.rust-lang.org/book/ch09-00-error-handling.html)

---

## üéì Learning Outcomes

After implementing v1.7.0, you understand:

1. **Error Context:** How to add rich context to errors
2. **Error Chains:** How errors propagate through the call stack
3. **Custom Errors:** Creating domain-specific error types
4. **Error Conversion:** Converting between error types
5. **Professional UX:** Providing helpful error messages
6. **Type Safety:** Using types to distinguish error cases
7. **Clean Propagation:** Using `?` instead of manual handling

**This is production-ready error handling!** üéâ
