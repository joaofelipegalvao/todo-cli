# v0.4.0 - Undone Command

**ğŸ¯ Goal:** Unmark completed tasks (reverse of `done`)

**ğŸ“¦ Implementation:**

```rust
"undone" => {
    if args.len() < 3 {
        return Err("Usage: todo undone <number>".into());
    }
    
    let number: usize = args[2].parse()?;
    let content = fs::read_to_string("todos.txt")?;
    let mut lines: Vec<String> = content.lines().map(|l| l.to_string()).collect();
    
    if number == 0 || number > lines.len() {
        return Err("Invalid task number".into());
    }
    
    let index = number - 1;
    lines[index] = lines[index].replace("[x]", "[ ]");  // â† Reverse!
    
    fs::write("todos.txt", lines.join("\n") + "\n")?;
    println!("âœ“ Task unmarked");
}
```

**ğŸ§  Key Concepts:**

### Inverse operations

```rust
// done: marks as completed
lines[index].replace("[ ]", "[x]")

// undone: marks as pending  
lines[index].replace("[x]", "[ ]")
```

**This is the power of simple data representation:**

- State is just text: `"[ ]"` or `"[x]"`
- Changing state is just string replacement
- Inverse operation is trivial

**Alternative design (that would be more complex):**

```rust
// If we had stored status separately:
struct Task {
    text: String,
    completed: bool,  // Now we need struct, serialization, etc.
}
```

**Our choice:** Keep it simple - plain text format enables easy state changes.

### Code duplication notice

**Look at the pattern:**

```rust
// done, undone, and remove all have:
if args.len() < 3 { return Err(...); }
let number: usize = args[2].parse()?;
let content = fs::read_to_string("todos.txt")?;
let mut lines: Vec<String> = content.lines().map(|l| l.to_string()).collect();
if number == 0 || number > lines.len() { return Err(...); }
let index = number - 1;
// ... specific operation ...
fs::write("todos.txt", lines.join("\n") + "\n")?;
```

**This duplication is intentional at this stage:**

- âœ… Learning step-by-step
- âœ… Each command is self-contained
- âœ… Easy to understand

**Later (v1.0.0+), this will be refactored** into helper functions. For now, repetition helps learning.

### Boolean logic in action

The command structure now forms a **state machine:**

```
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ Pending â”‚
      â”‚  [ ]    â”‚
      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
           â”‚
     done   â”‚   undone
     â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€
           â”‚
      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
      â”‚Completedâ”‚
      â”‚  [x]    â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Tasks can toggle between states, and `remove` deletes from any state.

**ğŸ”— Resources:**

- [Code v0.4.0](https://github.com/joaofelipegalvao/todo-cli/tree/v0.4.0)
- [Full diff](https://github.com/joaofelipegalvao/todo-cli/compare/v0.3.0...v0.4.0)