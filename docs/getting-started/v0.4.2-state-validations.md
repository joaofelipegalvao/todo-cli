# v0.4.2 - State Validations

**ğŸ¯ Goal:** Prevent invalid state transitions with specific error messages

**ğŸ“¦ Implementation:**

**Validation in `done` command:**

```rust
"done" => {
    // ... parsing and validation ...
    
    let index = number - 1;
    
    // âœ… NEW: Check if already completed
    if lines[index].contains("[x]") {
        return Err("Task is already marked as completed".into());
    }
    
    lines[index] = lines[index].replace("[ ]", "[x]");
    // ...
}
```

**Validation in `undone` command:**

```rust
"undone" => {
    // ... parsing and validation ...
    
    let index = number - 1;
    
    // âœ… NEW: Check if already pending
    if lines[index].contains("[ ]") {
        return Err("Task is already unmarked".into());
    }
    
    lines[index] = lines[index].replace("[x]", "[ ]");
    // ...
}
```

**Improved error message in `remove`:**

```rust
"remove" => {
    // ...
    if number == 0 || number > lines.len() {
        // âœ… More specific message
        return Err("This task doesn't exist or was already removed".into());
    }
    // ...
}
```

**Consistent filtering in all commands:**

```rust
// done, undone, and remove now all filter empty lines
let mut lines: Vec<String> = content
    .lines()
    .filter(|l| !l.trim().is_empty())  // â† Applied everywhere
    .map(|l| l.to_string())
    .collect();
```

**ğŸ§  Key Concepts:**

### Precondition validation

**What are preconditions?**

- Conditions that must be true before an operation
- Checked before performing the action
- Prevent invalid state transitions

**Example:**

```rust
// Precondition: task must be pending ([ ])
if lines[index].contains("[x]") {
    return Err("Task is already marked as completed".into());
}
// If we reach here, precondition is satisfied
lines[index] = lines[index].replace("[ ]", "[x]");
```

### Specific vs generic error messages

**Before v0.4.2:**

```rust
// Generic - doesn't tell user what's wrong
if number > lines.len() {
    return Err("Invalid task number".into());
}
```

**After v0.4.2:**

```rust
// Specific - explains the actual problem
if lines[index].contains("[x]") {
    return Err("Task is already marked as completed".into());
}
```

**Why this matters:**

**User experience comparison:**

```bash
# Generic error
$ todo done 1
Error: Invalid task number
# User thinks: "But 1 is valid! What's wrong?"

# Specific error  
$ todo done 1
Error: Task is already marked as completed
# User thinks: "Oh, I already did this one!"
```

**Good error messages:**

1. âœ… Tell user what went wrong
2. âœ… Explain why it's wrong
3. âœ… (Ideally) Suggest how to fix it

### State machine enforcement

**Valid transitions:**

```
[ ] â”€â”€doneâ”€â”€> [x]
[x] â”€â”€undoneâ”€â”€> [ ]
```

**Invalid transitions (now prevented):**

```
[x] â”€â”€doneâ”€â”€> [x]  âŒ "Task is already marked as completed"
[ ] â”€â”€undoneâ”€â”€> [ ]  âŒ "Task is already unmarked"
```

**This is defensive programming:**

- Assume user will make mistakes
- Validate before acting
- Provide helpful feedback

### Consistency across commands

**Pattern established:**

All mutation commands now follow:

1. Parse arguments
2. Validate arguments (bounds)
3. Read file with empty line filtering
4. Validate preconditions (state)
5. Perform operation
6. Write file
7. Confirm to user

**This consistency:**

- âœ… Makes code predictable
- âœ… Easier to maintain
- âœ… Easier to add new commands

**ğŸ”— Resources:**

- [Code v0.4.2](https://github.com/joaofelipegalvao/todo-cli/tree/v0.4.2)
- [Full diff](https://github.com/joaofelipegalvao/todo-cli/compare/v0.4.1...v0.4.2)