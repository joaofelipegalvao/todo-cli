# v1.5.0 - Due Dates and Tabular Display

**üéØ Goal:** Add due date tracking with `chrono` and improve visual display with tabular format

**üì¶ What We're Adding:**

**Due dates for deadline management:**

```bash
# Before - no deadline tracking:
todo add "Submit report" --high
# When is it due? No way to know!

# After - with due dates:
todo add "Submit report" --high --due 2026-02-15
todo list --overdue        # See what's late
todo list --due-soon       # See what's coming up
todo list --sort due       # Sort by deadline
```

**Why due dates matter:**

‚úÖ **Deadline awareness** - Never miss important dates  
‚úÖ **Smart filtering** - `--overdue`, `--due-soon`  
‚úÖ **Flexible sorting** - By priority, due date, or creation  
‚úÖ **Visual urgency** - Color-coded warnings  
‚úÖ **Automatic timestamps** - `created_at` tracks when task was added  

**üß† Key Concepts:**

### Adding the `chrono` crate

**In `Cargo.toml`:**

```toml
[dependencies]
colored = "2.1"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }  # ‚Üê ADD
```

**Why chrono?**

- Rust's standard library has basic `std::time` but no date parsing
- `chrono` is the de-facto standard for dates/times in Rust
- Feature `serde` enables automatic serialization

**Import:**

```rust
use chrono::{Local, NaiveDate};
```

**What's `NaiveDate`?**

- "Naive" = no timezone information
- Just year-month-day (2026-02-15)
- Perfect for due dates (we care about the day, not the hour)

### Adding date fields to `Task`

**Updated struct:**

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Task {
    text: String,
    completed: bool,
    priority: Priority,
    tags: Vec<String>,
    due_date: Option<NaiveDate>,  // ‚Üê NEW: Optional due date
    created_at: NaiveDate,         // ‚Üê NEW: Creation timestamp
}
```

**Why `Option<NaiveDate>`?**

```rust
// Not all tasks have deadlines:
due_date: Option<NaiveDate>

// Some(...) = has due date
// None = no due date
```

**Why `NaiveDate` for `created_at` (not `Option`)?**

```rust
created_at: NaiveDate  // Always has a value
```

Every task has a creation time, so no `Option` needed.

**Updated constructor:**

```rust
fn new(
    text: String,
    priority: Priority,
    tags: Vec<String>,
    due_date: Option<NaiveDate>,  // ‚Üê NEW parameter
) -> Self {
    Task {
        text,
        completed: false,
        priority,
        tags,
        due_date,
        created_at: Local::now().naive_local().date(),  // ‚Üê AUTO
    }
}
```

**Breaking down `created_at`:**

```rust
Local::now()           // Get current local time (with timezone)
    .naive_local()     // Convert to naive (remove timezone)
    .date()            // Extract just the date (no time)
```

**Result:** `NaiveDate` like `2026-02-03`

### Date methods on `Task`

**Check if overdue:**

```rust
fn is_overdue(&self) -> bool {
    if let Some(due) = self.due_date {
        let today = Local::now().naive_local().date();
        due < today && !self.completed
    } else {
        false  // No due date = can't be overdue
    }
}
```

**Breakdown:**

```rust
if let Some(due) = self.due_date  // Only if task has due date
```

Pattern matching on `Option`:

- If `Some(date)` ‚Üí extract date, continue
- If `None` ‚Üí skip to `else { false }`

```rust
let today = Local::now().naive_local().date();
due < today && !self.completed
```

Task is overdue if:

1. Due date is before today (`due < today`)
2. AND task is not completed (`!self.completed`)

**Check if due soon:**

```rust
fn is_due_soon(&self, days: i64) -> bool {
    if let Some(due) = self.due_date {
        let today = Local::now().naive_local().date();
        let days_until = (due - today).num_days();
        days_until >= 0 && days_until <= days && !self.completed
    } else {
        false
    }
}
```

**New concept: Date arithmetic**

```rust
let days_until = (due - today).num_days();
```

**What's happening:**

```rust
// Today: 2026-02-03
// Due: 2026-02-10
let days_until = (2026-02-10) - (2026-02-03);
// Result: Duration of 7 days
.num_days()  // Extract as i64: 7
```

### Parsing dates from command line

**In `add` command:**

```rust
"--due" => {
    if i + 1 >= args.len() {
        return Err("--due requires a date in format YYYY-MM-DD".into());
    }

    let date_str = &args[i + 1];
    match NaiveDate::parse_from_str(date_str, "%Y-%m-%d") {
        Ok(date) => due_date = Some(date),
        Err(_) => {
            return Err(format!(
                "Invalid date format: '{}'. Use YYYY-MM-DD",
                date_str
            )
            .into());
        }
    }

    i += 1;
}
```

**What's `parse_from_str`?**

```rust
NaiveDate::parse_from_str(date_str, "%Y-%m-%d")
```

**Parameters:**

- `date_str`: String to parse ("2026-02-15")
- `"%Y-%m-%d"`: Format pattern
  - `%Y` = 4-digit year (2026)
  - `%m` = 2-digit month (02)
  - `%d` = 2-digit day (15)

**Examples:**

```bash
# Valid:
todo add "Task" --due 2026-02-15  ‚úÖ

# Invalid:
todo add "Task" --due 02/15/2026  ‚ùå Wrong format
todo add "Task" --due 2026-13-01  ‚ùå Invalid month
todo add "Task" --due tomorrow    ‚ùå Not a date
```

### Enhanced sorting

**New sort options:**

```rust
match sort_by {
    "priority" => {
        indexed_tasks.sort_by(|(_, a), (_, b)| 
            a.priority.order().cmp(&b.priority.order())
        );
    }
    "due" => {
        indexed_tasks.sort_by(|(_, a), (_, b)| 
            match (a.due_date, b.due_date) {
                (Some(date_a), Some(date_b)) => date_a.cmp(&date_b),
                (Some(_), None) => std::cmp::Ordering::Less,
                (None, Some(_)) => std::cmp::Ordering::Greater,
                (None, None) => std::cmp::Ordering::Equal,
            }
        );
    }
    "created" => {
        indexed_tasks.sort_by(|(_, a), (_, b)| 
            a.created_at.cmp(&b.created_at)
        );
    }
    _ => {}
}
```

**Understanding the `due` sort:**

Pattern matching on two `Option`s:

| Case | a.due_date | b.due_date | Result | Why |
|------|------------|------------|--------|-----|
| 1 | `Some(date_a)` | `Some(date_b)` | Compare dates | Both have dates |
| 2 | `Some(_)` | `None` | a comes first (`Less`) | Tasks with dates come first |
| 3 | `None` | `Some(_)` | b comes first (`Greater`) | Tasks with dates come first |
| 4 | `None` | `None` | Equal | Neither has date |

**Why tasks with dates come first?**

**Logic:** Tasks with deadlines are more important than tasks without deadlines.

### Date filters

**Four new filters:**

```rust
if overdue {
    indexed_tasks.retain(|(_, t)| t.is_overdue());
}
if due_soon {
    indexed_tasks.retain(|(_, t)| t.is_due_soon(7));
}
if with_due {
    indexed_tasks.retain(|(_, t)| t.due_date.is_some());
}
if without_due {
    indexed_tasks.retain(|(_, t)| t.due_date.is_none());
}
```

**Examples:**

```bash
todo list --overdue        # Only late tasks
todo list --due-soon       # Due in next 7 days
todo list --with-due       # Any task with a due date
todo list --without-due    # Tasks with no deadline
```

### Tabular display format

**Major visual change:**

**Before (v1.4.0):**

```
1. üî¥ ‚è≥ Study Rust [learning, programming]
2. üü° ‚úÖ Fix bug [work, urgent]
```

**After (v1.5.0):**

```
  ID  P  S  Task                Tags            Due
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1  H  ‚è≥  Study Rust          learning, ...   in 5 days
   2  M  ‚úÖ  Fix bug             work, urgent
```

**Why the change?**

- ‚úÖ More professional
- ‚úÖ Easier to scan
- ‚úÖ Aligned columns
- ‚úÖ Better for many tasks

**New display function:**

```rust
fn display_task_tabular(
    number: usize,
    task: &Task,
    task_width: usize,
    tags_width: usize
) {
    let number_str = format!("{:>3}", number);
    let letter = task.priority.letter();
    let checkbox = if task.completed { "‚úÖ".green() } else { "‚è≥".bright_white() };

    // Truncate if too long
    let task_text = if task.text.len() > task_width {
        format!("{}...", &task.text[..task_width - 3])
    } else {
        task.text.clone()
    };

    // Format tags
    let tags_str = if task.tags.is_empty() {
        String::new()
    } else {
        let joined = task.tags.join(", ");
        if joined.len() > tags_width {
            format!("{}...", &joined[..tags_width - 3])
        } else {
            joined
        }
    };

    // Get due date text and color
    let due_text = get_due_text(task);
    let due_colored = get_due_colored(task, &due_text);

    // Print with alignment
    if task.completed {
        print!("{:>4} ", number_str.dimmed());
        print!(" {} ", letter);
        print!(" {} ", checkbox);
        print!("{:<width$}", task_text.green(), width = task_width);
        print!("  {:<width$}", tags_str.dimmed(), width = tags_width);
        println!("  {}", due_colored);
    } else {
        print!("{:>4} ", number_str.dimmed());
        print!(" {} ", letter);
        print!(" {} ", checkbox);
        print!("{:<width$}", task_text.bright_white(), width = task_width);
        print!("  {:<width$}", tags_str.cyan(), width = tags_width);
        println!("  {}", due_colored);
    }
}
```

**Formatting tricks:**

```rust
format!("{:>3}", number)   // Right-align in 3 chars: "  1"
format!("{:<40}", text)    // Left-align in 40 chars: "Task text             "
```

### Dynamic column widths

**Calculate optimal widths:**

```rust
fn calculate_column_widths(tasks: &[(usize, &Task)]) -> (usize, usize, usize) {
    let mut max_task_len = 10;   // Minimum width
    let mut max_tags_len = 4;
    let mut max_due_len = 3;

    for (_, task) in tasks {
        max_task_len = max_task_len.max(task.text.len());
        
        if !task.tags.is_empty() {
            let tags_str = task.tags.join(", ");
            max_tags_len = max_tags_len.max(tags_str.len());
        }
        
        let due_text = get_due_text(task);
        if !due_text.is_empty() {
            max_due_len = max_due_len.max(due_text.len());
        }
    }

    // Enforce maximum widths
    max_task_len = max_task_len.min(40);
    max_tags_len = max_tags_len.min(20);
    max_due_len = max_due_len.min(20);

    (max_task_len, max_tags_len, max_due_len)
}
```

**Why dynamic widths?**

Columns adjust to content!

### Due date text and colors

**Format due date:**

```rust
fn get_due_text(task: &Task) -> String {
    if let Some(due) = task.due_date {
        let today = Local::now().naive_local().date();
        let days_until = (due - today).num_days();

        if task.completed {
            String::new()  // Don't show for completed tasks
        } else if days_until < 0 {
            format!("late {} day{}", -days_until, if -days_until == 1 { "" } else { "s" })
        } else if days_until == 0 {
            "due today".to_string()
        } else if days_until <= 7 {
            format!("in {} day{}", days_until, if days_until == 1 { "" } else { "s" })
        } else {
            format!("in {} day{}", days_until, if days_until == 1 { "" } else { "s" })
        }
    } else {
        String::new()  // No due date
    }
}
```

**Examples:**

```rust
// days_until = -3
"late 3 days"

// days_until = 0
"due today"

// days_until = 1
"in 1 day"

// days_until = 5
"in 5 days"
```

**Apply colors:**

```rust
fn get_due_colored(task: &Task, text: &str) -> ColoredString {
    if text.is_empty() {
        return "".normal();
    }

    if let Some(due) = task.due_date {
        let today = Local::now().naive_local().date();
        let days_until = (due - today).num_days();

        if days_until < 0 {
            text.red().bold()         // Overdue: RED + BOLD
        } else if days_until == 0 {
            text.yellow().bold()      // Due today: YELLOW + BOLD
        } else if days_until <= 7 {
            text.yellow()             // Due soon: YELLOW
        } else {
            text.cyan()               // Future: CYAN
        }
    } else {
        text.normal()
    }
}
```

**Color scheme:**

| Days Until | Color | Style | Urgency |
|------------|-------|-------|---------|
| < 0 | Red | Bold | üö® LATE! |
| 0 | Yellow | Bold | ‚ö†Ô∏è TODAY! |
| 1-7 | Yellow | Normal | üìÖ Soon |
| > 7 | Cyan | Normal | üóìÔ∏è Future |

**üîó Resources:**

- [Code v1.5.0](https://github.com/joaofelipegalvao/todo-cli/tree/v1.5.0)
- [Full diff](https://github.com/joaofelipegalvao/todo-cli/compare/v1.4.0...v1.5.0)
- [chrono documentation](https://docs.rs/chrono/)