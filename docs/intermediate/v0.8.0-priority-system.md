# v0.8.0 - Priority System + Priority Filters

**ðŸŽ¯ Goal:** Add three-level priority system with visual indicators and filtering

**ðŸ“¦ Key Implementations:**

**Priority extraction function:**

```rust
fn extract_priority(line: &str) -> (&str, String) {
    let without_checkbox = line
        .replace("[ ]", "")
        .replace("[x]", "")
        .trim()
        .to_string();

    if without_checkbox.contains("(high)") {
        let text = without_checkbox.replace("(high)", "").trim().to_string();
        ("high", text)
    } else if without_checkbox.contains("(low)") {
        let text = without_checkbox.replace("(low)", "").trim().to_string();
        ("low", text)
    } else {
        ("medium", without_checkbox)
    }
}
```

**Priority emoji function:**

```rust
fn priority_emoji(priority: &str) -> String {
    match priority {
        "high" => "ðŸ”´".red().to_string(),
        "low" => "ðŸŸ¢".green().to_string(),
        _ => "ðŸŸ¡".yellow().to_string(),
    }
}
```

**Adding tasks with priority:**

```rust
"add" => {
    // ... validation ...
    
    let line = match args.len() {
        3 => format!("[ ] {}", task),  // No flag = medium
        
        4 => {
            let flag = args[3].as_str();
            match flag {
                "--high" => format!("[ ] (high) {}", task),
                "--low" => format!("[ ] (low) {}", task),
                _ => return Err(format!("Invalid flag '{}'. Use --high or --low", flag).into()),
            }
        }
        
        _ => return Err("Usage: todo add <task> [--high | --low]. Only one flag allowed".into()),
    };
    
    // Write to file...
}
```

**Multi-flag parsing in list:**

```rust
"list" => {
    let mut status_filter = "all";
    let mut priority_filter: Option<&str> = None;

    for arg in &args[2..] {
        match arg.as_str() {
            "--pending" => {
                if status_filter != "all" {
                    return Err("Use only one status filter (--pending or --done)".into());
                }
                status_filter = "pending";
            }
            "--done" => {
                if status_filter != "all" {
                    return Err("Use only one status filter".into());
                }
                status_filter = "done";
            }
            "--high" => {
                if priority_filter.is_some() {
                    return Err("Use only one priority filter".into());
                }
                priority_filter = Some("high");
            }
            "--low" => {
                if priority_filter.is_some() {
                    return Err("Use only one priority filter".into());
                }
                priority_filter = Some("low");
            }
            _ => return Err(format!("Invalid filter: {}", arg).into()),
        }
    }
    
    // Apply filters sequentially...
    
    // First filter by status
    valid_lines = match status_filter {
        "pending" => valid_lines.iter().filter(|l| l.contains("[ ]")).copied().collect(),
        "done" => valid_lines.iter().filter(|l| l.contains("[x]")).copied().collect(),
        _ => valid_lines,
    };

    // Then filter by priority (if specified)
    if let Some(pri) = priority_filter {
        valid_lines = valid_lines
            .iter()
            .filter(|line| {
                let (priority, _) = extract_priority(line);
                priority == pri
            })
            .copied()
            .collect();
    }
    
    // Dynamic title based on filters
    let title = match (status_filter, priority_filter) {
        ("pending", Some("high")) => "High priority pending tasks",
        ("pending", Some("low")) => "Low priority pending tasks",
        ("pending", None) => "Pending tasks",
        ("done", Some("high")) => "High priority completed tasks",
        ("done", Some("low")) => "Low priority completed tasks",
        ("done", None) => "Completed tasks",
        (_, Some("high")) => "High priority",
        (_, Some("low")) => "Low priority",
        _ => "Tasks",
    };
}
```

**ðŸ§  Key Concepts:**

### Tuple Return Types

```rust
fn extract_priority(line: &str) -> (&str, String) {
    //                â†‘ tuple of priority and cleaned text
}
```

**Why return a tuple?**

```rust
// Single return would need two function calls
let priority = get_priority(line);
let text = get_clean_text(line);

// Tuple return gets both at once
let (priority, text) = extract_priority(line);
```

**Tuple destructuring:**

```rust
let (priority, text) = extract_priority(line);
//  â†‘ priority    â†‘ text
```

### `Option<T>` for Optional Filters

```rust
let mut priority_filter: Option<&str> = None;
```

**Why `Option` instead of just `&str`?**

```rust
// Without Option - what value means "no filter"?
let mut priority_filter: &str = "";  // Empty string?
// Or maybe "none"? Or "all"? Ambiguous!

// With Option - clear meaning
let mut priority_filter: Option<&str> = None;  // No filter
priority_filter = Some("high");                 // High filter
```

**Pattern matching on Option:**

```rust
if let Some(pri) = priority_filter {
    // Only runs if filter is set
    // pri is the &str value inside Some
}
```

### String Manipulation Pipeline

```rust
let without_checkbox = line
    .replace("[ ]", "")
    .replace("[x]", "")
    .trim()
    .to_string();
```

**Step-by-step transformation:**

```rust
"[ ] (high) Buy milk"
    .replace("[ ]", "")  // "(high) Buy milk"
    .replace("[x]", "")  // "(high) Buy milk" (no change)
    .trim()              // "(high) Buy milk" (no extra spaces)
    .to_string()         // Owned String for further manipulation
```

### Match with Guards

```rust
match flag {
    "--high" => format!("[ ] (high) {}", task),
    "--low" => format!("[ ] (low) {}", task),
    _ => return Err(format!("Invalid flag '{}'. Use --high or --low", flag).into()),
}
```

**The `_` pattern catches everything else:**

- Invalid flags
- Missing flags
- Typos

**Error message includes the actual invalid value** for better UX.

### Multi-Flag Argument Parsing

**Challenge:** Users can combine flags in any order:

```bash
todo list --pending --high
todo list --high --pending
todo list --done --low
```

**Solution:** Sequential processing with validation:

```rust
for arg in &args[2..] {
    match arg.as_str() {
        "--pending" => { /* validate and set */ }
        "--high" => { /* validate and set */ }
        _ => return Err(format!("Invalid filter: {}", arg).into()),
    }
}
```

**Validation prevents conflicts:**

```rust
if status_filter != "all" {
    return Err("Use only one status filter (--pending or --done)".into());
}
```

### Pipeline Filtering Architecture

**Two-stage filtering:**

```rust
// Stage 1: Filter by status
valid_lines = match status_filter {
    "pending" => /* filter pending */,
    "done" => /* filter done */,
    _ => /* no change */,
};

// Stage 2: Filter by priority (if specified)
if let Some(pri) = priority_filter {
    valid_lines = /* filter by priority */;
}
```

**Why sequential filtering?**

- **Composable** - Can add more filter stages
- **Efficient** - Each stage works on smaller dataset
- **Clear** - Easy to understand and debug

### Dynamic Title Generation

```rust
let title = match (status_filter, priority_filter) {
    ("pending", Some("high")) => "High priority pending tasks",
    ("pending", Some("low")) => "Low priority pending tasks",
    // ... all combinations ...
    _ => "Tasks",
};
```

**Tuple pattern matching:**

- First element = status filter
- Second element = priority filter (Option)
- Covers all possible combinations
- Provides descriptive titles

**ðŸ”— Resources:**

- [Code v0.8.0](https://github.com/joaofelipegalvao/todo-cli/tree/v0.8.0)
- [Full diff](https://github.com/joaofelipegalvao/todo-cli/compare/v0.7.0...v0.8.0)