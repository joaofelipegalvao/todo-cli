# v1.2.0 - Struct Refactoring (Type-Safe Architecture)

**ðŸŽ¯ Goal:** Replace string parsing with type-safe structs and enums for maintainability and extensibility

**ðŸ“¦ The Problem We're Solving:**

**Before v1.2.0:**

Every command parsed strings manually:

```rust
// Parsing priority from strings (repeated everywhere)
let without_checkbox = line.replace("[ ]", "").replace("[x]", "").trim();
if without_checkbox.contains("(high)") {
    let text = without_checkbox.replace("(high)", "").trim();
    // ... handle high priority
} else if without_checkbox.contains("(low)") {
    // ... handle low priority
}

// Checking completion status (string matching)
if line.contains("[x]") {
    // completed
} else {
    // pending
}
```

**Problems:**

âŒ String parsing repeated in every command  
âŒ No type safety - typos like `"hihg"` compile fine  
âŒ Hard to add new fields (timestamps, tags)  
âŒ Can't leverage Rust's type system  
âŒ Prone to bugs (what if format changes?)  

**ðŸ“¦ The Solution: Structs + Enums**

**Core data structures:**

```rust
#[derive(Debug, Clone, PartialEq, Copy)]
enum Priority {
    High,
    Medium,
    Low,
}

#[derive(Debug, Clone, PartialEq)]
struct Task {
    text: String,
    completed: bool,
    priority: Priority,
}
```

**Why this is revolutionary:**

âœ… **Type-safe** - compiler catches mistakes  
âœ… **Self-documenting** - clear what a Task contains  
âœ… **Extensible** - add fields easily  
âœ… **DRY** - parsing logic in ONE place  
âœ… **Testable** - can unit test Task methods  

**ðŸ§  Key Concepts:**

### What is a `struct`?

Think of it as a **custom data type** that groups related data:

```rust
// Instead of passing around 3 separate values:
fn display_task(text: String, completed: bool, priority: String) { }

// We bundle them into one logical unit:
fn display_task(task: &Task) { }
```

**Real-world analogy:**

```rust
// Like a form with labeled fields:
struct Person {
    name: String,      // "John Doe"
    age: u32,          // 25
    email: String,     // "john@example.com"
}

// Instead of passing 3 separate strings/numbers around
```

**Our Task struct:**

```rust
struct Task {
    text: String,       // "Study Rust"
    completed: bool,    // false
    priority: Priority, // High
}
```

### What is an `enum`?

An enum represents **one of several possible values**:

```rust
enum Priority {
    High,    // â† can ONLY be one of these
    Medium,  // â† mutually exclusive
    Low,     // â† not multiple at once
}
```

**Why enum vs strings?**

```rust
// âŒ String approach - error-prone
let priority = "hihg";  // Typo! Compiles fine, breaks at runtime
if priority == "high" { }  // Won't match, silent bug

// âœ… Enum approach - compile-time safety
let priority = Priority::Hihg;  // ERROR: no variant `Hihg`
// Won't compile! Catches typo immediately
```

**Enums are exhaustive:**

```rust
match priority {
    Priority::High => "ðŸ”´",
    Priority::Medium => "ðŸŸ¡",
    // Forgot Low? âŒ Compiler error: "non-exhaustive patterns"
}
```

Compiler **forces** you to handle all cases!

### The `#[derive(...)]` attributes

```rust
#[derive(Debug, Clone, PartialEq, Copy)]
enum Priority {
    High,
    Medium,
    Low,
}
```

**What do these mean?**

**`Debug`** - Enables printing for debugging:

```rust
let pri = Priority::High;
println!("{:?}", pri);  // Output: High
```

**`Clone`** - Enables creating copies:

```rust
let pri1 = Priority::High;
let pri2 = pri1.clone();  // Explicit copy
```

**`PartialEq`** - Enables comparison:

```rust
if task.priority == Priority::High {
    // This works because of PartialEq
}
```

**`Copy`** - Enables implicit copying:

```rust
let pri1 = Priority::High;
let pri2 = pri1;  // Automatically copied (not moved!)
// pri1 still valid here âœ…
```

### `impl` blocks - Adding methods to types

```rust
impl Priority {
    fn order(&self) -> u8 {
        match self {
            Priority::High => 0,
            Priority::Medium => 1,
            Priority::Low => 2,
        }
    }

    fn emoji(&self) -> ColoredString {
        match self {
            Priority::High => "ðŸ”´".red(),
            Priority::Medium => "ðŸŸ¡".yellow(),
            Priority::Low => "ðŸŸ¢".green(),
        }
    }
}
```

**What's `&self`?**

```rust
fn emoji(&self) -> ColoredString
//       â†‘ "self" = the Priority value we're calling this on
```

**Usage:**

```rust
let pri = Priority::High;
let icon = pri.emoji();  // "self" is `pri`
//         â†‘ calling method ON the value
```

### Implementing Task methods

```rust
impl Task {
    // Constructor - creates new Task
    fn new(text: String, priority: Priority) -> Self {
        Self {
            text,
            completed: false,  // Always starts incomplete
            priority,
        }
    }

    // Convert Task â†’ string format for file
    fn to_line(&self) -> String {
        let checkbox = if self.completed { "[x]" } else { "[ ]" };
        let pri_str = match self.priority {
            Priority::High => " (high)",
            Priority::Low => " (low)",
            Priority::Medium => "",
        };
        format!("{}{} {}", checkbox, pri_str, self.text)
    }

    // Parse string â†’ Task (returns Option because can fail)
    fn from_line(line: &str) -> Option<Self> {
        // ... parsing logic ...
    }

    // Mark as done
    fn mark_done(&mut self) {
        self.completed = true;
    }

    // Mark as pending
    fn mark_undone(&mut self) {
        self.completed = false;
    }
}
```

### Centralized I/O with `load_tasks` and `save_tasks`

**Before - I/O scattered everywhere:**

```rust
// In 'add' command
let mut file = OpenOptions::new().append(true).open("todos.txt")?;
writeln!(file, "[ ] (high) {}", task)?;

// In 'done' command
let content = fs::read_to_string("todos.txt")?;
let mut lines: Vec<String> = content.lines().map(|l| l.to_string()).collect();
// ... modify ...
fs::write("todos.txt", lines.join("\n"))?;
```

**After - Centralized:**

```rust
fn load_tasks() -> Result<Vec<Task>, Box<dyn Error>> {
    match fs::read_to_string("todos.txt") {
        Ok(content) => {
            let tasks: Vec<Task> = content
                .lines()
                .filter(|l| !l.trim().is_empty())
                .filter_map(Task::from_line)  // Parsing in ONE place
                .collect();
            Ok(tasks)
        }
        Err(_) => Ok(Vec::new()),  // Missing file = empty list
    }
}

fn save_tasks(tasks: &[Task]) -> Result<(), Box<dyn Error>> {
    let lines: Vec<String> = tasks.iter().map(|t| t.to_line()).collect();
    fs::write("todos.txt", lines.join("\n") + "\n")?;
    Ok(())
}
```

**Now every command:**

```rust
"done" => {
    let mut tasks = load_tasks()?;  // Load
    tasks[index].mark_done();       // Modify
    save_tasks(&tasks)?;            // Save
}
```

### Impact of Refactoring

**Code metrics:**

| Metric | Before | After | Change |
|--------|--------|-------|--------|
| Total lines | ~180 | ~115 | **-36%** |
| `add` command | 30 lines | 20 lines | -33% |
| `list` command | 90 lines | 60 lines | -33% |
| `done` command | 25 lines | 15 lines | -40% |
| `search` command | 35 lines | 20 lines | -43% |

**36% less code with MORE features!**

**Extensibility unlocked:**

Now trivial to add:

âœ… Timestamps:
```rust
struct Task {
    // ...
    created_at: DateTime,
    completed_at: Option<DateTime>,
}
```

âœ… Tags:
```rust
struct Task {
    // ...
    tags: Vec<String>,
}
```

**ðŸ”— Resources:**

- [Code v1.2.0](https://github.com/joaofelipegalvao/todo-cli/tree/v1.2.0)
- [Full diff](https://github.com/joaofelipegalvao/todo-cli/compare/v1.1.0...v1.2.0)
- [Rust Book - Structs](https://doc.rust-lang.org/book/ch05-00-structs.html)
- [Rust Book - Enums](https://doc.rust-lang.org/book/ch06-00-enums.html)